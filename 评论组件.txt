评论组件开发（一）

评论组件（组）：
CommentApp	  ----评论功能的整体用一个叫 CommentApp 的组件包含起来。CommentApp 包含上部和下部两部分。
CommentInput：----负责用户输入区域，包括输入评论的用户名、评论内容和发布按钮，这一部分功能划分到一个单独的组件 CommentInput 中。
CommentList： ----评论列表，用一个叫 CommentList 的组件负责列表的展示。
Comment：	  ----每个评论列表项由独立的组件 Comment 负责显示，这个组件被 CommentList 所使用。
结构：
-CommentApp
	-CommentInput
	+CommentList
		-Comment
		-Comment
		...

CommentInput 设置state属性关联输入数据：
constructor () {
	super()
	this.state = {
	  username: '',
	  content: ''
	}
}
绑定输入数据到state属性：
<input value={this.state.username} onChange={(event)=>{this.setState({username: event.target.value})}} />

将 CommentInput 的 state 当中最新的评论数据传递给父组件 CommentApp ，然后让父组件把这个数据传递给 CommentList 进行渲染:
...
	<button
	  onClick={this.handleSubmit.bind(this)}>
	  发布
	</button>
...
-------------------------------------------------
...
handleSubmit () {
    if (this.props.onSubmit) {
      const { username, content } = this.state
      this.props.onSubmit({username, content})
    }
    this.setState({ content: '' })
}
...
-------------------------------------------------
---CommentApp 使用state属性 comments 保存评论数据：
constructor () {
    super()
    this.state = {
      comments: []
    }
}
---父组件 CommentApp 传递回调函数给 CommentInput：
...
<CommentInput
	onSubmit={this.handleSubmitComment.bind(this)} />
<CommentList />
...

handleSubmitComment (comment) {
	comments: this.state.comments.push(comment)
}

---CommentApp 传递评论数据给 CommentList：
<CommentList comments={this.state.comments}/>

---CommentList 使用 Comment 渲染数据：
<div>
	{this.props.comments.map((comment, i) =>
	  <Comment comment={comment} key={i} />
	)}
</div>

Comment渲染数据：
<div className='comment'>
	<div className='comment-user'>
	  <span>{this.props.comment.username} </span>：
	</div>
	<p>{this.props.comment.content}</p>
</div>
----------
----------完整源码地址：https://github.com/huzidaha/react-naive-book-examples/tree/master/comment-app
----------

---状态提升：
将组件之间共享的状态交给组件最近的公共父节点保管，然后通过 props 把状态传递给子组件，实现在组件之间共享数据。
为什么需要状态提升：
1.同级组件需要共享数据；
2.其他组件会影响本组件要使用的数据；
---状态提升的问题：
一旦发生了提升，你就需要修改原来保存这个状态的组件的代码，也要把整个数据传递路径经过的组件都修改一遍，
好让数据能够一层层地传递下去。这样对代码的组织管理维护带来很大的问题。



===*************************************************************************************************===
使用ref属性进行dom操作--->自动聚焦
<textarea
	ref={(textarea) => this.textarea = textarea}
	value={this.state.content}
	onChange={this.handleContentChange.bind(this)} 
/>
componentDidMount () {
	this.textarea.focus()
}
使用localStorage持久化输入：
<input
	value={this.state.username}
	onBlur={this.handleUsernameBlur.bind(this)}
	onChange={this.handleUsernameChange.bind(this)} 
/>
//私有方法
_saveUsername (username) {
	localStorage.setItem('username', username)
}

handleUsernameBlur (event) {
	this._saveUsername(event.target.value)
}
组件挂载前从localStorage获取数据：
componentWillMount () {
	this._loadUsername()
}

_loadUsername () {
	const username = localStorage.getItem('username')
	if (username) {
		this.setState({ username })
	}
}
删除Comment：
CommentApp传递回调函数给CommentList，CommentList再传递回调函数到Comment；
CommentApp的回调函数执行是通过comments.splice(index, 1)删除comment。
使用dangerouslySetInnerHTML 将输入的``中的内容使用code显示：
<p dangerouslySetInnerHTML={{
  __html: this._getProcessedContent(comment.content)
}} />
---------------------------------------------------------
 _getProcessedContent (content) {
    return content
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;")
      .replace(/`([\S\s]+?)`/g, '<code>$1</code>')
  }

