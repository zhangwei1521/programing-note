										Mysql学习
mysql 5.7.23 压缩版安装：
将下的压缩包解压到D:\zhangwei\devtools\下：mysql-5.7.23-winx64
在D:\zhangwei\devtools\mysql-5.7.23-winx64\目录下新建文件：my.ini
	[mysqld]
	#设置3306端
	port = 3306
	# 设置mysql的安装目录
	basedir=D:\zhangwei\devtools\mysql-5.7.23-winx64
	# 设置mysql数据库的数据的存放目录
	datadir=D:\zhangwei\devtools\mysql-5.7.23-winx64\data
	# 允许最大连接数
	max_connections=200
	# 服务端使用的字符集默认为8比特编码的latin1字符集
	character-set-server=utf8
	# 创建新表时将使用的默认存储引擎
	default-storage-engine=INNODB
	sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
	[mysql]
	# 设置mysql客户端默认字符集
	default-character-set=utf8
(踩坑：如果目录是D:\software\mysql-5.7.25-winx64，D:后面的\s会被当成空格，所以需要转义：
D:\\software\mysql-5.7.25-winx64
踩坑：需要在mysql安装目录的bin目录下执行安装命令，其他目录下虽然也可以安装成功，但是会
在以后启动服务时报错。)
配置环境变量：
	MYSQL_HOME		D:\zhangwei\devtools\mysql-5.7.23-winx64\
	path			%MYSQL_HOME%\bin
安装MySQL服务：
	1) 以管理员身份运行cmd，进入mysql根目录E:\Program Files\mysql\mysql-5.7.23-winx64 
	2) 运行mysqld --install，控制台提示Services successfully installed，运行成功。 
		① 如果显示已存在，可以使用mysqld --remove后再次执行 
		② 如果报错，可能是权限不足(没有以管理员身份运行cmd) 
	3) 运行mysqld --initialize，生成data目录 
	4) 运行net start mysql启动服务
可能遇到的问题：
msvcr120.dll文件缺失，无法安装mysql，需要下载：Visual C++ Redistributable Packages for Visual Studio 2013
（直接下载msvcr120.dll好像没起作用）地址：https://www.microsoft.com/zh-CN/download/details.aspx?id=40784
最后一步启动mysql服务报错：发现系统错误2，系统找不到指定的文件：这是因为解压版不会主动去修改注册表，所以需要
手动去修改注册表：
	HKEY_LOCAL_MACHINE - SYSTEM - CurrentControlSet - services - mysql - ImagePath
需要将ImagePath这项的值改为解压的mysqld路径："D:\zhangwei\devtools\mysql-5.7.23-winx64\bin\mysqld" (保留引号)
    windows下默认是关闭了binlog的，开启binlog需配置:
        log-bin=mysql-bin-log
        binlog-format=Row
        server-id=123456
    查看binlog状态：
        show variables like 'log_bin';
    log_bin 这个变量是不能通过命令修改的。



修改密码：
	1) 运行net stop mysql，停止服务 
	2) 运行mysqld --skip-grant-tables，开启无密码模式的MySQL Server 
	3) 开启新终端，运行mysql -u root -p，进入MySQL 
	4) 更新root密码 
		运行update mysql.user set authentication_string=password("root") where user="root"; 
	5) 运行flush privileges，刷新权限 
	6) 运行quit，退出 
	7) 运行mysql -u root -p进入mysql输入密码root 
	8) 更改root密码 
		① SET PASSWORD = PASSWORD('1234') 
		② ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER 
		③ FLUSH PRIVILEGES

非安装版本可能会出现时区问题,设置时区：
set global time_zone='+8:00';	
查看时区设置：show variables like '%time_zone%';


centos7 安装 mariadb 10.4.10:
	下载二进制tar压缩包：
		wget https://downloads.mariadb.org/interstitial/mariadb-10.4.10/bintar-linux-systemd-x86_64/mariadb-10.4.11-linux-systemd-x86_64.tar.gz/from/http%3A//mirror.rackspace.com/mariadb/
	新增mysql用户和mysql用户组：
		groupadd mysql
		useradd -g mysql mysql
	解压：
		cd /usr/local
		tar -zxvpf /usr/local/src/mariadb-10.4.10-linux-systemd-x86_64.tar.gz
	建软链接：
		ln -s mariadb-10.4.10-linux-systemd-x86_64 mysql
	初始化：
		cd mysql
		./scripts/mysql_install_db --user=mysql
	修改目录用户：
		chown -R root:root .
		chown -R mysql:mysql data
	添加配置文件：
		vim /etc/my.cnf
		#mysql配置文件
		[mysqld]
		port            = 3306
		socket          = /tmp/mysql.sock
		basedir = /usr/local/mysql
		datadir= /usr/local/mysql/data
		innodb_file_per_table = on
		skip_name_resolve = on
		skip-external-locking
		key_buffer_size = 16M
		max_allowed_packet = 1M
		table_open_cache = 64
		sort_buffer_size = 512K
		net_buffer_length = 8K
		read_buffer_size = 256K
		read_rnd_buffer_size = 512K
		myisam_sort_buffer_size = 8M
	注：配置文件可以放在/etc和/home/username或/root目录下。
	配置为systemd服务：
		cp support-files/systemd/mariadb.service /usr/lib/systemd/system/mariadb.service
	启动：
		systemctl start mariadb
	安全设置(设置修改root密码等):
		./bin/mysql_secure_installation
	授权root远程主机登录(需登录进mysql)：
		grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;
		或者
		update mysql.user set host = '%' where user = 'root'  and host='localhost';
		flush privileges;
	配置path环境变量：
		vim /etc/bashrc
		
		MARIADB_HOME=/usr/local/mysql
		PATH=$PATH:$MARIADB_HOME/bin

		source /etc/bashrc
	

mysql数据类型：
	整数型：
		tinyint			-- 1个字节
		smallint 		-- 2个字节
		mediumint		-- 3个字节
		int				-- 4个字节
		bigint			-- 8个字节
		注：id int(4), 这种写法只是指定在id字段字符位长度小于等于4时使用4个字符位宽显示该字段。	
	浮点数型：
		float			-- 4个字节
		double			-- 8个字节
		注：sal double(7,2), 这种写法表示总位数为7位，小数位数为2位，如果小数位数超过2位，将执行5舍6入。处理小数位后如果总位数
超过7位，mysql将抛出错误。小数位数总是会保留2位，如果没有小数位就使用.00占位，所以整数位最多只有5位（不包括符号位）
	decimal类型：用于保存需要保持精度的数据
		decimal			-- MySQL分别为整数和小数部分分配存储空间。 MySQL使用二进制格式存储DECIMAL值。使用4个字节存储9位数字（
不足9位使用4个字节，超出部分规则：剩余1-2位使用1个字节保存，超出3-4位使用2个字节保存，超出5-6位使用3个字节保存，超出7-9个字节使用
4个字节保存）。对于decimal(19,9)，小数部分9位使用4个字节保存，整数部分10使用4+1=5个字节保存。decimal使用4舍5入。
	日期、时间类型：
		year			-- 1个字节，1901 ~ 2155
		time			-- 3个字节，-838:59:59 ~ 838:59:59
		date			-- 3个字节，1000-01-01 ~ 9999-12-3
		datetime		-- 8个字节,yyyy-mm-dd hh:mm:ss
		timestamp		-- 4个字节，1970-01-01 00:00:00 ~ 2038-01-19 03:14:07
	字符串：
		char			-- char(M)，定长M位(字符)，这里的位数和英文、中文无关，所以这个M位不是指的字节，但是char最多只能存256个字节
		varchar			-- varchar(M),变长M位，最多M位，varchar最多可以存65535个字节
		tinytext		-- 最大255B（字节）
		text			-- 最大65KB
		mediumtext		-- 最大16MB
		longtext		-- 最大4GB
		enum			-- 只能保存指定枚举值当中的某个，两个隐含值：null、''
		set				-- 只能保存指定set集合中的某个子集
	二进制：
		bit				-- bit(M) M位长
		binary			-- binary(M) 定长M个字节，最多256个字节
		varbinary		-- varbinary(M) 变长M个字节，最多65535个字节
		tinyblob		-- 最大255B（字节）
		blob			-- 最大65KB
		mediumblob		-- 最大16MB
		longblob		-- 最大4GB
	
	获取当前时间戳(timestamp)：
		select current_timestamp();	或
		select current_timestamp;
	获取当前时间(datetime)：
		select now();
触发器
	准备：
	create table goods(
		gid int,
		name varchar(),
		num int
	);

	create table orders(
		oid int,
		gid int,
		much int	
	);

	insert into goods values 
	(1,'cat',55),
	(2,'dog',45),
	(3,'pig',50);

# tg1 -- insert插入orders表后同步修改goods表库存

delimiter $
create trigger tg1
after
insert 
on 
orders
for each row
begin
update goods set num=num-new.much where gid=new.gid;
end$
delimiter ;

# tg2 -- update修改orders表前修改goods表库存

delimiter $
create trigger tg2 
before 
update 
on 
orders
for each row
begin 
update goods set num=num+old.much-new.much where gid=old.gid;
end$
delimiter ;

# tg3 -- delete删除orders表后修改goods表库存

delimiter $
create trigger tg3
after 
delete 
on orders 
for each row
begin
update goods set num=num+old.much where gid=old.gid;
end$
delimiter ;

# tg4 -- insert插入orders表前判断much是否大于goods表的num值，如果大于就修改much为goods表的num值

delimiter $
create trigger tg4 
before 
insert 
on 
orders 
for each row
begin
declare snum int;
select num into snum from goods where gid=new.gid;
if new.much>snum then
	set new.much=snum;
end if;
update goods set num=num-new.much where gid=new.gid;
end$
delimiter ;

# for each row 说明
表示操作影响每一行都会执行一次触发器中的sql
mysql、oracle都支持
oracle还可以不写这一条语句，表示一条影响多行的语句只会触发一次触发器中的sql语句
mysql5.5及之前的版本都必须要写这一条语句

分页查询：
	select * from table_name order by id limit rownum,pagesize;

建立索引：
    create index i_emp_num on emp(empNum);
建立unique索引：
    create unique index i_emp_id on emp(empId);
标准sql中可以建立cluster索引：
    create cluster index i_name on table_name(attr_name);
    建立这种索引后加入的数据在写入物理文件时将尽可能按照 cluster 索引属性进行靠近存储。
mysql的 MyISAM 存储引擎不支持 cluster 索引，而 InnoDB 存储引擎默认使用主键作为 cluster 索引，
而且不能修改。所以在 mysql 中手动创建 cluster 索引会提示语法错误。

排名：
	建表：
		CREATE TABLE `scores` (
			`pid` int(2) NOT NULL AUTO_INCREMENT,
			`name` varchar(50) NOT NULL,
			`score` int(2) NOT NULL,
			PRIMARY KEY (`pid`),
			UNIQUE KEY `name` (`name`)
		) ENGINE=InnoDB  DEFAULT CHARSET=latin1;
	准备数据：
		INSERT INTO `scores` (`pid`, `name`, `score`) VALUES
			(1, 'Samual', 85),
			(2, 'Vino', 90),
			(3, 'John', 78),
			(4, 'Andy', 85),
			(5, 'Brian', 88),
			(6, 'Dew', 65),
			(7, 'Kris', 67),
			(8, 'William', 74),
			(9, 'George', 95),
			(10, 'Peter', 82),
			(11, 'Tom', 92),
			(12, 'Andre', 62);
	根据score排名：
		SELECT pid, name, score, @curRank := @curRank + 1 AS rank
		FROM scores p, (SELECT @curRank := 0) q
		ORDER BY score DESC, name;
	根据score排名(得分相同则排名并列，例如 1 1 2 3 3 4...)：
		SELECT pid, name, score, 
			CASE 
				WHEN @prevRank = score THEN @curRank 
				WHEN @prevRank := score THEN @curRank := @curRank + 1
			END AS rank
		FROM scores p, (SELECT @curRank :=0, @prevRank := NULL) r
		ORDER BY score;
	根据score排名(得分相同则排名并列,后续记录排名不接续并列记录排名，例如 1 1 3 4 4 6..)：
		SELECT pid, name, score, rank 
		FROM (
			SELECT pid, name, score,
					@curRank := IF(@prevRank = score, @curRank, @incRank) AS rank, 
					@incRank := @incRank + 1, 
					@prevRank := score
			FROM scores p, ( SELECT @curRank :=0, @prevRank := NULL, @incRank := 1) r 
			ORDER BY score) s

modify column name:
    alter table table_name change old_col_name new_col_name varchar(40);

functions:
    rand()      //return a random decimal between 0 and 1
        select rand();
    round(x)     //return the result of round-up or round-down of x
        select round(rand() * 10);
    floor(x)    //return the result of round-down of x
        select floor(rand() * 10);
    ceiling(x)  //return the result of round-up of x
        select ceiling(rand() * 10);
    exmaple1:
        select t.decimal,round(t.decimal),floor(t.decimal),ceiling(t.decimal) from (select rand()*10 as 'decimal') t;
    exmaple2:
        select 50+floor(rand() * (100-50+1));
    md5(x)      //get a 32 bit random string
        select md5(rand() * 10000);

指定mysql运行时参数：
    通过命令行参数指定：
        mysqld_safe --datadir=/data/sql_data
    通过配置文件指定，查看默认配置文件：
        mysqld --help --verbose | grep -A 1 'Default options'
        返回：/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf
    
查看session变量：
    show variables where variable_name in ('wait_timeout','interactive_timeout');
查看对应的全局变量：
    select variable_name,variable_value 
    from information_schema.global_variables 
    where variable_name in ('interactive_timeout','wait_timeout');
修改session变量：
    set session wait_timeout=3600;
修改全局变量：
    set global wait_timeout=3600;
    注：interactive_timeout表示MySQL服务器关闭交互式连接前等待活动的秒数；wait_timeout表示MySQL服务器关闭非交互连接之前
等待活动的秒数。interactive_timeout和wait_timeout的默认值都是28800（8小时）。
    交互式连接指的是通过MySQL客户端连接数据库，非交互连接则是通过JDBC等连接数据库。
    对于非交互式连接，类似于jdbc连接，wait_timeout的值继承自服务器端全局变量wait_timeout。
    对于交互式连接，类似于MySQL客户单连接，wait_timeout的值继承自服务器端全局变量interactive_timeout。

内存配置相关参数：
    sort_buffer_size：对数据进行排序的时候使用的缓冲区，针对连接。可以通过增大这个参数的大小来提高order by或者group by的处理性能。
    join_buffer_size：多表join时使用的缓冲区，针对连接，并且每个join都分配一个缓冲区，所以一个连接可以有多个join缓冲区。
    read_buffer_size：主要用于当需要顺序读取数据的时候，如无法使用索引的情况下的全表扫描，全索引扫描等，MySQL 按照数据的存储顺序依
次读取数据块，每次读取的数据块首先会暂存在read_buffer_size中，当 buffer 空间被写满或者全部数据读取结束后，再将buffer中的数据返回给
上层调用者，以提高效率。这个变量值需要时4k的倍数。针对连接。
    read_rnd_buffer_size：用于进行非顺序读取（随机读取）数据块的时候，MySQL利用这个缓冲区暂存读取的数据。针对连接。
    innodb_buffer_pool_size：innodb引擎使用来缓存索引、行数据、自适应哈希索引、插入缓存、锁和其他的内部数据结构。
    key_buffer_size：myisam引擎使用来缓存索引。
    innodb_file_per_table：用于设置是否采用单独的表空间存储每个innodb表。

查看引擎列表：
    show engines;
查看默认的存储引擎：
    show variables like '%storage_engine%';
查看某表使用的引擎：
    show create table table_name;

查询mysql版本：
    select version();


join语句执行过程：
    sql: 
        SELECT 
            <row_list> 
        FROM 
            <left_table> 
            <inner|left|right> JOIN <right_table> 
            ON <join condition> 
        WHERE 
            <where_condition>
    执行顺序如下:
        FROM：对left_table和right_table执行笛卡尔积，产生第一张虚拟表vt1。行数为n*m（n为左表的行数，m为右表的行数）；
        ON：根据ON的条件逐行筛选vt1，将结果插入第一张虚拟表vt2中；
        JOIN：添加外部行，如果指定的是LEFT JOIN(LEFT OUTER JOIN)，则先遍历一遍左表的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为NULL，形成vt3，
            如果指定的是RIGHT JOIN则遍历右表并将不在vt2中的行加入vt2得到vt3。如果指定的是INNER JOIN，则不添加外部行，即vt2=vt3;
        WHERE：对vt3进行条件过滤，满足条件的行被输出到vt4
        SELECT：取出vt4的指定字段到vt5
标准SQL还定义了FULL JOIN，单mysql不支持。FULL JOIN指的是在JOIN阶段会将左右表中不满足ON条件的行都加入虚拟表。