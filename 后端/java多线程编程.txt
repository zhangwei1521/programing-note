                                                    java多线程编程
                                        (参考书籍：java多线程编程实战指南-核心篇)
    第一章 线程和多线程编程简介
    什么是进程？进程是程序的运行实例，运行一个java程序就是启动一个java虚拟机进程。进程是操作系统分配资源（内存空间、文件句柄等）的基本
单元。
    linux查看运行中的进程：
        ps -ef | grep "pname" | grep -v "grep"
    windows下查看运行中的进程：
        tasklist | findstr pid/"pname"
    什么是线程？线程是进程中可独立执行的最小单元，一个进程可以包含多个线程。一个进程中的所有线程共享操作系统分配给该进程的资源。线程用
于完成实际的计算工作，通常称为线程的任务。
    什么是多线程编程？多线程编程是一种以线程为基本抽象单元的编程模式，java语言中多线程编程和面向对象编程是相容的。
    多线程编程不仅仅只是使用多个线程完成计算，还需要考虑多种条件和环境，如果设计不合理，多线程不但不能提高程序运行的效率，反而会降低程
序的运行效率，甚至影响程序的正确运行。
    多线程编程的优点：正确且合理的多线程设计可以充分利用现代多核处理器的计算能力，提高程序的效率和使用体验，比如web服务器为每个请求提供
一个线程，可以实现请求不需要等待其他请求的执行；某些GUI程序使用不同的线程处理界面展示和内部计算，可以保证启动时不需要等待内部计算完成才
展示程序界面。
    java提供一个类：java.lang.Thread作为java平台线程的实现。Thread类和其子类的实例对象就是一个线程。
    Thread类提供一个实例方法：run，这个方法是线程任务处理逻辑的入口方法，所以线程任务处理逻辑可以直接在这个方法中实现，也可以在这个方
法中调用。线程对象的run方法由JVM在运行线程时直接调用。
    运行一个线程就是让JVM去执行线程对象的run方法，这需要启动线程。Thread类提供一个实例方法start，调用线程对象的start方法就可以启动这
个线程。
    使用start方法启动一个线程只是通知JVM运行线程实例，但是这个线程的实际运行时间由线程调度器（操作系统提供）决定，所以start方法调用后
并不意味着这个线程已经开始运行。
    Thread类提供两个构造方法：Thread()和Thread(Runnale task)；因此可以使用两种方式来创建线程。一种是实现一个继承Thread的类，在该类
中覆写Thread类的run方法，在覆写的run方法中实现或调用任务处理逻辑。第二种是实现一个实现java.lang.Runnale接口的类，并在实现的run方法中
实现或调用任务处理逻辑，使用第二个构造函数来创建线程对象。
        public class WelcomApp {
            public static void main(String[] args) {
                Thread welcomeThread = new WelcomThread();
                welcomeThread.start();

                Thread welcomeThread2 = new Thread(new WelcomeTask());
                welcomeThread2.start();

                System.out.printf("1.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }

        class WelcomThread extends Thread{
            @Override
            public void run(){
                System.out.printf("2.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }

        class WelcomeTask implements Runnable{
            @Override
            public void run() {
                System.out.printf("3.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }
    第一种创建线程的方式是使用继承模型，第二种是应用组合模式，一般来说，组合模式下，类之间的耦合度更低，所以通常选用这种模式创建线程。
    run方法执行结束或run方法执行过程中抛出异常，线程的运行就结束了，线程占用的系统资源就会被GC。
    线程不能重复运行，也就是说线程的start方法只能调用一次，重复调用将会抛出异常：IllegalThreadStateException
    java创建一个Thread对象实例和普通java对象的不同：JVM会为线程对象分配一块称为调用栈的内存空间（用于跟踪java方法调用关系），此外，
可能还会关联线程对象和内核线程（由操作系统支持）。所以创建一个线程对象比普通对象成本更高。
    java代码总是由某个线程来执行的，该线程称为这段代码的执行线程。程序运行时，同一段代码可以被多个线程执行，在这段代码中可以使用
Thread.currentThread()获取正在执行这段代码的线程。
    Thread类是Runnable接口的一个实现类，它的run方法如下：
        public void run(){
            if(target != null){
                target.run();
            }
        }
    可见，如果直接new Thread()，这个线程什么也不会做，所以继承Thread类的子类必须覆写run方法。上面的target是一个Runnable的实例，通过
new Thread(Runnable task)传入的task将被设置为创建线程对象的target。
    如果使用一个Runnable实例对象去创建多个线程对象，而这个Runnable实例的run方法中使用了自己的对象变量，就有可能出现竞态和线程安全问题。
    线程对象的属性：编号（ID）、名称（Name）、线程类型（Daemon）、优先级（Priority）.
    线程编号是一个long型变量，用于标识不同的线程，不可修改，这个编号在线程运行结束后可能被分配给其他新的线程。
    线程名称是一个String类型的变量，面向人标识线程，可修改，默认格式：Thread-线程编号，java允许把不同的线程名称设置为相同。
    线程类型是一个boolean类型变量，值为true表示线程为守护线程，值为false表示线程为用户线程，可以修改，默认和创建当前线程的父线程的类型
相同，如果要修改，需要在启动线程前进行。守护线程不会阻止JVM的正常停止，而用户线程则会，因此重要任务最好不要设置线程类型为守护线程。
    线程优先级是一个int类型的变量，它是给线程调度器的提示，用于表示希望优先运行哪个线程。java定义了1~10的10个优先级，默认为5，子线程的
优先级默认和父线程相同。一般不需要修改这个属性。
    Thread类的常用方法：
        static Thread currentThread();
        void run();
        void start();
        void join();                        在A线程中调用B线程的join方法后，A线程将会暂停执行，直到B线程执行完成后A线程继续执行。
        static void yield();                在A线程中调用Thread.yield()后，如果进程存在其他线程，A线程将被让出处理器使用，等待线程
                                            调度器再次分配处理器时间，否则线程A将继续执行。
        static void sleep(long millis);     在A线程中调用Thread.sleep(1000)后，A线程将休眠1s。
    使用Thread.sleep(n)实现一个定时器：
        public class SimpleTimer {
            public static void main(String[] args) throws InterruptedException {
                for(int i=0; i<60; i++){
                    System.out.println("remaining "+(60-i)+" seconds");
                    Thread.sleep(1000);
                }
            }
        }
    JVM规范的调整使得Thread的一些早期提供的方法不再建议使用（这些方法在早期的JVM上也可能出现问题）：stop、suspend、resume
    这些方法提供的功能：停止一个线程、暂停线程执行、恢复线程执行，现在通常使用一些其他方式实现（Thread类没有提供新的替代方法）。
    启动一个java虚拟机进程时会创建一个名称为main的线程（编号为1），这个线程负责执行java程序的入口方法（main方法）。JVM会创建一个垃圾
回收线程用来进行GC。JVM还会创建一个线程执行JIT编译器的编译任务。
    java的线程具有逻辑上的层级结构，main线程通常是最上层的线程，可以创建子线程，这些子线程也可以创建自己的子线程。子线程的类型和优先级
默认和父线程一致。除了子线程由父线程创建外，父线程和子线程的生命周期没有特别的关系，父线程执行结束不影响子线程的执行，子线程的执行也不影
响父线程（抛出异常除外）。有些父线程创建的用于执行特定任务的线程也被称为工作者线程。
    线程的生命周期状态：使用Thread.getState()可以获取线程状态，返回值类型是枚举类型Thread.State。
    线程对象被创建后，在启动（调用start方法）之前处于状态：NEW，一个线程只有一次处于这种状态。
    线程启动后进入RUNNABLE状态，这个状态具有两个子状态：READY和RUNNING，线程调度器可以对线程调度时线程处于READY状态（称为活跃线程），
线程执行时处于RUNNING状态。线程执行时调用Thread.yield()可能会使当前线程状态从RUNNING转为READY。
    当执行中的线程发起阻塞IO请求或请求一个锁住的资源时，线程状态转为BLOCKED，这时该线程不占用处理器，等待请求返回后，线程转回RUNNABLE
状态（不一定直接转回RUNNING）。
    线程执行过程中调用了join等方法时，线程状态转为WAITING，处理器被让给其他线程，直到等待的线程执行完成后，线程状态才转回RUNNABLE.
    线程执行过程中调用Thread.sleep(n)等方法后，线程状态转为TIMED_WAITING，等待指定时间之后线程状态转回RUNNABLE.
    线程执行结束后状态转为TERMINATED，包括正常结束和抛出异常。
    使用线程转储监控线程：一个程序的线程转储包含了在获取这个线程转储的那一刻该程序的线程信息，包括程序中具有哪些线程以及各个线程的属性、
生命周期状态、调用栈、锁的信息。可以使用如下方法获取线程转储：
    获取线程转储的工具：
        (oracle/sun)jdk1.6开始提供jstack工具，使用：jstack -l pid （平台无关）
        oracle jdk提供jvisualvm工具，位于jdk目录/bin/jvisualvm（GUI工具，平台无关）
        oracle jdk1.8开始提供jmc工具，位于jdk目录/bin/jmc（GUI工具，平台无关）
        linux系统命令：kill -3 pid 或在启动java进程的shell中：ctrl+\
    多线程编程的优势：
        提高系统的吞吐率（单位时间内服务器处理的请求数）；
        提高响应性（返回响应给请求者的时间不受其他慢请求影响）；
        充分利用处理器多核资源；
        最小化使用系统资源（多个线程共享进程的内存空间）；
        简化程序复杂性。
    多线程编程的问题和风险：
        线程共享数据带来的线程安全问题；
        不合理的设计带来的线程饥饿、死锁等线程活性问题；
        上下文切换（线程间切换）带来的性能消耗；
        线程意外终止可能引起JVM进程终止（多线程比单线程的发生概率更大）。
        
    第二章 多线程编程基本概念
    串行(Sequential)：多个任务只能依次进行，后面的任务只能等待前面的任务完成后才能被执行。
    并发(Concurrent)：多个任务可以在一段时间内同时执行，后面的任务不需要等待前面的任务完全结束就可以执行。
    并行(Parallel)：多个任务在任意时间点都可以同时执行，任务间没有顺序关系。
    并行是并发的极限情形，单核机器上，可以通过CPU时间分片实现多个线程并发执行，而并行则需要多个CPU核心执行不同的线程才能实现。
    多线程编程的本质就是将任务的处理方式由串行改为并发，即并发化，以提高程序的性能。如果一个任务可以拆分为多个可以并发执行的子任务，那么
就称这个任务为可并发化的。当然，不是所有的任务都是可并发化的。
    竞态：如果一个多线程程序的执行结果的正确性和时间有关，即结果可能正确也可能错误，这种情况就称为竞态。具体来说，竞态表示计算的正确性依
赖于相对时间顺序或线程的交错。竞态通常伴随着读取脏数据的问题，读取脏数据通常会导致丢失更新问题。
    状态变量：即类的实例变量、静态变量。
    共享变量：可以被多个线程共同访问的变量（即该变量在被某个线程访问期间，其他线程也可以访问它）。状态变量属于共享变量。
    竞态的模式：read-modify-write(读-改-写)、check-then-act(检测-使用)，这两种模式都可能读取到脏数据。局部变量不属于共享变量，所以不会
出现竞态问题。
    synchronized关键字修饰方法可以使该方法在被一个线程执行时，不能再被其他线程执行。
    线程安全性：如果一个类在单线程环境下可以正确执行，不做改变地迁移到多线程环境也能正确执行，该类就是线程安全的，否则就是非线程安全的。
    ArrayList、HashMap等类是非线程安全的，如果用在多线程环境中，就有可能导致内存泄漏等问题。
    线程安全性问题：将非线程安全的类用在多线程环境中即存在线程安全性问题，表现在原子性、可见性和有序性三个方面。
    原子性：多线程环境下，某个访问共享变量的操作，如果操作过程的中间效果对于其他线程都是不可见的，即其他线程不能访问该操作执行过程中部分修
改的共享变量，该操作就具有原子性，称为原子操作。原子操作之间不能交错。
    非线程安全的类没有实现其操作共享变量的操作（方法）的原子性。
    java中可以使用锁和CAS指令来实现操作的原子性，锁具有排他性，即在任意时刻只允许一个线程访问某个共享变量。CAS指令是依靠硬件实现的。
    java中，long、double以外其他类型变量的写操作都是原子操作，long和double型变量在32位机器上的写操作会分为两步，先写低32位，再写高32位，
所以不是原子操作。可以使用volatile关键字修改long、double型变量使其写操作具有原子性。
    可见性：一个线程对共享变量的更新的结果对于读取相应共享变量的其他线程是否可见。一个多线程程序存在可见性问题，即某些线程读取到了旧数据，
而这些旧数据导致计算出现错误。
    可见性问题出现的原因：
    在多核处理器中，每个核心都有其独自的寄存器、高速缓存、写缓存器和无效化队列，这些部件作为主内存的缓存，某个线程对共享变量的修改首先是
写在其执行核心的写缓存器中的，在其他处理核心上执行的线程不能访问到这个已修改的共享变量。
    如果要让当前线程可以访问其他核心执行的线程修改的共享变量，首先需要那个核心上的线程修改的共享变量（从写缓存器）同步到其高速缓存或主内
存中，这称为冲刷处理器缓存；必须将那个核心的缓存数据同步到当前线程所在核心的高速缓存中，这称为缓存同步。一个新线程处理器在读取某个共享变
量时，该共享变量已被其他线程核心更新，当前线程核心就需要从其他核心的处理器缓存同步该变量到自己的处理器缓存，这称为刷新处理器缓存。
    在单核处理器上，上下文切换会导致保存上个线程修改的共享变量的寄存器内容被保存，所以新线程无法访问上一个线程修改的共享变量。
    java中使用volatile关键字修饰一个变量后，JIT编译器将不会对访问该变量的访问操作进行可能导致可见性问题的优化，而且读取该变量时会进行刷
新处理器缓存，写该变量时会进行冲刷处理器缓存。
    在子线程启动之前，父线程对共享变量的更新对子线程总是可见的，某一线程对共享变量的修改在该线程终止后，对于调用该线程的join方法的线程（
等待该线程执行完再执行的线程）总是可见的。
    有序性：一个线程对内存的访问操作在其他线程看来是否和其源码中的顺序一致，如果不一致，则该多线程程序存在有序性问题。
    重排序是导致有序性问题的主要原因，指的是处理器执行的指令顺序和程序源码中的顺序不一致，或者是多线程程序中其他线程观测某个线程的内存操作
结果和其源码中预定的结果不一致。重排序可能是软件导致的，如静态编译导致的字节码指令重排序（javac编译器不会进行这种重排序）、JIT编译导致的
本地机器码指令重排序，也可能是硬件设计导致的，如处理器执行指令时重排序、处理器缓存系统写数据重排序。
    JIT编译重排序（指令重排序）的一个例子：
    创建对象时，通常的顺序应该是：①先分配内存，②初始化分配空间，③将分配的地址赋值给对象引用。
    但是JIT编译器可能生成如下顺序的本地机器码指令：①先分配内存，③将分配的地址赋值给对象引用，②初始化分配空间。
    这就可能导致创建对象的线程在还没有完成对象初始化时，其他线程就可以访问这个对象，造成线程安全性问题。
    处理器执行指令时重排序（乱序执行）：现代处理器为了提高效率，通常会动态调整指令执行顺序，例如选择先准备好操作数的指令执行，执行结果被保
存到重排序缓冲器中，这个缓冲器按照原来指令被读取的顺序提交执行结果到寄存器或主内存。还有一种“猜测执行”技术，即在执行条件判断指令前先执行条
件判断指令后的指令，并将执行结果保存到重排序缓冲器中，执行条件判断指令后再根据结果决定是否提交重排序缓冲器中的结果。
    处理器缓存系统重排序：这种重排序不是指令重排序，也不是指令执行重排序，而是指令执行结果提交乱序导致的其他线程观测当前线程执行类似发生了
重排序。例如线程X连续写两个变量A和B，线程Y观测变量B的结果输出变量A的值，如果线程X写变量B先提交，这里线程Y检测到可以访问变量A，但是此时变量
A的新值还没有提交，就会导致线程Y拿到脏数据。需要说明的是，不同的处理器在乱序提交上的设计上并不相同。
    貌似串行语义：尽管存在各种重排序，但是在单线程程序中，程序执行结果仍然和源码中约定的顺序相同，就好像没有发生重排序。
    在单核处理器上，只有静态编译重排序会产生有序性问题，其他类型的重排序都不会产生有序性问题，这是因为单核处理器在切换线程时会提交当前线程
执行的结果（提交到高速缓存，不同线程使用不同的高速缓存，所以仍然存在可见性问题）。
    在java中，volatile、synchronized关键字可以保证有序性，屏蔽了禁止重排序的具体细节做法。
    线程上下文切换：在多线程程序中，通常线程的数量要比处理器（核心）的数量多得多，所以必须采用时间分片的方法来实现多线程并发执行，当一个正
在执行的线程的时间片用完或者该线程主动暂停执行，又或者线程调度器提前暂停该线程执行，当线程暂停执行时，操作系统就会保存其暂停前的运行期数据，
主要是寄存器中的数据（通用寄存器和PC寄存器）被保存到内存中，当该线程下次执行时，操作系统就把保存的数据从内存恢复到寄存器中。
    对java程序来说，线程上下文切换就是一个线程在RUNNABLE状态和非RUNNABLE状态之间的一次切换。
    java多线程程序触发自发性上下文切换的方法：Thread.sleep方法、Object.wait方法、Thread.yield方法、Thread.join方法，LockSupport.park
方法等。线程执行阻塞式IO操作和等待锁也会触发自发性上下文切换。
    非自发性上下文切换一般是由于时间片用完导致的，也可能是线程调用器遇到了一个更高优先级的线程。在java程序中，JVM在GC时，通常需要停止用户线
程的执行。
    线程上下文切换的开销：主要包括处理器保存和重新加载线程运行期寄存器数据的时间开销、线程调度器选择新执行线程的开销、高速缓存重新加载的开销，
通常一次线程上下文切换的时间开销在us级。
    因为存在上下文切换的开销，所以可能出现多线程的效率反而比单线程更低。
    在linux下，perf命令可以统计java程序运行期间发生的线程上下文切换次数，windows下可以使用perfmon工具监控程序的线程上下文切换信息。
    线程活性故障：程序中的线程都处于非RUNNABLE状态或者线程处于RUNNABLE状态但是其任务无法完成。
    线程活性故障的几种类型：
    死锁：两个或多个线程都在等待对方持有的锁（资源），同时都不释放自己持有的锁（资源），导致线程处于RUNNABLE状态但是无法完成任务。
    锁死：一个线程一直等待被唤醒。
    活锁：线程处于RUNNABLE状态但是任务没有进展。
    饥饿：一个线程无法获得其等待的资源。
    高并发：一段时间内，处于运行状态的线程越多，并发程度就越高，即高并发。高并发会增加资源争用的概率，即多个线程都去请求一个排他性资源，如处理器
时间。
    资源调度通常会使用排队策略，即把申请某资源失败的线程加入一个队列，当该资源被释放后，就唤醒队列头部的线程使其获得资源。
    公平调度：先申请排他性资源的线程总是比后申请的线程先获得该资源的独占权，但是其吞吐率较低，因为公平调度通常需要更多的上下文切换。公平调度适合
用在线程持有资源时间较长或线程申请资源时间间隔较长或者要求各个线程公平获得资源使用权的场景下。
    非公平调度：允许后申请排他性资源的线程比先申请的线程先获得该资源的独占权，其吞吐率较高，因为非公平调度时有些线程不需要进行上下文切换，但是可能
导致饥饿问题。非公平调度是大多数场景下的默认选择，其吞吐率更高。
    
    第三章 java中的线程同步机制
    线程同步机制指的是用于协调线程间的数据访问和活动以保障线程安全和正确执行的机制。
    java平台提供的线程同步机制包括：锁、volatile关键字、final关键字、static关键字和一些相关的API，如Object.wait/Object.notify等。
    锁可以看成是线程共享数据的访问许可证，使用锁保护共享数据时，在任何线程访问共享数据前都需要先获取对应的锁，访问结束后应该释放持有的锁。
    临界区：在获得锁和释放锁之间线程执行的代码（指令）。临界区一次只能被一个线程执行，所以在临界区内访问共享数据就变成了串行访问，就可以避免线程安
全性问题。
    如果多个线程访问同一个锁保护的共享数据，就称这些线程同步在这个锁上，这些线程执行的临界区称为这个锁所引导的临界区。
    锁大多数都具有排他性，即一次只能被一个线程持有，如内部锁（synchronized实现），这些锁称为排它锁或互斥锁。
    java虚拟机提供两种锁实现，即内部锁和显式锁，内部锁是通过synchronized关键字实现的（java语法层面），显式锁是通过java.concurrent.locks.Lock接口
的实现类实现的。
    锁是通过排他性（互斥性）保障原子性的，其可见性保障是隐含的，即获得锁时隐含进行了刷新处理器缓存，释放锁隐含进行了冲刷处理器缓存，使用锁保护共享数据
也可以保障有序性，即使可能会有执行指令重排序，其执行结果对其他线程仍然是和代码约定顺序一致的。
    使用锁保证线程安全性，需要注意：线程访问共享数据时必须使用同一个锁，这里的访问包括仅进行读操作。
    可重入性：一个线程在已获得某个锁时，还能继续申请该锁。这样的锁称为可重入锁，否则称为非可重入锁。
    锁其实相当于一种排他性资源，所以申请锁也存在锁调度策略。
    一个锁保护的共享数据的数量大小称为锁的粒度，共享数据的数量大就称锁的粒度粗，否则称锁的粒度细。锁的粒度太粗会导致不必要的执行阻塞，粒度太细则会导致
调度开销增加。
    使用锁需要注意锁的释放，忘记释放锁将导致锁泄漏，即其他线程一直无法获取锁。
    锁这种同步机制本身是非常粗粒度的。
    在java中，任何一个对象都可以作为锁，当作为锁使用时，称为监视器或内部锁，将对象作为锁是通过synchronized关键字实现的。
    synchronized关键字修饰的方法称为同步方法，其修饰的代码块称为同步代码块，同步方法的方法体就是一个临界区，同步代码块内的代码也是一个临界区。同步静态
方法（即使用synchronized修饰的静态方法）默认使用静态方法所在类的class对象作为锁，同步实例方法默认使用实例方法所在对象作为锁，同步代码块需要指定一个锁
句柄，该句柄引用一个对象作为锁，锁句柄通常需要使用private final修饰以保障该句柄不会被修改（如果锁句柄被修改就会无法保障同步代码块的线程安全性，这样就会
会引发竞态），这些锁对象称为引导锁。
    javac编译器在编译同步方法和同步代码块时，会对临界区内抛出而程序没有处理的异常进行特殊处理，使得抛出异常不会妨碍内部锁的释放，所以内部锁不会导致锁泄漏。
    java虚拟机会为每个内部锁创建一个入口集（它的实现由虚拟机实现决定），这个入口集用于记录等待该锁的线程，当这个锁被释放后，虚拟机就从这些等待线程中选择
一个线程参与该锁的申请，选择等待线程的算法由虚拟机实现自己决定，而选择的线程不是直接获得该锁，因为内部锁的申请都是使用非公平调度，所以选中的等待线程可能
会重新回到入口集中。
    显式锁是在JDK1.5才引入的，一个显式锁是一个java.util.concurrent.locks.Lock接口的一个实例对象，设计显式锁不是要替换内部锁，而是作为内部锁的一种补充，
增加锁应用范围的灵活性。
    类java.util.concurrent.locks.ReentrantLock是Lock接口的默认实现，它是一个可重入锁。
    Lock接口中的lock方法用于申请锁，unlock方法用于释放锁。临界区代码放在lock方法和unlock方法之间。临界区代码通常使用try包裹，并将unluck方法放在try后面
的finally块中，这样就可以避免锁泄漏。
        public class SafeCircularSeqGenerator {
            private final Lock lock = new ReentrantLock();
            private short sequence = -1;
            public short nextSequence() {
                lock.lock();
                try {
                    if(sequence>=999) {
                        sequence = 0;
                    }
                    else {
                        sequence++;
                    }
                    return sequence;
                } finally {
                    lock.unlock();
                }
            }
        }
    ReentrantLock支持公平调度和非公平调度两种调度策略，这是显式锁和内部锁的区别之一。
        private final Lock lock = new ReentrantLock(true);
        //默认为非公平调度
    Lock接口的tryLock方法用于尝试申请一个锁，如果申请不成功就跳过临界区代码继续，这样就不需要暂停执行线程。tryLock方法另一个重载版本允许设置一个等待时间，
即在该时间值内申请，超出该时间后不再等待该锁。
        public short nextSequence() {
                if(lock.tryLock()) {
                    try {
                        if(sequence>=999) {
                            sequence = 0;
                        }
                        else {
                            sequence++;
                        }
                        return sequence;
                    } finally {
                        lock.unlock();
                    }
                }
                System.out.println(Thread.currentThread().getName()+" locked? "+((ReentrantLock)lock).isLocked());
                return -1;
            }
    ReentrantLock提供一个isLocked方法，可检查该锁是否被某个线程持有，提供一个getQueueLength方法，可获取等待该锁的线程的数量。
    在决定选用内部锁还是显式锁时，比较保守的做法是默认使用内部锁，仅在需要使用显式锁提供的新特性的地方使用显式锁。另一种做法是尽量选用显式锁，毕竟显式锁更加
灵活和可控。
    只读线程：对共享变量仅进行读取操作的同步线程。
    写线程：对共享变量进行更新的同步线程。
    读写锁：允许多个只读线程同时读取共享变量，但是一次只允许一个线程对共享变量更新，即有一个线程在更新共享变量时，其他线程都不能访问共享数据，这样的锁称为
读写锁。读写锁是一种改进型的排它锁，也称共享/排它锁。
    读写锁不是两个锁（对象），而是一个锁对象扮演两个角色，即读锁和写锁。只读线程在访问共享数据前申请读锁，写线程在访问共享数据前申请写锁。读锁是共享的，而
写锁是独占的。
    java.util.concurrent.locks.ReadWriteLock接口是读写锁的抽象，ReentrantReadWriteLock是其默认实现类，它也是一个可重入锁。
    ReadWriteLock接口中的方法readLock返回读锁，writeLock方法返回写锁。
        public class HostConfig {
            private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(false);
            Lock readLock = readWriteLock.readLock();
            Lock writeLock = readWriteLock.writeLock();

            private String ip = "192.168.1.1";
            
            private int port = 80;
            
            public String getHostConfig(){
                
                readLock.lock();
                String config = "ip: "+ip+"; port: "+port;
                readLock.unlock();
                return config;
            }
            
            public void setHostConfig(String ip,int port) {
                
                writeLock.lock();
                this.ip = ip;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                this.port = port;
                writeLock.unlock();
            }
        }
		public class HostTask implements Runnable{
			private HostConfig hostConfig = new HostConfig();
			
			@Override
			public void run() {
				long threadId = Thread.currentThread().getId();
				if(threadId%3==0) {
					hostConfig.setHostConfig("192.168.1.2", 81);
				}
				else if(threadId%4==0) {
					hostConfig.setHostConfig("192.168.1.3", 82);
				}
				else {
					String config = hostConfig.getHostConfig();
					System.out.println(threadId+": "+config);
				}
			}
		}
    读写锁适用场景：
        只读操作比写（更新）操作要频繁得多；
        读线程持有锁的时间比较长。
    ReentrantReadWriteLock支持锁的降级，即一个线程在持有写锁的情况下，可以继续获取相应的读锁，但是不支持锁的升级，即持有读锁期间不能获得写锁。
    java虚拟机使用内存屏障指令实现刷新处理器缓存和冲刷处理器缓存，这是java各种线程同步机制的底层实现机制。
	内存屏障指令共4种：LoadLoad, LoadStore, StoreLoad, StoreStore。
		Load1; LoadLoad; Load2			确保Load1数据装载指令（刷新处理器缓存）不会被重排序到Load2及所有后续装载指令之后。
		Store1; StoreStore; Store2		确保Store1数据提交指令（冲刷处理器缓存），不会被重排序到Store2及所有后续提交指令之后。
		Load1; LoadStore; Store2		确保Load1数据装载指令不会被重排序到Store2及所有后续提交指令之后。
		Store1; StoreLoad; Load2		确保Store1数据提交指令不会被重排序到Load2及所有后续提交指令之后。

	volatile关键字也可以用于实现线程间的同步，使用volatile修饰共享变量，能够保障long和double型变量写操作的原子性、共享变量的可见性和有序性。
volatile的作用类似于锁，被称为轻量级锁。
	在32位虚拟机中，long和double变量的访问不是原子操作，使用volatile修饰共享变量可以保障此操作的原子性，虚拟机是通过使用处理器的原子指令来实现的
（32位机器中普通的long、double型变量访问，会连续执行两条mov指令，但是使用volatile修饰的long、double变量，JIT编译器生成的本地机器码会使用处理器的
原子指令：vmovsd指令（先执行vmovd指令将低32位和高32位保存到寄存器，在使用此指令访问返回全部64位）。）。
	volatile对原子性的保障仅限于共享变量写和读操作本身。对共享变量进行的赋值操作实际上往往是一个复合操作，volatile并不能保障这些赋值操作的原子性：
		volatile counter1 = counter2 + 1;
		//如果counter2是一个局部变量，那么上述赋值语句实际上就是针对counter1的写操作，因此在volatile关键字的作用下上述赋值操作具有原子性。
		//如果counter2也是一个共享变量，那么上述赋值语句就不具有原子性。
	可见性保障：Java语言规范规定，对于同一个volatile变量，一个线程（写线程）对该变量进行更新，其他线程（读线程）随后对该变量进行读取，这些线程总是
可以读取到写线程对该变量所做的更新。volatile并不能够保障读线程所读取到变量值是共享变量的最新值：读线程在读取一个volatile变量的那一刻，其他线程
（写线程）可能又恰好更新了该变量，因此读线程所读取到共享变量值仅仅是一个相对新值，即其他线程更新过的值（不一定是最新值）。
	有序性保障：Java语言规范规定，对于访问（读、写）同一个volatile变量的多个线程而言，一个线程（写线程）在写volatile变量前所执行的内存读、写操作在
随后读取该volatile变量的其他线程（读线程）看来是有序的。
	Java内存模型定义的动作（Action）概念：变量的读/写、锁的申请（lock）与释放（unlock）以及线程的启动（Thread.start()调用）和加入（Thread.join()调用）等。
	Java内存模型定义的Happens-before关系：如果动作A和动作B之间存在Happens-before关系，那么动作A的执行结果对动作B可见。反之，如果动作A和动作B之间不存在
Happens-before关系，那么动作A的执行结果对B来说不一定是可见的。
	Java内存模型定义的volatile变量规则:	对一个volatile变量的写操作与该操作后的每一个针对该变量的读操作存在happens-before关系。
	Java内存模型定义的程序顺序规则：同一个线程中的每一个动作都与该线程中程序顺序上排在该动作之后的每一个动作存在happens-before关系。所以Happens-before
关系具有传递性。
	volatile关键字对有序性的保障是通过虚拟机（JIT编译器）在写线程和读线程中配对地使用内存屏障实现的。
	JIT编译器会在volatile变量写操作之前插入LoadStore+StoreStore内存屏障指令来确保程序顺序上排在volatile变量写操作之前的其他写操作不会被编译器/处理器
通过指令重排序和（或）内存重排序被重排序到该volatile变量写操作之后，在volatile变量写操作之后插入StoreLoad指令来将最新的共享变量输出到高速缓存中。
	JIT编译器会在volatile变量读操作之前插入LoadLoad指令来同步其他线程的高速缓存中的共享变量到当前线程的缓存中,在volatile变量读操作之后插入一个
LoadLoad+LoadStore内存屏障指令来确保程序顺序上排在volatile变量读操作之后的其他共享变量的读、写操作不能够被编译器/处理器通过指令重排序和（或）内存重排序
被重排序到该volatile变量读操作之前。
	普通共享变量的访问不会使用内存屏障指令，volatile变量则总是需要内存屏障指令，内存屏障指令本身执行时会同步数据到高速缓存，所以会造成一定的开销。由于内存
屏障指令的存在，所以volatile变量的访问相当于直接访问主存而没有使用寄存器。所以volatile变量的访问开销要比普通共享变量的开销要大。
	基于volatile提供的可见性、有序性保障，可以使用volatile来实现对象的安全发布（即保证创建并返回的对象是完整的对象）。

	CAS指令
	CAS（Compare and Swap）是对一类处理器指令的指称，java的多线程实现通常都是通过CAS指令实现的。
	CAS指令能将read-modify-write和check-and-act操作转换为原子操作。
	check-and-act例子：
		private int count;
		public void increment(){
			count++;
		}
	上面increment方法中对共享变量count的修改是一种read-modify-write操作，类似于：
		int temp1 = count;
		int temp2 = temp1+1;
		count = temp2;
	在多线程环境中，可以使用加锁的方式来同步，保证访问count的安全性，但是锁本身是非常粗粒度的，而使用volatile关键字并不能保证这种复合操作的原子性。
	利用CAS指令来转换这种操作：
		public class CASBasedCounter {
			private volatile long count;
			private final AtomicLongFieldUpdater<CASBasedCounter> fieldUpdater = null;

			public CASBasedCounter() throws SecurityException, NoSuchFieldException {
				fieldUpdater = AtomicLongFieldUpdater.newUpdater(CASBasedCounter.class,"count");
			}

			public long vaule() {
				return count;
			}

			public void increment() {
				long oldValue;
				long newValue;
				do {
					oldValue = count;// 读取共享变量当前值
					newValue = oldValue + 1;// 计算共享变量的新值
				} while (/* 调用CAS来更新共享变量的值 */!compareAndSwap(oldValue, newValue));
			}

			private boolean compareAndSwap(long oldValue, long newValue) {
				boolean isOK = fieldUpdater.compareAndSet(this, oldValue, newValue);
				return isOK;
			}
		}
	这里fieldUpdater是使用CAS指令实现的共享变量操作"代理"，各个线程在修改共享变量时委托fieldUpdater去修改，基本模式入下：
		do {
			oldValue = V.get();
			newValue = modify(oldValue);
		} while (!compareAndSwap(oldValue, newValue));
	compareAndSwap执行时，先检查共享变量的值是否等于oldValue，如果相等，说明共享变量没有被其他线程修改，然后就更新共享变量的值为newValue，然后返回true；
do...while循环就退出；如果共享变量的值不等于oldValue，说明共享变量已经被其他线程修改，这时就返回false，do...while循环继续，这里的共享需要使用volatile修饰，
这样可以保证修改共享变量失败的线程能在下一次循环时读到共享变量的最新值。
	实际上，通常不会使用AtomicLongFieldUpdater，而是使用标准库的并发包下的原子变量来利用CAS指令。

	原子变量：原子变量类都是基于CAS指令实现的能保障多线程对共享变量进行read-modify-write的原子性和可见性的工具类，包括：
		基础数据类型：	AtomicInteger、AtomicLong、AtomicBoolean
		数组类型：		AtomicIntegerArray、AtomicLongArray、AtomicReferrenceArray
		字段更新器：	AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater
		引用型：		AtomicReferrence、AtomicStampedReference、AtomicMarkableReferrence
	使用AtomicLong：
		import java.util.concurrent.atomic.AtomicLong;
		class Indicator{
			private static final Indicator INSTANCE = new Indicator();

			private final AtomicLong count = new AtomicLong(0);

			private Indicator(){}

			public static Indicator getInstance(){
				return INSTANCE;
			}

			public void increment(){
				count.incrementAndGet();
			}

			public long get(){
				return count.get();
			}
		}
		
		public class AtomicLongDemo1 {
			private final Indicator indicator = Indicator.getInstance();
			public static void main(String[] args) throws Exception{
				AtomicLongDemo1 demo1 = new AtomicLongDemo1();
				for (int i=0;i<20;i++){
					Thread thread = new Thread(()->{
						demo1.indicator.increment();
					});
					thread.start();
				}
				Thread.sleep(50);
				System.out.println("total count : "+demo1.indicator.get());
			}
		}
	使用AtomicBoolean保证某个方法（操作）只被执行一次：
		import java.util.concurrent.atomic.AtomicBoolean;
		class OnceBox{
			private final AtomicBoolean status = new AtomicBoolean(false);

			public void work(){
				if(status.compareAndSet(false,true)){
					System.out.println("work start, then it will be destroyed");
				}
			}
		}

		public class AtomicBooleanDemo1 {
			public static void main(String[] args) {
				OnceBox onceBox = new OnceBox();
				for (int i=0;i<20;i++){
					Thread thread = new Thread(()->{
						onceBox.work();
					});
					thread.start();
				}
			}
		}
	虽然上面的work方法也可以使用加锁实现一样的效果，但是锁的开销要比使用原子变量大得多。
	ABA问题：compareAndSet在比较传入的oldValue和共享变量的最新值时，不能保证共享变量没有被其他线程更新，即共享变量可能发生了如下变化：
		oldValue --> newValue1 --> oldValue
	ABA问题可能不算问题，但是在某些场景下不能忽略这类问题，所以引入了AtomicStampedReference类，这个类是基于修订号的思想设计的，即在每次
更新时都会更新一个关联的修订号。

	对象发布：使对象能被其作用域外的线程访问。常见的对象发布形式包括：使用public修饰对象引用，在非private方法中返回对象，调用其他类的方法
时传入共享对象，创建内部类在其内部访问外部对象变量。
	static关键字修饰变量，除了定义变量的作用域为类作用域外，还保证了访问线程在访问此静态变量已经被初始化过。
	final关键字修饰变量，除了限定变量不能修改外，还保证了访问线程在访问对象的final变量时，该变量已经初始化完成，如果final变量引用一个对象，
则该引用对象也是已经初始化完成的。在构造对象时，非final变量可能被重排序到对象引用赋值后，所以其他线程可能访问到未初始化的变量，而虚拟机会保障
final变量的初始化不会被重排序到对象引用赋值之后。
	对象逸出：广义上，一个不应该被发布的内部对象被错误地发布出去都是对象逸出，狭义上，通常指一个没有构造完成的对象被提前发布。
	典型的构造函数内this逸出：
		public class EscapeDemo{
			private int value;
			public EscapeDemo(){
				new Thread(()->{
					doSomething();
				}).start();
				//初始化
				value = 7;
			}
			
			public void doSomething(){
				System.out.println(value);
			}
		}
	上面的代码中构造方法里在对象初始化之前就把对象发布出去，就导致了不符合预期的结果，由于重排序的原因，即使把初始化代码（即value = 7;)写到发布代码前
也不能保证发布的对象是一个初始化完成的对象。
	为了实现上面的程序语义，可以改写成如下形式：
		public class EscapeDemo{
			private int value;
			private EscapeDemo(){
				value = 7;
			}
			private void init(){
				new Thread(()->{
					doSomething();
				}).start();
			}

			public EscapeDemo getInstance(){
				EscapeDemo instance = new EscapeDemo();
				init(instance);
				return instance;
			}
		}
	几种安全发布对象的方法：
		使用static修饰引用要发布对象的变量；			 //访问发布对象时，static保证发布对象已经初始化完成
		使用final修饰引用要发布对象的变量；				 //访问发布对象时，final保证发布对象已经初始化完成
		使用volatile修饰引用要发布对象的变量；			 //volatile保证对象引用赋值的代码不会被重排序到初始化代码之前
		使用AtomicReferrence变量引用要发布对象；		//AtomicReferrence保证对象的构造过程的原子性
		对访问发布对象的代码加锁。
	
	第四章 并发模式
	程序执行时并不是所有的过程都必须线性执行，也不是所有过程都可以并发执行，所以需要找到可以并发执行的过程，即寻找可并发点。
	在编程中，可以从数据和任务两个维度来寻找可并发点，某些数据处理场景下，可以将大的数据集拆分为规模较小的数据集再并发处理；而没有依赖关系的任务
则可以并发地执行这些任务。这两种并发模式其实都是基于分治的思想，即将一个问题分解为更小的多个不相关（或者关联不紧密）问题。
	基于拆分数据的并发模式的一个典型应用场景是多线程下载。多线程下载通常要比单线程更快，这是因为多个线程同时下载一个资源，每个线程下载该资源的一
部分。这里隐含的一个条件是，基于TCP的连接每次都需要客户端返回确认消息给服务器，这样就导致网络带宽不可能被完全利用，并发下载由于使用了多个线程，所以
可以更充分地利用带宽。（单线程模型中，只有上一个数据包被确认后，服务端才发送下一个数据包，而多线程则可以在等待一个客户端线程发回确认时发送数据包给其他
客户端线程）。
	基于拆分任务的并发模式中，通常是将一个大的复杂任务拆分为多个功能更单一的任务，类似于流水线模型，在程序中，这类功能单一的任务通常可以分为CPU密集型
（数据处理）和IO密集型（数据采集）两类，这就很适合使用不同线程来处理不同任务，这样可以让数据处理的效率更高（处理数据的线程可以充分利用CPU时间）。
	拆分任务的并发模式是按步骤分割的并发模式的特例，这类按步骤分割的并发模式的描述如下：对于输入集{d1,d2,...dn}中的每一个元素di都包含相同的多个处理
步骤{step1,step2...stepn}，那么可以为每个处理步骤安排一个或多个工作者线程。可以看成，这其实就是流水线模型。
	Amdahl's定律
	Amdahl's定律描述了[线程数]与[多线程程序相对于单线程程序的提速]之间的关系，其数学表达如下：
		Smax = 1 / (p + ((1 - p) / N))
	Smax表示最大提速，p表示不可并行的步骤的耗时占比，N表示处理器数量（理想线程数），当N->∞，Smax=1/p，这表明多线程提速实际取决于程序中不可并行化步骤
的耗时占比。
	设置多线程程序的线程数量时，需要考虑很多因素：机器处理器数量、其他进程及其线程的数量等，因为无法完全控制这些因素，如其他进程和线程，这就导致不可能
找到一个线程数量的理想值，所谓合理设置线程数的含义实质上是指避免随意设置这个数量。
	设置线程数量的经验总结：CPU密集型任务可以设置的线程数量合理值是CPU处理核心的数量：Ncpu，如果考虑由于某些原因导致某个任务中断，可以设置线程数量为
Ncpu + 1。对于IO密集型任务，通常只需要设置一个线程，这是因为磁盘IO是一个机械过程，一个线程顺序读取效率最高，如果是多个线程就可能导致磁盘的机械臂频繁
大范围移动，导致效率降低。另外一种建议是，当单个IO任务线程不能满足需求时，IO任务线程数量靠近Ncpu * 2，这是考虑，在Ncpu个线程在执行IO操作时，处理器仍然
可以执行其他的任务（IO密集型任务仍然有需要CPU计算的部分工作）。
	对于不拆分为CPU密集型任务和IO密集型任务的多线程程序（例如基于数据量拆分的多线程程序），合理线程数量的经验公式如下：
		Nt = Ncpu * Ucpu * (1 + Wt/St)
	其中，Nt是线程数量，Ncpu是CPU核心数量，Ucpu是CPU使用率，即如果Ncpu为4，Ucpu为75%，则有效CPU核心数量为3，Wt为程序等待(IO)上的时间，St是CPU执行计算
的时间。如果Ncpu为4，Ucpu为75%，Wt/St为1，即程序运行时有一半时间在等待IO返回，一半时间是在实际计算，那么Nt=6，说明应该设置6个线程，其实就是为每个有效处理
核心分配2个线程，那么当其中一个线程在等待IO时，CPU可以执行另一个线程的计算任务。（前面Wt和St描述的程序是指单线程程序）

	第五章 线程间协作
	等待和通知（wait/notify）：一个线程在检查其目标动作的保护条件不通过时主动暂停的过程被称为等待，一个线程在更新系统状态后使得其他线程的保护条件得到满足
时唤醒那些暂停线程的过程被称为通知。
	线程暂停的典型模式：
		atomic {
			while(保护条件不满足){
				暂停执行
			}
			//执行目标动作
			doAction();
		}
	这里目标动作和保护条件的检查必须是一个原子操作，如果不是原子操作，就可以出现：某一个线程检查保护条件满足后，执行目标动作前保护条件再次被其他线程修改，就
会出现和预期不一致的问题。
	java使用 Object.wait/Object.wait(long)实现线程暂停，使用 Object.notify()/Object.notifyAll()实现通知。
	任意对象都可以执行wait方法，因执行anyObject.wait()而暂停的线程称为对象anyObject上的等待线程。一个对象的wait方法可以被多个线程执行，所以一个对象可以有
多个等待线程。对象anyObject上的等待线程需要其他线程执行anyObject.notify()方法来唤醒。线程在执行anyObject.wait()时会自动释放其持有的anyObject对应的内部锁，
所以通常会使用anyObject作为内部锁和执行暂停的对象：
		synchronized(anyObject){
			while(保护条件不满足){
				anyObject.wait();	//执行时会释放anyObject对应的内部锁
			}
			doAction();
		}
	anyObject.wait()不会立即返回，而是在线程被唤醒后重新申请到anyObject对应的锁后再返回。
	唤醒对象anyObject上的等待线程：
		synchronized(anyObject){
			updateSharedState();
			anyObject.notify();
			//anyObject.notifyAll();
		}
	只有执行线程持有anyObject对象的内部锁时，才能执行anyObject.notify()。anyObject.notify()不会释放anyObject对应的内部锁，只有在这个同步代码块/同步方法
执行完后才会释放这个锁，所以应该把anyObject.notify()放在靠近同步代码块结束的位置。
	anyObject.notify()只会唤醒anyObject上的一个等待线程，选择哪个线程是随机的，如果要唤醒该对象上的所有等待线程，应该使用notifyAll方法。
	anyObject.wait(long)执行后，如果超过long指定的时间后没有其他线程执行anyObject.notify()/notifyAll()，即该线程没有被其他线程唤醒，虚拟机就会唤醒该线程。
所以这个方法外还是应该使用while来检查保护条件，如果超时可以编写代码break，可以在执行目标动作前再检查保护条件判断是否是等待超时造成的。
	过早唤醒问题：如果多个使用不同保护条件的目标方法使用了同一个对象anyObject来实现线程暂停和唤醒，就可能出现，在某个线程更新了某一保护条件后为了唤醒等待该条件
的所有线程而执行了anyObject.notifyAll，导致anyObject对象上等待其他条件的线程也被唤醒，这些线程的等待条件仍不满足，所以不得不再次暂停。
	信号丢失问题：指的是代码中没有检查保护条件就直接调用wait方法，而在调用wait方法前其他线程已经更新了保护条件和执行了notify，这样就导致等待线程错过了通知信号。
信号丢失问题其实是代码错误，而非wait/notify方法实现等待/通知的问题。
	操作系统允许一个暂停线程被系统偶发性唤醒，这称为欺骗性唤醒，不过其发生概率非常低，通过将wait方法调用放在检查保护条件的while循环中可以避免欺骗性唤醒的影响。
	执行wait方法后暂停线程和执行notify方法唤醒暂停线程都涉及线程上下文切换、锁的申请和释放。
	选用notify和notifyAll的经验：优先选用notifyAll保证程序正确性，只在notify不影响正确性的时候使用notify以避免notifyAll可能导致的过早唤醒问题。
	threadA.join方法用于暂停当前线程，直到threadA执行结束后才继续执行当前线程，join方法内使用wait方法实现线程暂停。
    条件变量：java.util.concurrent.locks.Condition接口的实例可以用来代替实现等待/通知功能，这个接口提供方法：await、awaitUntil、signal、signalAll方法。
Lock接口中有一个newCondition方法返回一个Condition接口实例。
    Condition.await和Object.wait实现的是执行线程等待一个通知信号（Condition.signal或signalAll和Object.notify或notifyAll产生信号）。
    可以使用同一个显示锁对象的不同Condition实例来暂停使用不同保护条件的线程，这样就可以避免在同一个对象上调用notifyAll导致的过早唤醒问题。
    Condition的awaitUntil方法接收一个Date对象作为参数，表示超时时间点，这个方法返回一个boolean值，返回true表示是被其他线程唤醒（即其他线程更新保护条件后
调用Condition对象的signal或signalAll方法唤醒暂停线程），返回false表示超时。
        import java.util.Date;
        import java.util.concurrent.locks.Condition;
        import java.util.concurrent.locks.Lock;
        import java.util.concurrent.locks.ReentrantLock;

        public class ConditionDemo {

            private Lock lock = new ReentrantLock();

            private Condition cond1 = lock.newCondition();

            private Condition cond2 = lock.newCondition();

            private boolean status1 = false;

            private boolean status2 = false;

            public static void main(String[] args) throws InterruptedException {
                // test01();
                test02();
            }

            // 测试Condition的过早唤醒问题解决方式
            private static void test01() throws InterruptedException {
                ConditionDemo demo = new ConditionDemo();
                for (int i = 1; i < 5; i++) {
                    final int j = i;
                    Thread thread = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                demo.doSomething1(j % 2);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    });
                    thread.setName("thread-" + i);
                    thread.start();
                }
                // Thread.sleep(500);
                demo.doUpdateStatus(1);
                Thread.sleep(500);
                demo.doUpdateStatus(0);
            }

            private void doSomething1(int sign) throws InterruptedException {
                lock.lock();
                try {
                    if (sign == 0) {
                        while (!status1) {
                            System.out.println(Thread.currentThread().getName() + " wait status1");
                            cond1.await();
                        }
                    }
                    if (sign == 1) {
                        while (!status2) {
                            System.out.println(Thread.currentThread().getName() + " wait status2");
                            cond2.await();
                        }
                    }
                    doNow();
                } finally {
                    lock.unlock();
                }
            }

            private void doNow() {
                System.out.println("------doNow start!!!------");
                System.out.println("thread: " + Thread.currentThread().getName());
                System.out.println("status1 = " + status1);
                System.out.println("status2 = " + status2);
                System.out.println("------doNow end!!!!!------");
            }

            private void doUpdateStatus(int sign) {
                lock.lock();
                try {
                    if (sign == 0) {
                        status1 = true;
                        cond1.signalAll();
                    }
                    if (sign == 1) {
                        status2 = true;
                        cond2.signalAll();
                    }
                } finally {
                    lock.unlock();
                }
            }

            // 测试Condition的判断超时等待解决方式
            private static void test02() throws InterruptedException {
                ConditionDemo demo = new ConditionDemo();
                for (int i = 1; i < 3; i++) {
                    final int j = i;
                    Thread thread = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            try {
                                demo.doSomething2(j * 1000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    });
                    thread.setName("thread-" + i);
                    thread.start();
                }
                Thread.sleep(1200);
                demo.doUpdateStatus(0);
            }

            private void doSomething2(int timeToWait) throws InterruptedException {
                Date deadline = new Date(System.currentTimeMillis() + timeToWait);
                lock.lock();
                try {
                    while (!status1) {
                        boolean getSignal = cond1.awaitUntil(deadline);
                        if (!getSignal) {
                            System.out.println(Thread.currentThread().getName() + " timeout....");
                            return;
                        }
                    }
                    doNow();
                } finally {
                    System.out.println("finally do....");
                    lock.unlock();
                }
            }
        }
    计数协调器：java.util.concurrent.CountDownLatch维护一个计数器，调用其方法await时，如果计数器值不为0就暂停执行线程，其他线程调用其方法countDown，
其内部计数器值减一，直到计数器值减为0就唤醒执行await的线程，如果继续调用countDown方法，不会再改变计数器值。计数器初始值根据构造函数参数设置。
    CountDownLatch.await实现的是执行线程等待多个信号，CountDownLatch.countDown产生一个这样的信号。
        public class CountDownLatchDemo {

            private boolean status1 = false;
            private boolean status2 = false;
            private boolean status3 = false;

            public static void main(String[] args) throws InterruptedException {
                // test01();
                test02();
            }

            private static void test01() throws InterruptedException {
                CountDownLatchDemo demo = new CountDownLatchDemo();
                CountDownLatch latch = new CountDownLatch(5);
                demo.doSomething1(latch);
                latch.await();
                System.out.println("start..." + latch.getCount());
            }

            private void doSomething1(CountDownLatch latch) {
                for (int i = 1; i < 8; i++) {
                    new Thread() {
                        @Override
                        public void run() {
                            try {
                                System.out.println(Thread.currentThread().getName() + " : " + latch.getCount());
                            } finally {
                                latch.countDown();
                            }
                        }
                    }.start();
                }
            }

            private static void test02() throws InterruptedException {
                CountDownLatchDemo demo = new CountDownLatchDemo();
                CountDownLatch latch = new CountDownLatch(2);
                demo.doSomething2(latch);
                latch.await();
                System.out.println("start..." + latch.getCount());
                System.out.println("status1 is true ? " + demo.status1);
                System.out.println("status2 is true ? " + demo.status2);
                System.out.println("status3 : " + demo.status3);
            }

            private void doSomething2(CountDownLatch latch) {
                new Thread() {
                    @Override
                    public void run() {
                        step1();
                        latch.countDown();
                        step2();
                        latch.countDown();
                        step3();
                        step4();
                    }
                }.start();
                new Thread() {
                    @Override
                    public void run() {
                        step2();
                        latch.countDown();
                        step4();
                    }
                }.start();
            }

            private void step1() {
                System.out.println("step1...");
                status1 = true;
            }

            private void step2() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("step2...");
                status2 = true;
            }

            private void step3() {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("step3...");
                status3 = true;
            }

            private void step4() {
                System.out.println("step4...");
            }
        }
    栅栏：java.util.concurrent.CyclicBarrier用于设置线程间互相等待时的暂停/通知，构造函数参数设置一个计数器初始值，当其await方法被调用一次，计数器值
减一，当计数器值不为0时，执行await方法的线程就暂停，计数器值为0时，执行线程就唤醒其他等待线程。CyclicBarrier构造方法可以接收一个Runnable实例作为第二个
参数，该Runnable实例的run方法将在更新计数器为0的线程唤醒其他等待线程前执行(由当前线程执行)。
    CyclicBarrier.await实现的是多个线程互相等待，每个线程执行CyclicBarrier.await即各自产生一个信号，当约定的所有线程都产生了信号，所有暂停线程就被唤醒。
        import java.util.concurrent.BrokenBarrierException;
        import java.util.concurrent.CyclicBarrier;

        public class CycliyBarrierDemo {

            public static void main(String[] args) {
                test01();
            }

            private static void test01() {
                // CyclicBarrier barrier = new CyclicBarrier(5);
                CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("everyone is here! are you ready?");
                    }
                });
                for (int i = 0; i < 5; i++) {
                    new Thread() {
                        @Override
                        public void run() {
                            System.out.println(Thread.currentThread().getName() + " : Hello!");
                            try {
                                barrier.await();
                                System.out.println("done !");
                            } catch (InterruptedException | BrokenBarrierException e) {
                                e.printStackTrace();
                            }
                        }
                    }.start();
                }
            }
        }
    CyclicBarrier可以用于测试中模拟高并发。
    阻塞队列：java.util.concurrent.BlockingQueue是线程安全的队列，可以充电生产者-消费者模型中的传输通道，实现类包括ArrayBlockingQueue、
LinkedBlockingQueue、SynchronousQueue。
    BlockingQueue.put(T)方法用于添加一个对象到队列中，如果队列已经满了，这个方法就阻塞，阻塞时生产者线程将被暂停；如果put执行前队列为空，put执行时会
产生一个通知，如果有等待的消费者线程，这些线程中的一个将被唤醒。
    BlockingQueue.take()方法从队列中取出一个元素，如果队列上存在等待的生产者线程，就唤醒其中一个生产者线程，如果队列为空，这个方法就会阻塞，消费者线程
被暂停，直至有生产者线程添加一个对象到队列中时，消费者线程才被唤醒。
    BlockingQueue还提供put和take方法的非阻塞版本：offer和poll，offer返回一个布尔值，返回true表示入队成功，返回false表示队列已满；poll方法返回对象，如果
队列为空，则返回null。
    阻塞队列可以分为有界队列和无界队列。有界队列可以自动调整生产者、消费者线程的处理速率，ArrayBlockingQueue、LinkedBlockingQueue都可以用于实现有界队列，
ArrayBlockingQueue的put方法和take方法使用同一个显示锁对象，所以会出现锁的争用，即在put时，不能进行take。LinkedBlockingQueue的put方法和take方法使用不同
的显式锁对象，所以可以并行执行（使用原子变量AtomicInteger表示队列元素数量，所以还是存在对这个原子变量的争用），但是这类队列基于链表，所以take后脱离链表的
节点对象会增加GC的负担。
    LinkedBlockingQueue也可以用来构造无界队列，无界队列不会导致生产者线程阻塞（无界队列的容量是Integer.MAX_VALUE，程序中基本上不会产生这样大的数据量），
但是这样也可能导致资源（内存）消耗过大。
    SynchronousQueue实际上不是队列，它不维护保存数据的缓冲区，其put方法执行时，如果没有其他线程调用take方法，put方法就阻塞，直到其他线程调用了take方法，
阻塞的生产者线程才被唤醒继续执行；如果put方法执行时，存在等待的消费者线程（消费者线程执行take方法时阻塞暂停），就唤醒某个等待的消费者线程。
    ArrayBlockingQueue和SynchronousQueue支持非公平调度和公平调度(默认都是非公平调度)，而LinkedBlockingQueue只支持非公平调度，所以使用LinkedBlockingQueue
不能保障先执行put的线程提交的数据会被先消费。
    ArrayBlockingQueue适用于并发程度不高的场景，LinkedBlockingQueue适用于并发更高的场景，SynchronousQueue适用于生产速率和消费速率差不多的场景。
        private static void test01() {
            //BlockingQueue<String> channel = new ArrayBlockingQueue<String>(2);
            BlockingQueue<String> channel = new ArrayBlockingQueue<String>(2,true);
            //BlockingQueue<String> channel = new LinkedBlockingQueue<String>(2);
            for (int i = 0; i < 5; i++) {
                new Thread() {
                    @Override
                    public void run() {
                        try {
                            channel.put(Thread.currentThread().getName());
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }.start();
            }

            try {
                System.out.println(channel.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 4; i++) {
                new Thread() {
                    @Override
                    public void run() {
                        try {
                            System.out.println(channel.take());
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }.start();
            }
        }

        private static void test02() {
            //BlockingQueue<String> channel = new SynchronousQueue<String>();
            BlockingQueue<String> channel = new SynchronousQueue<String>(true);
            try {
                for (int i = 0; i < 2; i++) {
                    new Thread() {
                        @Override
                        public void run() {
                            try {
                                System.out.println(channel.take());
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }.start();
                }
                new Thread() {
                    @Override
                    public void run() {
                        try {
                            channel.put(Thread.currentThread().getName());
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }.start();
                channel.put(Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
 
        private static void test03() {
            BlockingQueue<String> channel = new ArrayBlockingQueue<>(5);
            // BlockingQueue<String> channel = new SynchronousQueue<String>();
            System.out.println(channel.offer("hello"));
            System.out.println(channel.poll());
        }
    流量控制：java.util.concurrent.Semaphore可以用来为资源设置配额，从而控制获得资源的请求线程的数量，实现流量控制。Semaphore构造函数接收一个整数作为
参数，表示资源配额，每次执行Semaphore.acquire方法时，如果可用配额不为0，则返回并将资源配额减一，如果可用配额为0，则执行线程被暂停；每次调用Semaphore的
release方法，可用配额的值就加一（不受原始配额控制，即可以超过原始配额）。
        private static void test04() {
            Semaphore semaphore = new Semaphore(1);
            semaphore.release();
            try {
                semaphore.acquire();
                System.out.println("acquire success");
                semaphore.acquire();
                System.out.println("acquire again success");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    通常，release方法和acquire方法应该配对使用，申请一个配额，就应该返还一个配额。
        private static void test04() {
            BlockingQueue<String> channel = new LinkedBlockingQueue<String>();
            Semaphore semaphore = new Semaphore(2);
            for (int i = 0; i < 9; i++) {
                new Thread() {
                    @Override
                    public void run() {
                        try {
                            semaphore.acquire();
                            channel.put(Thread.currentThread().getName());
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } finally {
                            semaphore.release();
                        }
                    }
                }.start();
            }
        }
    使用管道流来实现线程间通信：PipedInputStream和PipedOutputStream可以提供基于字节流的通信模型，通常用在两个线程中，而且这种通信是单向的，其中
PipedOutputStream在发送数据的线程中执行write方法，向其他线程发送数据，PipedInputStream使用read方法读取数据：
        private static void test01() {
            try {
                PipedInputStream pin = new PipedInputStream();
                PipedOutputStream pout = new PipedOutputStream(pin);
                new Thread() {
                    @Override
                    public void run() {
                        try {
                            Thread.sleep(500);
                            String str = "hello! this is " + Thread.currentThread().getName();
                            //这里write方法不会等待其他线程调用pin.read后才返回，而是写出成功就返回。
                            pout.write(str.getBytes());
                            Thread.sleep(500);
						    pout.write("\tgood morning!".getBytes());
                            System.out.println("send message success!");
                        } catch (Exception e) {
                            e.printStackTrace();
                            try {
                                //这里关闭pout，pin.read就会返回-1
                                pout.close();
                            } catch (IOException e1) {
                                e1.printStackTrace();
                            }
                        }
                    }
                }.start();

                System.out.println("before");
                while (true) {
                    byte[] buf = new byte[1024];
                    int len = pin.read(buf);
                    String msg = new String(buf, 0, len, StandardCharsets.UTF_8);
                    System.out.println("收到消息：: " + msg);
                }
            } catch (IOException e) {
                //写线程终止后，主线程调用pin.read会抛出异常
                //e.printStackTrace();
                System.out.println("finish");
            }
        }
    数据交换器：java.util.concurrent.Exchanger.Exchanger用于在两个线程间交换数据，这是一种双向通信模式，不是基于消息的通信，而是需要互相等待。当一个
线程调用Exchanger.exchange(T)时，如果另一个线程没有调用exchange方法，则调用线程将暂停，直到第二个线程调用exchange方法唤醒该线程，这个方法将返回对方线程
提供的数据，即线程间实现了数据交换。
	private static void test01() {
		Exchanger<List<String>> exchanger = new Exchanger<>();
		new Thread() {
			@Override
			public void run() {
				List<String> buf1 = new ArrayList<String>();
				for (int i = 0; i < 5; i++) {
					for (int j = 0; j < 3; j++) {
						buf1.add(i + "-" + j);
					}
					try {
						List<String> ll = exchanger.exchange(buf1);
						System.out.println(Thread.currentThread().getName() + " get : " + ll);
						buf1 = new ArrayList<String>();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("===============");
				}
			}
		}.start();

		new Thread() {
			@Override
			public void run() {
				List<String> buf1 = new ArrayList<String>();
				for (int i = 0; i < 5; i++) {
					for (int j = 0; j < 3; j++) {
						buf1.add(i + "=" + j);
					}
					try {
						List<String> ll = exchanger.exchange(buf1);
						System.out.println(Thread.currentThread().getName() + " get : " + ll);
						buf1 = new ArrayList<String>();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("************");
				}
			}
		}.start();
	}
	在生产者-消费者模型中，有时候生产者生成的产品是待执行的任务，生产者线程通过通道把这些任务提供给消费者线程，由消费者线程执行。在这种多线程模型中，一个
消费者线程可以执行多个任务，可以在线程数量有限制的情景下充分利用线程资源。
	线程中断机制：一个线程请求另外一个线程停止其正在执行的操作。java中的线程中断机制是通过一个线程发送一个指示给另外一个线程实现的，具体来说，是通过修改
线程维护的中断标记以通知目标线程，但是目标线程可以不处理其接收到的中断指示，从而继续执行。
	获取当前线程的中断标记：
		Thread.currentThread().isInterrupted();	//返回true表示接收到中断指示，false表示没有收到中断指示
	获取线程的中断标记然后将其重置为false：
		Thread.interrupted();	//可以在目标线程中获取重置自身的中断标记，这是一个静态方法。
	设置线程中断标记为true：
		threadA.interrupt();	//通常用于通知目标线程中断执行
	核心库中一些阻塞API不会对线程中断（标记）做成响应，如InputStream.read、ReentrantLock.lock等：
		private static void  test01(){
			Thread t1 = new Thread(()->{
				try(InputStream in = new FileInputStream("/tem_file/files/app.js");){
					int c;
					int i = 0;
					while ((c = in.read()) != -1){
						if(Thread.currentThread().isInterrupted()){
							i++;
							System.out.println("get interrupted indicator");
							if(i==2){
								Thread.interrupted();
							}
						}
					}
					System.out.println("success!");
				} catch (Exception e){
					e.printStackTrace();
				}
			});
			t1.start();
			System.out.println("before");
			t1.interrupt();
			System.out.println("after");
		}

	还有一些核心API会在检查到线程中断标记后抛出InterruptedException异常，如Thread.sleep(long)、ReentrantLock.lockInterruptibly()等：
		private static void  test02(){
			Thread t1 = new Thread(()->{
				while (true){
					System.out.println("now : "+System.currentTimeMillis());
					try {
						Thread.sleep(5);
					} catch (InterruptedException e){
						e.printStackTrace();
						break;
					}
				}
			});
			t1.start();
			System.out.println("before");
			try {
				Thread.sleep(5);
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			t1.interrupt();
			System.out.println("after");
		}
	ReentrantLock.lockInterruptibly()等在阻塞前（暂停线程前）,会先检查线程中断标记，如果收到中断指示，就直接抛出异常，如果在阻塞期间，收到中断指示，虚拟机
会先唤醒暂停的线程，然后这些线程就可以继续执行，执行过程中通常也会继续检查中断标记。
	在自己的程序中，也可以使用这两种模式，即不处理和抛出异常，另外一种模式是在多阶段任务模型中，只在某些任务执行时检查中断标记并决定是终止当前任务，还是继续
或者终止线程。
	终止当前任务：
		private static void  test03(){
			Thread t1 = new Thread(()->{
				step1();
				step2();
			});
			t1.start();
			System.out.println("before");
			try {
				Thread.sleep(5);
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			t1.interrupt();
			System.out.println("after");
		}

		private static void  step1(){
			System.out.println("step1....start....");
			while (true){
				if(Thread.currentThread().isInterrupted()){
					System.out.println("step1....canceled....");
					//终止当前任务
					break;
				}
				System.out.println("step1....doing....");
			}
		}

		private static void  step2(){
			System.out.println("step2。。。。start。。。。");
			if(Thread.currentThread().isInterrupted()){
				System.out.println("step2。。。。continue。。。。");
			}
			System.out.println("step2。。。。finish。。。。");
		}
	终止当前线程：
		private static void  test04(){
			Thread t1 = new Thread(()->{
				int i=0;
				while (i++ < 500){
					if(Thread.currentThread().isInterrupted()){
						System.out.println("thread....stop....");
						//终止当前线程
						return;
					}
					System.out.println("....step1 doing....");
				}
				System.out.println(".....other work......");
				i=0;
				while (i++ < 10000){
					if(Thread.currentThread().isInterrupted()){
						System.out.println("thread....stop....");
						return;
					}
					System.out.println("....step2 doing....");
				}
			});
			t1.start();
			System.out.println("before");
			try {
				Thread.sleep(5);
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			t1.interrupt();
			System.out.println("after");
		}
	应用层代码中如果调用了会抛出InterruptedException的API，应用层方法可以选择以下处理方案：
		1、当无法决定如果处理时，直接抛出，由调用者决定如何处理；
		2、捕获后做一些本地处理，然后抛出给调用者；
		3、捕获后，重新设置中断标记（调用interrupt方法），表示当前任务不响应中断，其他任务自行决定如何处理中断。
	最好不要在应用层捕获了InterruptedException后不做任何处理，这样做就导致了中断指示的消失。
	停止线程：早期API：Thread.stop()早已不建议使用，现在也很少有程序使用这个这个API来停止线程，但是官方一直没有给出新的停止线程执行的API，所以需要停止线程时，
需要在应用程序中自己实现。基本思路是设计一个停止标记，在线程（任务）的run方法中检测这个标记，检测到就直接返回，线程就停止了。
		class PureTask implements Runnable{
			private boolean proceed = true;

			public void stop(){
				proceed = false;
				Thread.currentThread().interrupt();
			}

			@Override
			public void run() {
				int i=0;
				while (i<10000){
					if(!proceed){
						System.out.println("found interrupted, return");
						return;
					}
					//这个方法可能会清除中断标记，但是不抛出异常
					doSomething();
					try {
						Thread.sleep(50);
					} catch (InterruptedException e) {
						Thread.currentThread().interrupt();
						e.printStackTrace();
						return;
					}
				}
			}

			private void doSomething(){
				if(Thread.interrupted()){
					System.out.println("found interrupted, do nothing");
				}
			}
		}

		private static void test01(){
			PureTask task = new PureTask();
			Thread t1 = new Thread(task);
			t1.start();
			try {
				Thread.sleep(5);
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			task.stop();
		}
	线程停止，有时候需要“优雅”地停止，即正在处理中的任务，需要处理完才停止线程，可以通过捕获中断异常，然后再重新设置中断标记实现。
	在基于web容器的web应用中，在停止应用时，应用容器进程没有退出，这是如果要终止应用线程，需要使用单独的监听器，在应用卸载时的回调方法中终止应用线程，可以使用
一个线程登记器，在启动每个线程时就登记上该应用线程，在监听器的对应方法中就可以得到需要卸载的应用线程了。
	
	第六章
	无状态对象：一个类的一个实例对象被多个线程使用时，不会让这些线程存在共享状态，这样的类的实例对象就是无状态对象。
	无状态对象具有固有的线程安全性，客户端使用无状态对象不需要加锁，无状态对象的方法也不需要加锁，即允许多个线程并发（并行）执行无状态对象的任意公开方法。
	无状态对象类及其上层类没有实例变量域和可变的静态变量域，但是一个类不包含任何实例变量域和静态变量域，并不能保证它就是一个无状态变量类。
		public class NoStateObjDemo {
			public static void main(String[] args) {
				test01();
			}

			private static void test01() {
				//NoStateObj1 obj1 = new NoStateObj1();
				UnRealNoStateObj obj1 = new UnRealNoStateObj();
				String[] dateStrs = { "2018-12-31", "2018-12-30", "2018-12-29", "2018-12-28", "2018-12-27" };
				for (int i = 0; i < 5; i++) {
					int j = i;
					new Thread(() -> {
						Date date = obj1.parse(dateStrs[j]);
						System.out.println(Thread.currentThread().getName() + " get : " + date.toString());
					}).start();
				}
			}
		}

		class NoStateObj1 {
			public Date parse(String dateStr) {
				SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd");
				try {
					return formater.parse(dateStr);
				} catch (ParseException e) {
					e.printStackTrace();
					return null;
				}
			}
		}

		class UnRealNoStateObj {
			public Date parse(String dateStr) {
				return UnSafeFormater.INSTANCE.parse(dateStr);
			}
		}

		enum  UnSafeFormater {
			INSTANCE;
			private UnSafeFormater(){}
			private SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd");

			public Date parse(String dateStr) {
				try {
					return formater.parse(dateStr);
				} catch (ParseException e) {
					e.printStackTrace();
					return null;
				}
			}
		}
	不可变对象：指的是一经创建，其状态就保持不变的对象。不可变对象也具有固有的线程安全性。
	当不可变对象所建模的现实实体的状态发生变化时，系统通过创建新的不可变对象来建模，而不是调整原建模对象。
	不可变对象多用在状态变化不频繁的模型中，如果一个对象的状态变化频率较高，使用不可变对象建模将导致大量的垃圾对象，造成GC的负担。对于大的不可变对象，状态变化
创建新的对象时，可以使用浅克隆的方式来重用原对象的部分变量。
	不可变对象作为map的key使用时，可以避免对象状态变化导致获取value失败的问题。
	当不可变对象需要暴露自身的状态给外部客户端，可以使用防御性复制和不可修改的迭代器来实现。
		public class ImmutableObjDemo {
			public static void main(String[] args) {
				//test01();
				test02();
			}

			private static HashMap<String,Object> prepareData(){
				HashMap<String,Object> map = new HashMap<>();
				map.put("name","zhangwei");
				map.put("age",25);
				map.put("tools",new String[]{"java","js","linux"});
				return map;
			}

			private static void test01(){
				HashMap<String,Object> map = prepareData();
				ImmutableObj1 obj1 = new ImmutableObj1(map);
				ImmutableObj1 obj2 = obj1.update("age",26);

				System.out.println(obj1.get("tools"));
				System.out.println(obj2.get("tools"));
			}

			private static void test02() {
				HashMap<String, Object> map = prepareData();
				ImmutableObj1 obj1 = new ImmutableObj1(map);
				Iterator<Map.Entry<String,Object>> iterator = obj1.iterator();
				while (iterator.hasNext()){
					Map.Entry<String,Object> entry = iterator.next();
					System.out.println(entry.getKey()+" : "+entry.getValue());
					if(entry.getKey().equals("age") && (Integer)entry.getValue()==25){
						// 不能删除：UnsupportedOperationException
						// iterator.remove();
					}
				}
			}
		}

		class ImmutableObj1{
			private final HashMap<String,Object> map;

			public ImmutableObj1(HashMap<String,Object> map){
				this.map = map;
			}

			public Object get(String key){
				return map.get(key);
			}

			public ImmutableObj1 update(String key,Object value){
				return new ImmutableObj1(copyMap(this,key,value));
			}
			
			public Set<Map.Entry<String,Object>> entrySet(){
				final Set<Map.Entry<String,Object>> entries = Collections.unmodifiableSet(map.entrySet());
				// 不能修改: UnsupportedOperationException
				// entries.clear();
				return entries;
			}

			public Iterator<Map.Entry<String,Object>> iterator(){
				final Set<Map.Entry<String,Object>> entries = entrySet();
				return new ReadOnlyIterator(entries.iterator());
			}

			private HashMap<String,Object> copyMap(ImmutableObj1 prototype,String key,Object value){
				HashMap<String,Object> newMap = (HashMap<String,Object>)prototype.map.clone();
				newMap.put(key,value);
				return newMap;
			}
		}
	线程特有对象：只能被一个线程访问的对象称为线程特有对象。某些特定类型的线程特有对象，一个线程只需要该类对象的一个实例，并且这个实例会被该线程所执行的多个方法
共享。
	ThreadLocal<T>的实例对象被设计为线程访问其线程特有对象的代理，一个线程可以有多个ThreadLocal<T>实例，多个线程也可以共用一个ThreadLocal<T>实例。
	ThreadLocal通常作为静态字段使用，而不需要为每个对象都添加一个ThreadLocal实例。
		public class ThreadLocalDemo {
			private static Map<String,String> map = new HashMap<>();
			private static ThreadLocal<String> tl1 = new ThreadLocal<>();
			//这样就不需要在每个方法中去创建SimpleDateFormat对象，且是线程安全的
			private static ThreadLocal<SimpleDateFormat> tl2 = ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd"));

			public static void main(String[] args) {
				//test01();
				test02();
			}

			private static void test01(){
				CyclicBarrier barrier = new CyclicBarrier(100);
				for (int i=0;i<100;i++){
					new Thread(()->{
						//doSomething1(barrier);
						doSomething2(barrier);
					}).start();
				}
			}

			private static void test02(){
				String[] dateStrs = { "2018-12-31", "2018-12-30", "2018-12-29", "2018-12-28", "2018-12-27" };
				CyclicBarrier barrier = new CyclicBarrier(5);
				for (int i=0;i<5;i++){
					final int j = i;
					new Thread(()->{
						Date date = parseDate(dateStrs[j],barrier);
						System.out.println(Thread.currentThread().getName() + " get : " + date);
					}).start();
				}
			}

			private static void doSomething1(CyclicBarrier barrier){
				try {
					barrier.await();
				} catch (InterruptedException | BrokenBarrierException e){
					e.printStackTrace();
				}
				//使用map，线程不安全
				String str1 = map.get(Thread.currentThread().getName());
				if(str1==null){
					map.put(Thread.currentThread().getName(),Thread.currentThread().getName());
				}
				System.out.println("a: "+Thread.currentThread().getName()+"\tb:"+map.get(Thread.currentThread().getName()));
			}
			private static void doSomething2(CyclicBarrier barrier){
				try {
					barrier.await();
				} catch (InterruptedException | BrokenBarrierException e){
					e.printStackTrace();
				}
				//使用ThreadLocal
				String str2 = tl1.get();
				if(str2==null){
					tl1.set(Thread.currentThread().getName());
				}
				System.out.println("1: "+Thread.currentThread().getName()+"\t2: "+tl1.get());
			}
			private static Date parseDate(String dateStr,CyclicBarrier barrier){
				try {
					barrier.await();
				} catch (InterruptedException | BrokenBarrierException e){
					e.printStackTrace();
				}
				try {
					return tl2.get().parse(dateStr);
				} catch (ParseException e) {
					e.printStackTrace();
					return null;
				}
			}
		}
	ThreadLocal的原理：每个Thread实例都有一个柜子（ThreadLocal.ThreadLocalMap类型的threadLocals），Thread实例不自己从这个柜子取东西和存东西，而是通过
某个ThreadLocal实例作为助手来操作，一个线程实例可以有多个ThreadLocal实例作为助手。每个ThreadLocal实例只管理柜子里的一样东西，每次存取东西时先要获得Thread
实例的柜子threadLocals，如果这个柜子不存在，就打造一个柜子并把初始化的值放到柜子里，如果柜子已经存在，就只取出或存入自己管理的东西即可。
	ThreadLocal带来的问题：Thread实例总是通过ThreadLocal实例来访问其内部的threadLocals中的数据，而在threadLocals中是通过弱引用来引用ThreadLocal实例，通过
强引用来引用线程特有对象，这就导致当线程还存活但是ThreadLocal实例已经被销毁后（弱引用不干涉GC），线程的threadLocals中引用的线程特有对象已经不能被访问到了，但
是由于强引用还存在，导致其不能被GC。（这类线程特有对象要等到线程对象被销毁后才能被GC回收，属于伪内存泄漏[无效对象不能被及时回收导致内存消耗]）。在web容器中，
一个工作者线程会被重复使用处理多个请求，并且自定义类通常使用web容器内实现的加载器加载，这就导致线程特有对象通过引用链引用了ThreadLocal实例，最终导致ThreadLocal
实例和线程特有对象实例在web应用停止和卸载（web容器仍然运行，工作者线程也仍然存活）后也不能被GC回收，导致内存泄漏。
	自定义线程特有对象类型实例-->自定义线程特有对象类型class对象-->web容器内实现的类加载器实例-->处理请求的自定义servlet等实例
		-->自定义servlet等类型的静态ThreadLocal实例
	使用装饰器模式来实现线程安全：基本思路是为非线程安全的对创建一个线程安全的外包装对象（代理），客户端不直接访问非线程安全的对象，而是通过线程安全的外包装对象
来访问，线程安全的外包装对象通常使用加锁来保障线程安全。
	java.util.Collections提供一系列synchronizedX方法，为非线程安全的集合对象提供线程安全的外包装对象：
		private static void test01(){
			//List<Integer> list = new ArrayList<>();
			List<Integer> list = Collections.synchronizedList(new ArrayList<>());
			CyclicBarrier barrier = new CyclicBarrier(20);
			CountDownLatch latch = new CountDownLatch(20);
			for (int i=0;i<20;i++){
				final int j = i;
				new Thread(()->{
					try {
						barrier.await();
					} catch (InterruptedException | BrokenBarrierException e) {
						e.printStackTrace();
					}
					list.add(j);
					latch.countDown();
				}).start();
			}
			try {
				latch.await();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			Iterator<Integer> iterator = list.iterator();
			while (iterator.hasNext()){
				System.out.println(iterator.next());
			}
		}
	Collections.synchronizedX方法返回的集合对象是线程安全的，其API接口和原集合对象完全一致，通常称这些线程安全的集合为同步集合。
	同步集合的iterator方法返回的Iterator并不是线程安全的，如果需要使用，则需要加锁，而且必须使用同步集合内部使用的锁，这在设计上出现了耦合。
	并发集合：jdk1.5开始核心类库中新增了并发集合类：CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentLinkedQueue等。
	并发集合都是线程安全的，使用时不需要加锁，其内部也不使用锁来保障线程安全性，而是使用CAS实现（锁粒度太粗了）。
	CopyOnWriteArrayList、CopyOnWriteArraySet基于快照模式实现，即通过其iterator方法拿到的是当时的集合的副本，并且这个副本是不能修改的，而其他如
ConcurrentLinkedQueue等则不使用快照模式，每个线程操作的都是实际的那个集合。
		private static void test03(){
			//List<Integer> list = new CopyOnWriteArrayList<>();
			Queue<Integer> list = new ConcurrentLinkedQueue<>();
			for (int i=0;i<20;i++){
				final int j = i;
				new Thread(()->{
					list.add(j);
				}).start();
			}
			Iterator<Integer> iterator = list.iterator();
			while (iterator.hasNext()){
				System.out.println(iterator.next());
			}
		}

	第七章 线程活性故障
	死锁：两个或多个线程都在等待对方持有的锁（资源），同时都不释放自己持有的锁（资源），导致各个线程都处于BLOCKED或WAITING状态。
	死锁实例：哲学家就餐问题：
		public class PhilosopherEatingDemo {
			public static void main(String[] args) {
				Chopstick[] chopsticks = new Chopstick[5];
				Philosopher[] philosophers = new Philosopher[5];
				for(int i=0;i<5;i++){
					chopsticks[i] = new Chopstick();
				}
				for(int i=0;i<5;i++){
					philosophers[i] = new Philosopher(chopsticks[i],chopsticks[(i+1)%5]);
				}
				for(int i=0;i<5;i++){
					final int j = i;
					new Thread(()->{
						while (true){
							philosophers[j].eat();
							philosophers[j].think();
						}
					}).start();
				}
			}
		}

		class Philosopher{
			private Chopstick left;
			private Chopstick right;

			public Philosopher(Chopstick l,Chopstick r){
				this.left = l;
				this.right = r;
			}

			public void think(){
				String threadName = Thread.currentThread().getName();
				long threadId = Thread.currentThread().getId();
				//System.out.println(Thread.currentThread().getName()+" : thinking....");
			}

			public void eat(){
				synchronized (left){
					left.pickUp();
					synchronized (right){
						right.pickUp();
						//System.out.println(Thread.currentThread().getName()+" : eating....");
						right.putDown();
					}
					left.putDown();
				}
			}
		}

		class Chopstick{
			private String status = "DOWN";

			public void pickUp(){
				status = "UP";
			}

			public void putDown(){
				status = "DOWN";
			}
		}
	通过JvisualVM可以查看到出现死锁，生成线程转储后可以在其中看到以下信息：
		...
		Found one Java-level deadlock:
		=============================
		"Thread-4":
		waiting to lock monitor 0x000000001e0c2328 (object 0x000000076b25d748, a com.zhangwei.javabase.thread.Chopstick),
		which is held by "Thread-0"
		"Thread-0":
		waiting to lock monitor 0x00000000030bb548 (object 0x000000076b25d788, a com.zhangwei.javabase.thread.Chopstick),
		which is held by "Thread-1"
		"Thread-1":
		waiting to lock monitor 0x000000001e0c3928 (object 0x000000076b25d798, a com.zhangwei.javabase.thread.Chopstick),
		which is held by "Thread-2"
		"Thread-2":
		waiting to lock monitor 0x00000000030bc9e8 (object 0x000000076b25d7a8, a com.zhangwei.javabase.thread.Chopstick),
		which is held by "Thread-3"
		"Thread-3":
		waiting to lock monitor 0x00000000030bc938 (object 0x000000076b25d7b8, a com.zhangwei.javabase.thread.Chopstick),
		which is held by "Thread-4"
	这里使用内部锁，这几个线程都处于BLOCKED状态，如果使用显示锁的lock和lockInterruptibly方法，则死锁发生时，这些线程处于WAITING状态，使用
tryLock(long timeout, TimeUnit unit)方法则死锁线程状态为TIMED_WAITING。
	死锁发生的条件：
		一、多个线程访问互斥资源；
		二、资源不能被抢夺，只能由持有者主动释放；
		三、线程持有某个资源时继续申请其他资源；
		四、多个线程持有资源和申请其他资源形成循环等待。
	这些条件是形成死锁的必要条件，但不是充分条件，即满足这些条件时不一定发生死锁，但是发生死锁时，一定存在这四种情形。
	死锁的代码特征：
	内部锁形式：
		synchronized (objA){
			//...
			synchronized (objB){
				...
			}
			//...
		}
	显示锁形式：
		lockA.lock();
		try{
			//...
			lockB.lock();
			try{
				//...
			}finally{
				lockB.unlock();
			}
		}finally{
			lockA.unlock();
		}
	规避死锁的思路：消除产生死锁的四个条件中的任意一个条件就可以规避死锁。
	规避死锁的常用方法：
	a) 粗锁法：使用一个粗粒度的锁代替多个细粒度的锁。粗锁法消除了产生死锁的第三个条件：线程持有某个资源时继续申请其他资源
		使用粗锁的哲学家类，每次只能有一个哲学家吃饭：
		class MonopolizedPhilosopher{
			private Chopstick left;
			private Chopstick right;
			private static final Object lockObj = new Object();

			public Philosopher(Chopstick l,Chopstick r){
				this.left = l;
				this.right = r;
			}

			public void think(){
				//System.out.println(Thread.currentThread().getName()+" : thinking....");
			}
			
			public void eat(){
				synchronized (lockObj){
					left.pickUp();
					right.pickUp();
					//System.out.println(Thread.currentThread().getName()+" : eating....");
					right.putDown();
					left.putDown();
				}
			}
		}
		从这个例子就可以看出，5个哲学家有5只筷子，理论上可以支持2个人同时吃饭，但是使用粗锁就导致每次只能一个人吃饭，可见粗锁会带来资源的浪费。
	b) 锁排序法：每个线程都使用全局统一的顺序去申请锁。
		在哲学家就餐问题中，如果对每根筷子编号排序，并且让每个哲学家在申请筷子时按照编号从小到大的顺序申请，就可以避免死锁条件的第四条：循环等待。
		下面使用System.identityHashCode(obj);方法获取对象的身份标识，然后设置筷子时，让left总是小于right：
		class FixedPhilosopher{
			private Chopstick one;
			private Chopstick theOther;
			private static final Object lockObj = new Object();

			public FixedPhilosopher(Chopstick l,Chopstick r){
				int lh = System.identityHashCode(l);
				int rh = System.identityHashCode(r);
				if(lh<rh){
					this.one = l;
					this.theOther = r;
				}
				else if(lh>rh){
					this.one = r;
					this.theOther = l;
				}
				else {
					this.one = null;
					this.theOther = null;
				}
			}
			public void eat(){
				if(one!=null){
					synchronized (one){
						one.pickUp();
						synchronized (theOther){
							theOther.pickUp();
							//System.out.println(Thread.currentThread().getName()+" : eating....");
							theOther.putDown();
						}
						one.putDown();
					}
				}
				else {
					synchronized (lockObj){
						one.pickUp();
						theOther.pickUp();
						//System.out.println(Thread.currentThread().getName()+" : eating....");
						theOther.putDown();
						one.putDown();
					}
				}
			}
			public void think(){
				//System.out.println(Thread.currentThread().getName()+" : thinking....");
			}
		}
	c) 使用ReentrantLock.tryLock(long timeout, TimeUnit unit)方法设置等待超时时间，这样可以避免一个线程无限制地等待其他线程占用的资源。
		class NewPhilosopher{
			private Chopstick left;
			private Chopstick right;
			private static final ConcurrentHashMap<Chopstick, ReentrantLock> LOCK_MAP;
			static {
				LOCK_MAP = new ConcurrentHashMap<>();
			}
			public NewPhilosopher(Chopstick left,Chopstick right){
				this.left = left;
				this.right = right;
				LOCK_MAP.putIfAbsent(left,new ReentrantLock());
				LOCK_MAP.putIfAbsent(right,new ReentrantLock());
			}

			public void eat(){
				final ReentrantLock leftLock = LOCK_MAP.get(left);
				final ReentrantLock rightLock = LOCK_MAP.get(right);
				try {
					boolean accessFlag = leftLock.tryLock(20, TimeUnit.SECONDS);
					if(!accessFlag){
						System.err.println("timeout for wait eating!");
						return;
					}
					left.pickUp();
					accessFlag = rightLock.tryLock(20, TimeUnit.SECONDS);
					if(!accessFlag){
						System.err.println("timeout for wait eating!");
						return;
					}
					right.pickUp();
					//....
				} catch (InterruptedException e) {
					e.printStackTrace();
				} finally {
					if(rightLock.isHeldByCurrentThread()){
						right.putDown();
						rightLock.unlock();
					}
					if(leftLock.isHeldByCurrentThread()){
						left.putDown();
						leftLock.unlock();
					}
				}
			}
		}
	导致死锁的另外一种形式：在持有一个锁的情况下调用一个外部方法(其他对象的方法)，而该外部方法也会申请锁，这时可能出现以下情景：
		class ClassA{
			private ClassB obj;
			public synchronized void method1(){
				//...
				obj.method3();
			}
			public synchronized void method2(){
				//...
			}
		}
		class ClassB{
			private ClassA obj;
			public synchronized void method3(){
				//...
			}
			public synchronized void method4(){
				//...
				obj.method2();
			}
		}
	当一个线程在执行ClassA实例的method1时，另一个线程正在执行ClassB实例的method4，如此就会导致死锁。由于很难控制外部调用是否使用同步，这种死锁需要特别关注。
对这类死锁问题的一种解决方案是开放调用：一个方法在调用外部方法时（包括其他类的方法和当前类的可覆写方法），不持有任何锁。
	当然如果不使用锁，自然就不会有死锁问题，在合适的场景中可以考虑使用一些设计上的方法替换锁，如无状态对象、线程特有对象、不可变对象等。
	死锁检测和恢复：死锁检测可以使用ThreadMXBean.findDeadlockedThreads，恢复死锁中的线程的思路是发送中断指示，这就要求死锁中的线程必须要能响应中断，对于
显示锁，需要使用lockInterruptibly方法。恢复死锁的线程实际用途不大，如果程序设计不当，导致死锁发生，那么意味着死锁不是只发生一次，即使从死锁恢复了，执行一段
时间后，程序还是会继续陷入死锁。
		public class DeadLockDetector extends Thread{
			static final ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
			private final long timeInterval;

			public DeadLockDetector(long timeInterval){
				setName("DeadLockDetector");
				setDaemon(true);
				this.timeInterval = timeInterval;
			}
			public DeadLockDetector(){
				this(2000);
			}

			public static ThreadInfo[] findDeadLockThread(){
				long [] ids = threadMxBean.findDeadlockedThreads();
				return null==ids ? new ThreadInfo[0] : threadMxBean.getThreadInfo(ids);
			}

			public static Thread findThreadById(long threadId){
				for (Thread t : Thread.getAllStackTraces().keySet()){
					if(t.getId()==threadId){
						return t;
					}
				}
				return null;
			}

			public static boolean interruptThread(long threadId){
				Thread thread = findThreadById(threadId);
				if(thread!=null){
					thread.interrupt();
					return true;
				}
				return false;
			}

			public void run(){
				ThreadInfo [] threadInfos;
				int i=0;
				while (true){
					threadInfos = findDeadLockThread();
					if(threadInfos.length>0){
						interruptThread(threadInfos[i++ % threadInfos.length].getThreadId());
						continue;
					}
					i=0;
					try {
						Thread.sleep(timeInterval);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}
	可以从死锁中恢复的哲学家就餐方法：
		public void eat(){
			try {
				if(pickUpChopstick(left) && pickUpChopstick(right)){
					//....
					left.putDown();
					right.putDown();
				}
			} finally {
				if(LOCK_MAP.get(right).isHeldByCurrentThread()){
					LOCK_MAP.get(right).unlock();
				}
				if(LOCK_MAP.get(left).isHeldByCurrentThread()){
					LOCK_MAP.get(left).unlock();
				}
			}
		}
		private boolean pickUpChopstick(Chopstick chopstick){
			final ReentrantLock lock = LOCK_MAP.get(chopstick);
			try {
				lock.lockInterruptibly();
			} catch (InterruptedException e){
				if(LOCK_MAP.get(right).isHeldByCurrentThread()){
					LOCK_MAP.get(right).unlock();
				}
				if(LOCK_MAP.get(left).isHeldByCurrentThread()){
					LOCK_MAP.get(left).unlock();
				}
				return false;
			}
			chopstick.pickUp();
			return true;
		}
	锁死：一个线程一直等待被唤醒，但是由于某些原因，此线程一直没有被唤醒。锁死通常只是一个或少量相对独立线程的活性问题，而死锁则是一组关联线程的活性故障。
	导致锁死的原因主要包括通知信号丢失和嵌套监视器，如果不使用状态量来控制wait等方法，则可能出现notify()[同时修改相关状态量]在wait()调用前执行，导致notify
失效。嵌套监视器的典型形式：
		synchronized(monitorX){
			synchronized(monitorY){
				which(!status){
					monitorY.wait();
				}
			}
		}
		//唤醒
		synchronized(monitorX){
			synchronized(monitorY){
				status = true;
				monitorY.notify();
			}
		}
	线程饥饿与活锁：线程饥饿是指一个线程无法获得其需要的资源，导致线程计算任务无法进行下去，线程饥饿不一定是BLOCKED或WAITING状态，比如在使用非公平调度的资源
争用环境中，某些线程可能一直处于RUNNABLE状态（线程一直在申请资源）。饥饿线程一直处于RUNNABLE状态，通常就称其为活锁。
	BLOCKED状态通常由线程申请内部锁（synchronized实现）阻塞时进入，属于线程被动进入暂停状态，而WAITING通常是线程调用Object.wait方法、申请显示锁失败等主动
进入暂停状态。
	WAITING和BLOCKED状态本质上是一样的，都是线程被暂停，但是jvm出于管理的需要在虚拟机层面做了这种区分，这样做一个典型的好处是，两种原因的线程放在两个队列，
如果别的线程运行出了synchronized这段代码，虚拟机只需要去blocked队列唤醒某个线程，如果某个线程调用了notify()，虚拟机则去waitting队列唤醒一个线程。

	第八章 线程管理
	线程组：ThreadGroup，表示一组相似或相关的线程，可以使用Thread的构造函数参数指定创建线程的线程组，不指定时默认线程组就是父线程所在的线程组，通过
threadA.getThreadGroup方法可以得到线程所在线程组。线程组是一个过时的概念，现在一般都不再使用。
	非检查异常的处理：线程运行时（run方法或run调用链中的方法）抛出运行时异常，线程会提前终止（退出run方法），jdk1.5开始在Thread中添加了一个接口：UncaughtExceptionHandler，
这个接口提供一个方法：void uncaughtException(Thread t, Throwable e)，把这个接口的实例注册到线程对象上，这个方法就会在线程终止前被产生异常的线程调用。在这个方法里
可以做一些工作来对异常做一些处理，例如记录日志，甚至创建一个新的线程替代原线程继续完成工作。
	下面是一个实例：
		public class ThreadExceptionHandleDemo {
			volatile boolean inited = false;
			static AtomicInteger threadIndex = new AtomicInteger(0);
			final BlockingQueue<String> channel = new ArrayBlockingQueue<>(100);

			public static void main(String[] args) {
				ThreadExceptionHandleDemo demo = new ThreadExceptionHandleDemo();
				demo.init();
				for(int i=0;i<100;i++){
					demo.sendMsg("msg"+i);
				}
				try {
					Thread.sleep(3000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.exit(0);
			}

			private void sendMsg(String msg){
				channel.add(msg);
			}

			private synchronized void init(){
				if(inited){
					return;
				}
				CustomerThread customerThread = new CustomerThread();
				customerThread.setName("customer-"+threadIndex.getAndAdd(1));
				customerThread.setUncaughtExceptionHandler(new CustomerThreadExceptionHandler());
				customerThread.start();
				inited = true;
			}

			private class CustomerThread extends Thread{
				@Override
				public void run(){
					String msg=null;
					for (;;){
						try {
							msg = channel.take();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						process(msg);
					}
				}

				private void process(String msg) {
					if((int)(Math.random()*100)<10){
						throw new RuntimeException("random exception");
					}
					System.out.println(msg);
					try {
						Thread.sleep(20);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}

			private class CustomerThreadExceptionHandler implements Thread.UncaughtExceptionHandler{
				@Override
				public void uncaughtException(Thread t, Throwable e) {
					String tname = t.getName();
					System.err.println(tname+" terminated : "+e);
					inited = false;
					init();
				}
			}
		}
	线程组(ThreadGroup)实现了UncaughtExceptionHandler接口，它的实现逻辑是优先使用父线程组的uncaughtException处理异常，如果没有父线程组，就使用全局的默认线程异常处理器
处理，全局线程异常处理器可以通过Thread.setDefaultUncaughtExceptionHandler()设置。
	线程抛出的运行时异常优先使用线程设置的线程异常处理器处理，如果线程没有设置异常处理器，就使用线程所在线程组的线程异常处理器处理，通常都不会去创建自己的线程组对象，所以
实际上会使用全局线程异常处理器处理。
	线程工厂：ThreadFactory，这是jdk1.5开始提供的一个接口，提供一个方法 Thread newThread(Runnable r),通过线程工厂创建线程对象，可以封装创建线程、配置线程的逻辑。
		class MyThreadFactory implements ThreadFactory{
			AtomicInteger threadIndex = new AtomicInteger(0);
			@Override
			public Thread newThread(Runnable r) {
				Thread thread = new Thread(r);
				thread.setDaemon(false);
				thread.setPriority(4);
				thread.setUncaughtExceptionHandler(new MyThreadExceptionHandler());
				thread.setName("mythread-"+threadIndex.getAndAdd(1));

				return thread;
			}
		}
		class MyThreadExceptionHandler implements Thread.UncaughtExceptionHandler{
			@Override
			public void uncaughtException(Thread t, Throwable e) {
				String tname = t.getName();
				System.err.println(tname+" terminated : "+e);
			}
		}
	线程的暂挂和恢复：Thread的实例方法suspend和resume方法早已废弃，现在实现线程的暂挂和恢复实际上是通过应用程序设计实现的，典型的做法是使用一个状态量，在执行那些耗时操作
（或其他任何有需要的操作）前先检查这个状态量，如果状态不满足条件就使用wait或Condition的await实现暂停，当需要时通过修改状态量和调用notify等唤醒线程实现恢复。
	下面的例子中把线程要执行的任务分为两个子任务，每个子任务使用可控制的工具类执行，这个工具类执行任务时会先检查一个状态量，这个工具类还提供一个暂停和一个恢复线程的方法。
		public class ThreadPauseDemo{
			public static void main(String[] args) throws InterruptedException {
				test01();
			}

			private static void test01() throws InterruptedException {
				Runnable task1 = createTask("task1");
				Runnable task2 = createTask("task2");

				ThreadPauseTool threadPauseTool = new ThreadPauseTool();
				new Thread(()->{
					try {
						threadPauseTool.doAction(task1);
						threadPauseTool.doAction(task2);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}).start();
				Thread.sleep(100);
				threadPauseTool.suspend();
				System.out.println("waiting........");
				threadPauseTool.resume();
			}

			private static Runnable createTask(String taskName){
				Runnable task = new Runnable() {
					@Override
					public void run() {
						System.out.println(taskName+" start");
						try {
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println(taskName+" end");
					}
					@Override
					public String toString(){
						return taskName;
					}
				};
				return task;
			}
		}

		class ThreadPauseTool extends ReentrantLock {
			private boolean status = true;
			private Condition condition = newCondition();
			public void suspend(){
				status = false;
			}

			public void resume(){
				lock();
				try {
					status = true;
					condition.signalAll();
				} finally {
					unlock();
				}
			}

			public void doAction(Runnable task) throws InterruptedException {
				lock();
				try {
					while (!status){
						System.out.println("task paused...");
						condition.await();
					}
					task.run();
				} finally {
					unlock();
				}
			}
		}
	
	多线程带来的额外开销：线程对象相比普通对象，增加了栈空间的开销，线程的启动、调度和销毁都需要占用额外的CPU时间（上下文切换）。
	线程池是一个对象，其内部会预先创建一批工作者线程，使用时，客户端代码将需要执行的任务提交给线程池，线程池可能将这些提交的任务缓存起来，然后由工作者线程从缓存中取出任务
执行。所以线程池可以看成是基于生产者-消费者模式的一种服务，客户端代码生产任务传递给线程池消费。
	java.util.concurrent.ThreadPoolExecutor是一个线程池实现，它提供三个submit方法给客户端代码调用以提交任务：
		public Future<?> submit(Runnable task);
		public <T> Future<T> submit(Runnable task, T result)
		public <T> Future<T> submit(Callable<T> task)
	其构造方法也有四个版本，参数最多的一个如下：
		public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
	在其他几个构造方法中，threadFactory和handler是可选的。
	构造方法参数介绍：
		corePoolSize	核心线程数量（表示"合适"的线程数量）
		maximumPoolSize 最多线程数量
		keepAliveTime	超出corePoolSize的线程的空闲时间
		unit			keepAliveTime的单位
		workQueue		缓存任务的队列
		threadFactory	生产线程对象的工厂
		handler			缓存队列已装满，并且线程数量也达到了maximumPoolSize后新提交的任务被拒绝后的处理器
	客户端代码提交任务给线程池，线程池内部的工作过程：初始状态下，每提交一个任务，线程池就创建一个线程来处理该任务，当任务数量超过corePoolSize后，如果所有工作者线程仍在
执行，新提交的任务就被存入缓存队列(使用offer存入，不会阻塞)，当队列被填满后，继续提交就导致创建新的工作者线程来处理这些新提交任务，当工作者线程数量达到maximumPoolSize，
继续提交的任务如果不能存入缓存队列，就会被拒绝，这时handler将会处理新提交的任务(由客户端线程执行)。
	ThreadPoolExecutor的prestartAllCoreThreadsf方法可以在提交任务前就创建出所有的核心工作者线程，即corePoolSize个工作者线程。
	ThreadPoolExecutor提供一个shutdown方法和一个shutdownNow方法，shutdown方法执行后，线程池内的线程不会马上终止，而是会继续执行已提交的任务，如果再提交任务给线程池，
这些新提交的任务就会像线程池已满时那样被拒绝。shutdownNow方法执行时，正在执行的任务会被停止，已提交的任务也不会被执行（将被返回给调用者），这里正在执行的任务必须要能响应
中断才能被停止，如果不响应中断则不会被停止。
		private static void test01(){
			ThreadPoolExecutor executor = new ThreadPoolExecutor(4,8,10, TimeUnit.SECONDS,
					new ArrayBlockingQueue<>(10),
					new RejectedExecutionHandler(){
						@Override
						public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
							System.out.println(Thread.currentThread().getName()+" : "+r);
						}
					});
			//executor.prestartAllCoreThreads();
			System.out.println("initial thread count : "+executor.getPoolSize());
			for (int i=0;i<19;i++){
				final int j = i;
				executor.submit(()->{
					System.out.println("hello "+j);
					try {
						Thread.sleep(j*4);
					} catch (InterruptedException e){
						e.printStackTrace();
					}
				});
				System.out.println("=================");
				System.out.println("thread count : "+executor.getPoolSize());
				System.out.println("active count : "+executor.getActiveCount());
				System.out.println("task count : "+executor.getTaskCount());
				System.out.println("completed task count : "+executor.getCompletedTaskCount());
				System.out.println("queue size : "+executor.getQueue().size());
				System.out.println("=================");
			}
			//executor.shutdown();
			try {
				Thread.sleep(6000);
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			System.out.println("final thread count : "+executor.getPoolSize());
			System.out.println("largest pool size : "+executor.getLargestPoolSize());
			executor.shutdownNow();
		}
	Callable是一个和Runnable功能类似的接口，也是任务的抽象，它提供一个call方法，和Runnable的run方法不同的是Callable的实例有返回值，且可以抛出异常：
		public String call() throws Exception;
	Executors.callable可以把一个Runnable实例转换为一个Callable实例：
		public static <T> Callable<T> callable(Runnable task, T result)
	ThreadPoolExecutor的几个submit方法返回值都是一个Future对象，这个对象可以看成是提交任务执行过程的一个句柄，通过这个对象可以获取任务执行结果（返回值）、取消任务等。
		private static void test02(){
			ThreadPoolExecutor executor = new ThreadPoolExecutor(4,8,5, TimeUnit.SECONDS,
					new ArrayBlockingQueue<>(10));
			Future<String> future = executor.submit(new Callable<String>() {
				@Override
				public String call() throws Exception {
					Thread.sleep(100);
					return "sucess";
				}
			});
			//future = executor.submit(Executors.callable(()->{},"success"));
			//future.cancel(true);
			try {
				if(!future.isCancelled()){
					//future.get()这个方法会阻塞执行线程
					//String result = future.get();
					String result = future.get(20, TimeUnit.MILLISECONDS);
					System.out.println(result);
				}
			} catch (InterruptedException | ExecutionException | TimeoutException e) {
				if(e instanceof TimeoutException){
					future.cancel(true);
					System.out.println("task canceled");
				}
				else {
					e.printStackTrace();
				}
			}
			executor.shutdown();
		}
	future.get()这个方法会阻塞执行线程，所以调用这个方法应该尽可能晚一点，只在必须获得任务执行结果的时候才调用这个方法。这个方法还会抛出任务执行过程中抛出的异常
（ExecutionException）（任务执行时抛出的异常会先被捕获并保存在任务实例中）。
	future.cancel(true/false)表示取消任务执行，true表示如果任务在执行中，就发送中断指示给执行线程，如果任务不响应中断，运行时则不能被取消。
	任务被取消后，再调用future.get()将抛出CancellationException异常。
	future.isDone()方法返回任务是否执行完毕，任务正常结束、任务被取消、任务执行过程中抛出异常，这个方法都返回true。
	future.get(20, TimeUnit.MILLISECONDS)这个方法在等待指定时间后任务仍没有执行结束就抛出一个运行时异常：TimeoutException。
	ThreadPoolExecutor提供一组监控线程池的方法：
		getPoolSize()			获取当前线程池大小（存活的线程数量）
		getQueue()				获取缓存队列，返回一个BlockingQueue实例，这个这个实例可以查看其使用情况
		getLargestPoolSize()	获取曾经达到过的最大线程数量
		getTaskCount()			获取已提交到线程池的任务数量(近似值)
		getCompletedTaskCount()	获取已完成的任务数量(近似值)
		getActiveCount()		获取工作中的线程数(近似值)
	后面三个方法获取的都只是近似值，所以不是很靠谱。
	ThreadPoolExecutor还提供两个hook方法：beforeExecute和afterExecute，beforeExecute在任务执行前执行，而afterExecute在任务执行后执行，这里需要注意，任务执行过程中
抛出的异常不会被传递给afterExecute，而是封装在了Runnable实例当中。
		private static void test03(){
			ThreadPoolExecutor executor = new ThreadPoolExecutor(4,8,5, TimeUnit.SECONDS,
					new ArrayBlockingQueue<>(10)){
				@Override
				protected void beforeExecute(Thread t, Runnable r) {
					System.out.println(t.getName()+" will execute "+r);
				}
				@Override
				protected void afterExecute(Runnable r, Throwable t) {
					System.out.println(r+" execute finished"+(t==null ? "" : ", exception happended : "+t.getMessage()));
				}
			};
			 Future future = executor.submit(new Runnable() {
				@Override
				public void run()  {
					int i = 20/0;
					System.out.println(Thread.currentThread().getName()+" doing");
				}
			});
			try {
				future.get();
			} catch (InterruptedException | ExecutionException e) {
				e.printStackTrace();
			}
			executor.shutdown();
		}
	线程池也需要注意避免线程死锁，一般来说，适合提交给同一线程池的任务应该是相对独立的任务，如果是一组彼此依赖的任务，可以提交给多个线程池执行。
	任务执行过程中的异常处理方案：
		一、直接在任务的run方法中捕获处理；
		二、捕获submit方法返回的future的get方法抛出的异常；
		三、使用自定义线程工厂，为其创建的线程添加线程异常处理器；
		四、设置默认线程异常处理器。
	覆写ThreadPoolExecutor的afterExecute方法不能拿到任务执行过程中抛出的异常。


	