                                                    java多线程编程
                                        (参考书籍：java多线程编程实战指南-核心篇)
    第一章 线程和多线程编程简介
    什么是进程？进程是程序的运行实例，运行一个java程序就是启动一个java虚拟机进程。进程是操作系统分配资源（内存空间、文件句柄等）的基本
单元。
    linux查看运行中的进程：
        ps -ef | grep "pname" | grep -v "grep"
    windows下查看运行中的进程：
        tasklist | findstr pid/"pname"
    什么是线程？线程是进程中可独立执行的最小单元，一个进程可以包含多个线程。一个进程中的所有线程共享操作系统分配给该进程的资源。线程用
于完成实际的计算工作，通常称为线程的任务。
    什么是多线程编程？多线程编程是一种以线程为基本抽象单元的编程模式，java语言中多线程编程和面向对象编程是相容的。
    多线程编程不仅仅只是使用多个线程完成计算，还需要考虑多种条件和环境，如果设计不合理，多线程不但不能提高程序运行的效率，反而会降低程
序的运行效率，甚至影响程序的正确运行。
    多线程编程的优点：正确且合理的多线程设计可以充分利用现代多核处理器的计算能力，提高程序的效率和使用体验，比如web服务器为每个请求提供
一个线程，可以实现请求不需要等待其他请求的执行；某些GUI程序使用不同的线程处理界面展示和内部计算，可以保证启动时不需要等待内部计算完成才
展示程序界面。
    java提供一个类：java.lang.Thread作为java平台线程的实现。Thread类和其子类的实例对象就是一个线程。
    Thread类提供一个实例方法：run，这个方法是线程任务处理逻辑的入口方法，所以线程任务处理逻辑可以直接在这个方法中实现，也可以在这个方
法中调用。线程对象的run方法由JVM在运行线程时直接调用。
    运行一个线程就是让JVM去执行线程对象的run方法，这需要启动线程。Thread类提供一个实例方法start，调用线程对象的start方法就可以启动这
个线程。
    使用start方法启动一个线程只是通知JVM运行线程实例，但是这个线程的实际运行时间由线程调度器（操作系统提供）决定，所以start方法调用后
并不意味着这个线程已经开始运行。
    Thread类提供两个构造方法：Thread()和Thread(Runnale task)；因此可以使用两种方式来创建线程。一种是实现一个继承Thread的类，在该类
中覆写Thread类的run方法，在覆写的run方法中实现或调用任务处理逻辑。第二种是实现一个实现java.lang.Runnale接口的类，并在实现的run方法中
实现或调用任务处理逻辑，使用第二个构造函数来创建线程对象。
        public class WelcomApp {
            public static void main(String[] args) {
                Thread welcomeThread = new WelcomThread();
                welcomeThread.start();

                Thread welcomeThread2 = new Thread(new WelcomeTask());
                welcomeThread2.start();

                System.out.printf("1.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }

        class WelcomThread extends Thread{
            @Override
            public void run(){
                System.out.printf("2.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }

        class WelcomeTask implements Runnable{
            @Override
            public void run() {
                System.out.printf("3.Welcome! I'm %s.%n",Thread.currentThread().getName());
            }
        }
    第一种创建线程的方式是使用继承模型，第二种是应用组合模式，一般来说，组合模式下，类之间的耦合度更低，所以通常选用这种模式创建线程。
    run方法执行结束或run方法执行过程中抛出异常，线程的运行就结束了，线程占用的系统资源就会被GC。
    线程不能重复运行，也就是说线程的start方法只能调用一次，重复调用将会抛出异常：IllegalThreadStateException
    java创建一个Thread对象实例和普通java对象的不同：JVM会为线程对象分配一块称为调用栈的内存空间（用于跟踪java方法调用关系），此外，
可能还会关联线程对象和内核线程（由操作系统支持）。所以创建一个线程对象比普通对象成本更高。
    java代码总是由某个线程来执行的，该线程称为这段代码的执行线程。程序运行时，同一段代码可以被多个线程执行，在这段代码中可以使用
Thread.currentThread()获取正在执行这段代码的线程。
    Thread类是Runnable接口的一个实现类，它的run方法如下：
        public void run(){
            if(target != null){
                target.run();
            }
        }
    可见，如果直接new Thread()，这个线程什么也不会做，所以继承Thread类的子类必须覆写run方法。上面的target是一个Runnable的实例，通过
new Thread(Runnable task)传入的task将被设置为创建线程对象的target。
    如果使用一个Runnable实例对象去创建多个线程对象，而这个Runnable实例的run方法中使用了自己的对象变量，就有可能出现竞态和线程安全问题。
    线程对象的属性：编号（ID）、名称（Name）、线程类型（Daemon）、优先级（Priority）.
    线程编号是一个long型变量，用于标识不同的线程，不可修改，这个编号在线程运行结束后可能被分配给其他新的线程。
    线程名称是一个String类型的变量，面向人标识线程，可修改，默认格式：Thread-线程编号，java允许把不同的线程名称设置为相同。
    线程类型是一个boolean类型变量，值为true表示线程为守护线程，值为false表示线程为用户线程，可以修改，默认和创建当前线程的父线程的类型
相同，如果要修改，需要在启动线程前进行。守护线程不会阻止JVM的正常停止，而用户线程则会，因此重要任务最好不要设置线程类型为守护线程。
    线程优先级是一个int类型的变量，它是给线程调度器的提示，用于表示希望优先运行哪个线程。java定义了1~10的10个优先级，默认为5，子线程的
优先级默认和父线程相同。一般不需要修改这个属性。
    Thread类的常用方法：
        static Thread currentThread();
        void run();
        void start();
        void join();                        在A线程中调用B线程的join方法后，A线程将会暂停执行，直到B线程执行完成后A线程继续执行。
        static void yield();                在A线程中调用Thread.yield()后，如果进程存在线程，A线程将被让出处理器使用，等待线程
                                            调度器再次分配处理器时间，否则线程A将继续执行。
        static void sleep(long millis);     在A线程中调用Thread.sleep(1000)后，A线程将休眠1s。
    使用Thread.sleep(n)实现一个定时器：
        public class SimpleTimer {
            public static void main(String[] args) throws InterruptedException {
                for(int i=0; i<60; i++){
                    System.out.println("remaining "+(60-i)+" seconds");
                    Thread.sleep(1000);
                }
            }
        }
    JVM规范的调整使得Thread的一些早期提供的方法不再建议使用（这些方法在早期的JVM上也可能出现问题）：stop、suspend、resume
    这些方法提供的功能：停止一个线程、暂停线程执行、恢复线程执行，现在通常使用一些其他方式实现（Thread类没有提供新的替代方法）。
    启动一个java虚拟机进程时会创建一个名称为main的线程（编号为1），这个线程负责执行java程序的入口方法（main方法）。JVM会创建一个垃圾
回收线程用来进行GC。JVM还会创建一个线程执行JIT编译器的编译任务。
    java的线程具有逻辑上的层级结构，main线程通常是最上层的线程，可以创建子线程，这些子线程也可以创建自己的子线程。子线程的类型和优先级
默认和父线程一致。除了子线程由父线程创建外，父线程和子线程的生命周期没有特别的关系，父线程执行结束不影响子线程的执行，子线程的执行也不影
响父线程（抛出异常除外）。有些父线程创建的用于执行特定任务的线程也被称为工作者线程。
    线程的生命周期状态：使用Thread.getState()可以获取线程状态，返回值类型是枚举类型Thread.State。
    线程对象被创建后，在启动（调用start方法）之前处于状态：NEW，一个线程只有一次处于这种状态。
    线程启动后进入RUNNABLE状态，这个状态具有两个子状态：READY和RUNNING，线程调度器可以对线程调度时线程处于READY状态（称为活跃线程），
线程执行时处于RUNNING状态。线程执行时调用Thread.yield()可能会使当前线程状态从RUNNING转为READY。
    当执行中的线程发起阻塞IO请求或请求一个锁住的资源时，线程状态转为BLOCKED，这时该线程不占用处理器，等待请求返回后，线程转回RUNNABLE
状态（不一定直接转回RUNNING）。
    线程执行过程中调用了join等方法时，线程状态转为WAITING，处理器被让给其他线程，直到等待的线程执行完成后，线程状态才转回RUNNABLE.
    线程执行过程中调用Thread.sleep(n)等方法后，线程状态转为TIMED_WAITING，等待指定时间之后线程状态转回RUNNABLE.
    线程执行结束后状态转为TERMINATED，包括正常结束和抛出异常。
    使用线程转储监控线程：一个程序的线程转储包含了在获取这个线程转储的那一刻该程序的线程信息，包括程序中具有哪些线程以及各个线程的属性、
生命周期状态、调用栈、锁的信息。可以使用如下方法获取线程转储：
    获取线程转储的工具：
        (oracle/sun)jdk1.6开始提供jstack工具，使用：jstack -l pid （平台无关）
        oracle jdk提供jvisualvm工具，位于jdk目录/bin/jvisualvm（GUI工具，平台无关）
        oracle jdk1.8开始提供jmc工具，位于jdk目录/bin/jmc（GUI工具，平台无关）
        linux系统命令：kill -3 pid 或在启动java进程的shell中：ctrl+\
    多线程编程的优势：
        提高系统的吞吐率（单位时间内服务器处理的请求数）；
        提高响应性（返回响应给请求者的时间不受其他慢请求影响）；
        充分利用处理器多核资源；
        最小化使用系统资源（多个线程共享进程的内存空间）；
        简化程序复杂性。
    多线程编程的问题和风险：
        线程共享数据带来的线程安全问题；
        不合理的设计带来的线程饥饿、死锁等线程活性问题；
        上下文切换（线程间切换）带来的性能消耗；
        线程意外终止可能引起JVM进程终止（多线程比单线程的发生概率更大）。
        
    第二章 多线程编程基本概念
    串行(Sequential)：多个任务只能依次进行，后面的任务只能等待前面的任务完成后才能被执行。
    并发(Concurrent)：多个任务可以在一段时间内同时执行，后面的任务不需要等待前面的任务完全结束就可以执行。
    并行(Parallel)：多个任务在任意时间点都可以同时执行，任务间没有顺序关系。
    并行是并发的极限情形，单核机器上，可以通过CPU时间分片实现多个线程并发执行，而并行则需要多个CPU核心执行不同的线程才能实现。
    多线程编程的本质就是将任务的处理方式由串行改为并发，即并发化，以提高程序的性能。如果一个任务可以拆分为多个可以并发执行的子任务，那么
就称这个任务为可并发化的。当然，不是所有的任务都是可并发化的。
    竞态：如果一个多线程程序的执行结果的正确性和时间有关，即结果可能正确也可能错误，这种情况就称为竞态。具体来说，竞态表示计算的正确性依
赖于相对时间顺序或线程的交错。竞态通常伴随着读取脏数据的问题，读取脏数据通常会导致丢失更新问题。
    状态变量：即类的实例变量、静态变量。
    共享变量：可以被多个线程共同访问的变量（即该变量在被某个线程访问期间，其他线程也可以访问它）。状态变量属于共享变量。
    竞态的模式：read-modify-write(读-改-写)、check-then-act(检测-使用)，这两种模式都可能读取到脏数据。局部变量不属于共享变量，所以不会
出现竞态问题。
    synchronized关键字修饰方法可以使该方法在被一个线程执行时，不能再被其他线程执行。
    线程安全性：如果一个类在单线程环境下可以正确执行，不做改变地迁移到多线程环境也能正确执行，该类就是线程安全的，否则就是非线程安全的。
    ArrayList、HashMap等类是非线程安全的，如果用在多线程环境中，就有可能导致内存泄漏等问题。
    线程安全性问题：将非线程安全的类用在多线程环境中即存在线程安全性问题，表现在原子性、可见性和有序性三个方面。
    原子性：多线程环境下，某个访问共享变量的操作，如果操作过程的中间效果对于其他线程都是不可见的，即其他线程不能访问该操作执行过程中部分修
改的共享变量，该操作就具有原子性，称为原子操作。原子操作之间不能交错。
    非线程安全的类没有实现其操作共享变量的操作（方法）的原子性。
    java中可以使用锁和CAS指令来实现操作的原子性，锁具有排他性，即在任意时刻只允许一个线程访问某个共享变量。CAS指令是依靠硬件实现的。
    java中，long、double以外其他类型变量的写操作都是原子操作，long和double型变量在32位机器上的写操作会分为两步，先写低32位，再写高32位，
所以不是原子操作。可以使用volatile关键字修改long、double型变量使其写操作具有原子性。
    可见性：一个线程对共享变量的更新的结果对于读取相应共享变量的其他线程是否可见。一个多线程程序存在可见性问题，即某些线程读取到了旧数据，
而这些旧数据导致计算出现错误。
    可见性问题出现的原因：
    在多核处理器中，每个核心都有其独自的寄存器、高速缓存、写缓存器和无效化队列，这些部件作为主内存的缓存，某个线程对共享变量的修改首先是
写在其执行核心的写缓存器中的，在其他处理核心上执行的线程不能访问到这个已修改的共享变量。
    如果要让当前线程可以访问其他核心执行的线程修改的共享变量，首先需要那个核心上的线程修改的共享变量（从写缓存器）同步到其高速缓存或主内
存中，这称为冲刷处理器缓存；必须将那个核心的缓存数据同步到当前线程所在核心的高速缓存中，这称为缓存同步。一个新线程处理器在读取某个共享变
量时，该共享变量已被其他线程核心更新，当前线程核心就需要从其他核心的处理器缓存同步该变量到自己的处理器缓存，这称为刷新处理器缓存。
    在单核处理器上，上下文切换会导致保存上个线程修改的共享变量的寄存器内容被保存，所以新线程无法访问上一个线程修改的共享变量。
    java中使用volatile关键字修饰一个变量后，JIT编译器将不会对访问该变量的访问操作进行可能导致可见性问题的优化，而且读取该变量时会进行刷
新处理器缓存，写该变量时会进行冲刷处理器缓存。
    在子线程启动之前，父线程对共享变量的更新对子线程总是可见的，某一线程对共享变量的修改在该线程终止后，对于调用该线程的join方法的线程（
等待该线程执行完再执行的线程）总是可见的。
    有序性：一个线程对内存的访问操作在其他线程看来是否和其源码中的顺序一致，如果不一致，则该多线程程序存在有序性问题。
    重排序是导致有序性问题的主要原因，指的是处理器执行的指令顺序和程序源码中的顺序不一致，或者是多线程程序中其他线程观测某个线程的内存操作
结果和其源码中预定的结果不一致。重排序可能是软件导致的，如静态编译导致的字节码指令重排序（javac编译器不会进行这种重排序）、JIT编译导致的
本地机器码指令重排序，也可能是硬件设计导致的，如处理器执行指令时重排序、处理器缓存系统写数据重排序。
    JIT编译重排序（指令重排序）的一个例子：
    创建对象时，通常的顺序应该是：①先分配内存，②初始化分配空间，③将分配的地址赋值给对象引用。
    但是JIT编译器可能生成如下顺序的本地机器码指令：①先分配内存，③将分配的地址赋值给对象引用，②初始化分配空间。
    这就可能导致创建对象的线程在还没有完成对象初始化时，其他线程就可以访问这个对象，造成线程安全性问题。
    处理器执行指令时重排序（乱序执行）：现代处理器为了提高效率，通常会动态调整指令执行顺序，例如选择先准备好操作数的指令执行，执行结果被保
存到重排序缓冲器中，这个缓冲器按照原来指令被读取的顺序提交执行结果到寄存器或主内存。还有一种“猜测执行”技术，即在执行条件判断指令前先执行条
件判断指令后的指令，并将执行结果保存到重排序缓冲器中，执行条件判断指令后再根据结果决定是否提交重排序缓冲器中的结果。
    处理器缓存系统重排序：这种重排序不是指令重排序，也不是指令执行重排序，而是指令执行结果提交乱序导致的其他线程观测当前线程执行类似发生了
重排序。例如线程X连续写两个变量A和B，线程Y观测变量B的结果输出变量A的值，如果线程X写变量B先提交，这里线程Y检测到可以访问变量A，但是此时变量
A的新值还没有提交，就会导致线程Y拿到脏数据。需要说明的是，不同的处理器在乱序提交上的设计上并不相同。
    貌似串行语义：尽管存在各种重排序，但是在单线程程序中，程序执行结果仍然和源码中约定的顺序相同，就好像没有发生重排序。
    在单核处理器上，只有静态编译重排序会产生有序性问题，其他类型的重排序都不会产生有序性问题，这是因为单核处理器在切换线程时会提交当前线程
执行的结果（提交到高速缓存，不同线程使用不同的高速缓存，所以仍然存在可见性问题）。
    在java中，volatile、synchronized关键字可以保证有序性，屏蔽了禁止重排序的具体细节做法。
    线程上下文切换：在多线程程序中，通常线程的数量要比处理器（核心）的数量多得多，所以必须采用时间分片的方法来实现多线程并发执行，当一个正
在执行的线程的时间片用完或者该线程主动暂停执行，又或者线程调度器提前暂停该线程执行，当线程暂停执行时，操作系统就会保存其暂停前的运行期数据，
主要是寄存器中的数据（通用寄存器和PC寄存器）被保存到内存中，当该线程下次执行时，操作系统就把保存的数据从内存恢复到寄存器中。
    对java程序来说，线程上下文切换就是一个线程在RUNNABLE状态和非RUNNABLE状态之间的一次切换。
    java多线程程序触发自发性上下文切换的方法：Thread.sleep方法、Object.wait方法、Thread.yield方法、Thread.join方法，LockSupport.park
方法等。线程执行阻塞式IO操作和等待锁也会触发自发性上下文切换。
    非自发性上下文切换一般是由于时间片用完导致的，也可能是线程调用器遇到了一个更高优先级的线程。在java程序中，JVM在GC时，通常需要停止用户线
程的执行。
    线程上下文切换的开销：主要包括处理器保存和重新加载线程运行期寄存器数据的时间开销、线程调度器选择新执行线程的开销、高速缓存重新加载的开销，
通常一次线程上下文切换的时间开销在us级。
    因为存在上下文切换的开销，所以可能出现多线程的效率反而比单线程更低。
    在linux下，perf命令可以统计java程序运行期间发生的线程上下文切换次数，windows下可以使用perfmon工具监控程序的线程上下文切换信息。
    线程活性故障：程序中的线程都处于非RUNNABLE状态或者线程处于RUNNABLE状态但是其任务无法完成。
    线程活性故障的几种类型：
    死锁：两个或多个线程都在等待对方持有的锁（资源），同时都不释放自己持有的锁（资源），导致线程处于RUNNABLE状态但是无法完成任务。
    锁死：一个线程一直等待被唤醒。
    活锁：线程处于RUNNABLE状态但是任务没有进展。
    饥饿：一个线程无法获得其等待的资源。
    高并发：一段时间内，处于运行状态的线程越多，并发程度就越高，即高并发。高并发会增加资源争用的概率，即多个线程都去请求一个排他性资源，如处理器
时间。
    资源调度通常会使用排队策略，即把申请某资源失败的线程加入一个队列，当该资源被释放后，就唤醒队列头部的线程使其获得资源。
    公平调度：先申请排他性资源的线程总是比后申请的线程先获得该资源的独占权，但是其吞吐率较低，因为公平调度通常需要更多的上下文切换。公平调度适合
用在线程持有资源时间较长或线程申请资源时间间隔较长或者要求各个线程公平获得资源使用权的场景下。
    非公平调度：允许后申请排他性资源的线程比先申请的线程先获得该资源的独占权，其吞吐率较高，因为非公平调度时有些线程不需要进行上下文切换，但是可能
导致饥饿问题。非公平调度是大多数场景下的默认选择，其吞吐率更高。
    
    第三章 java中的线程同步机制
    线程同步机制指的是用于协调线程间的数据访问和活动以保障线程安全和正确执行的机制。
    java平台提供的线程同步机制包括：锁、volatile关键字、final关键字、static关键字和一些相关的API，如Object.wait/Object.notify等。
    锁可以看成是线程共享数据的访问许可证，使用锁保护共享数据时，在任何线程访问共享数据前都需要先获取对应的锁，访问结束后应该释放持有的锁。
    临界区：在获得锁和释放锁之间线程执行的代码（指令）。临界区一次只能被一个线程执行，所以在临界区内访问共享数据就变成了串行访问，就可以避免线程安
全性问题。
    如果多个线程访问同一个锁保护的共享数据，就称这些线程同步在这个锁上，这些线程执行的临界区称为这个锁所引导的临界区。
    锁大多数都具有排他性，即一次只能被一个线程持有，如内部锁（synchronized实现），这些锁称为排它锁或互斥锁。
    java虚拟机提供两种锁实现，即内部锁和显式锁，内部锁是通过synchronized关键字实现的（java语法层面），显式锁是通过java.concurrent.locks.Lock接口
的实现类实现的。
    锁是通过排他性（互斥性）保障原子性的，其可见性保障是隐含的，即获得锁时隐含进行了刷新处理器缓存，释放锁隐含进行了冲刷处理器缓存，使用锁保护共享数据
也可以保障有序性，即使可能会有执行指令重排序，其执行结果对其他线程仍然是和代码约定顺序一致的。
    使用锁保证线程安全性，需要注意：线程访问共享数据时必须使用同一个锁，这里的访问包括仅进行读操作。
    可重入性：一个线程在已获得某个锁时，还能继续申请该锁。这样的锁称为可重入锁，否则称为非可重入锁。
    锁其实相当于一种排他性资源，所以申请锁也存在锁调度策略。
    一个锁保护的共享数据的数量大小称为锁的粒度，共享数据的数量大就称锁的粒度粗，否则称锁的粒度细。锁的粒度太粗会导致不必要的执行阻塞，粒度太细则会导致
调度开销增加。
    使用锁需要注意锁的释放，忘记释放锁将导致锁泄漏，即其他线程一直无法获取锁。
    锁这种同步机制本身是非常粗粒度的。
    在java中，任何一个对象都可以作为锁，当作为锁使用时，称为监视器或内部锁，将对象作为锁是通过synchronized关键字实现的。
    synchronized关键字修饰的方法称为同步方法，其修饰的代码块称为同步代码块，同步方法的方法体就是一个临界区，同步代码块内的代码也是一个临界区。同步静态
方法（即使用synchronized修饰的静态方法）默认使用静态方法所在类的class对象作为锁，同步实例方法默认使用实例方法所在对象作为锁，同步代码块需要指定一个锁
句柄，该句柄引用一个对象作为锁，锁句柄通常需要使用private final修饰以保障该句柄不会被修改（如果锁句柄被修改就会无法保障同步代码块的线程安全性，这样就会
会引发竞态），这些锁对象称为引导锁。
    javac编译器在编译同步方法和同步代码块时，会对临界区内抛出而程序没有处理的异常进行特殊处理，使得抛出异常不会妨碍内部锁的释放，所以内部锁不会导致锁泄漏。
    java虚拟机会为每个内部锁创建一个入口集（它的实现由虚拟机实现决定），这个入口集用于记录等待该锁的线程，当这个锁被释放后，虚拟机就从这些等待线程中选择
一个线程参与该锁的申请，选择等待线程的算法由虚拟机实现自己决定，而选择的线程不是直接获得该锁，因为内部锁的申请都是使用非公平调度，所以选中的等待线程可能
会重新回到入口集中。
    显式锁是在JDK1.5才引入的，一个显式锁是一个java.util.concurrent.locks.Lock接口的一个实例对象，设计显式锁不是要替换内部锁，而是作为内部锁的一种补充，
增加锁应用范围的灵活性。
    类java.util.concurrent.locks.ReentrantLock是Lock接口的默认实现，它是一个可重入锁。
    Lock接口中的lock方法用于申请锁，unlock方法用于释放锁。临界区代码放在lock方法和unlock方法之间。临界区代码通常使用try包裹，并将unluck方法放在try后面
的finally块中，这样就可以避免锁泄漏。
        public class SafeCircularSeqGenerator {
            private final Lock lock = new ReentrantLock();
            private short sequence = -1;
            public short nextSequence() {
                lock.lock();
                try {
                    if(sequence>=999) {
                        sequence = 0;
                    }
                    else {
                        sequence++;
                    }
                    return sequence;
                } finally {
                    lock.unlock();
                }
            }
        }
    ReentrantLock支持公平调度和非公平调度两种调度策略，这是显式锁和内部锁的区别之一。
        private final Lock lock = new ReentrantLock(true);
        //默认为非公平调度
    Lock接口的tryLock方法用于尝试申请一个锁，如果申请不成功就跳过临界区代码继续，这样就不需要暂停执行线程。tryLock方法另一个重载版本允许设置一个等待时间，
即在该时间值内申请，超出该时间后不再等待该锁。
        public short nextSequence() {
                if(lock.tryLock()) {
                    try {
                        if(sequence>=999) {
                            sequence = 0;
                        }
                        else {
                            sequence++;
                        }
                        return sequence;
                    } finally {
                        lock.unlock();
                    }
                }
                System.out.println(Thread.currentThread().getName()+" locked? "+((ReentrantLock)lock).isLocked());
                return -1;
            }
    ReentrantLock提供一个isLocked方法，可检查该锁是否被某个线程持有，提供一个getQueueLength方法，可获取等待该锁的线程的数量。
    在决定选用内部锁还是显式锁时，比较保守的做法是默认使用内部锁，仅在需要使用显式锁提供的新特性的地方使用显式锁。另一种做法是尽量选用显式锁，毕竟显式锁更加
灵活和可控。
    只读线程：对共享变量仅进行读取操作的同步线程。
    写线程：对共享变量进行更新的同步线程。
    读写锁：允许多个只读线程同时读取共享变量，但是一次只允许一个线程对共享变量更新，即有一个线程在更新共享变量时，其他线程都不能访问共享数据，这样的锁称为
读写锁。读写锁是一种改进型的排它锁，也称共享/排它锁。
    读写锁不是两个锁（对象），而是一个锁对象扮演两个角色，即读锁和写锁。只读线程在访问共享数据前申请读锁，写线程在访问共享数据前申请写锁。读锁是共享的，而
写锁是独占的。
    java.util.concurrent.locks.ReadWriteLock接口是读写锁的抽象，ReentrantReadWriteLock是其默认实现类，它也是一个可重入锁。
    ReadWriteLock接口中的方法readLock返回读锁，writeLock方法返回写锁。
        public class HostConfig {
            private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(false);
            Lock readLock = readWriteLock.readLock();
            Lock writeLock = readWriteLock.writeLock();

            private String ip = "192.168.1.1";
            
            private int port = 80;
            
            public String getHostConfig(){
                
                readLock.lock();
                String config = "ip: "+ip+"; port: "+port;
                readLock.unlock();
                return config;
            }
            
            public void setHostConfig(String ip,int port) {
                
                writeLock.lock();
                this.ip = ip;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                this.port = port;
                writeLock.unlock();
            }
        }
    public class HostTask implements Runnable{
        private HostConfig hostConfig = new HostConfig();
        
        @Override
        public void run() {
            long threadId = Thread.currentThread().getId();
            if(threadId%3==0) {
                hostConfig.setHostConfig("192.168.1.2", 81);
            }
            else if(threadId%4==0) {
                hostConfig.setHostConfig("192.168.1.3", 82);
            }
            else {
                String config = hostConfig.getHostConfig();
                System.out.println(threadId+": "+config);
            }
        }
    }
    读写锁适用场景：
        只读操作比写（更新）操作要频繁得多；
        读线程持有锁的时间比较长。
    ReentrantReadWriteLock支持锁的降级，即一个线程在持有写锁的情况下，可以继续获取相应的读锁，但是不支持锁的升级，即持有读锁期间不能获得写锁。
    java虚拟机使用内存屏障指令实现刷新处理器缓存和冲刷处理器缓存，这是java各种线程同步机制的底层实现机制。