												Spring核心技术
													第一章
	spring的诞生：替换重量级的EJB，spring提供了更加轻量级和简单的编程模型。增强了POJO的能力，使其能完成以前只有EJB的bean
才能完成的任务。
	spring简化开发的关键策略：
1、使用POJO作为bean，坚持最小侵入性原则（尽量不要求应用组件依赖spring的接口和组件）
2、通过依赖注入和面向接口编程实现松耦合
3、基于切面和惯例进行声明式编程
4、通过切面和模板减少样板式代码
	依赖注入（DI）：系统中负责协调各对象的第三方组件（IOC容器）创建各对象，并根据配置的规则设置对象间的依赖关系。
	装配方式：spring支持以多种方式定义各对象间的依赖关系，包括xml配置文件，java-config等。现在的spring通过应用上下文
(Application Context)读取装配配置，然后创建所有bean对象并组装对象。
	面向切面编程技术：分离软件系统中的关注点。业务组件不应该包含日志、事务等非核心逻辑，通常应用中这些非核心逻辑是
相同的，应该被单独分离出来，称为横切关注点。
	spring提供了一系列模板工具类，可以直接使用这些API来进行JDBC等操作，使用时只需要关注自己应用中的业务逻辑，而不必
关注那些样板式的代码。
	spring管理bean对象（创建、装配、配置等）的核心组件称为spring容器，spring容器可以分为两种类型：bean工厂(BeanFactory
接口定义)和应用上下文(ApplicationContext接口定义)。现在的spring基本上都是应用上下文作为容器。几种应用上下文：
		AnnotationConfigApplicationContext：从java配置类中加载配置信息以创建spring应用上下文
		AnnotationConfigWebApplicationContext：从java配置类中加载配置信息以创建spring web应用上下文
		ClassPathXmlApplicationContext：从类路径下的xml文件加载配置信息以创建spring应用上下文
		FileSystemXmlApplicationContext：从文件系统指定位置的xml文件加载配置信息以创建spring应用上下文
		XmlWebApplicationContext：从web应用下的xml文件加载配置信息以创建spring web应用上下文。
	bean的生命周期：
	实例化 --> 注入依赖 --> [setBeanName方法调用] --> [setBeanFactory方法调用] --> [setApplicationContext方法调用]-->
					   (bean实现BeanNameAware接口)   (bean实现BeanFactoryAware接口) (bean实现ApplicationContextAware接口)   
--> [postProcessBeforeInitialization方法调用] --> [afterProperties、init-method等方法调用] -->[postProcessAfterInitialization方法调用]-->		
	  (bean实现BeanPostProcessor接口) 				(bean实现InitializingBean接口)			   (bean实现BeanPostProcessor接口)
--> bean准备就绪，可以使用了 --> [destroy、destroy-method方法调用](bean实现DisposableBean接口)
	spring-framework-4.0.x共有20个模块，可以划分为6个大的功能模块：spring核心容器、面向切面编程、Insrumentation、数据库与
集成、web和远程调用、测试
													第二章
	装配的概念：创建应用对象之间的协作关系。
	spring提供3种主要的装配机制：Ⅰ在XML中显式配置；Ⅱ在java中进行显式配置；Ⅲ 隐式的bean发现机制和自动装配
	选择哪一种装配方式主要取决于自己的习惯，也可以混合使用三种方式。
	自动装配：spring通过两个步骤实现自动化装配：组件扫描、自动装配
	组件扫描：使用@Component 注解标记组件类，开启spring的自动扫描功能后，spring可以发现需要实例化的组件类。
		@Component
		public class Axe{
		...
		}
		开启自动扫描-基于java配置：
		@Configuration
		@ComponentScan
		public class AppConfig{
		}
		开启自动扫描-基于XML配置：
		<context:component-scan base-package="package1"/>
	测试：
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration(classes=AppConfig.class)
		public class MyAppTest{
			@Autowired
			private Axe axe;
			
			@Test
			public void test01(){
				asertNotNull(axe);
			}
		}
	使用@Component标记的bean的id默认为类名的小写形式，为bean指定id可以使用：@Component("xxx")；也可以使用java依赖注入规范
提供的注解：@Named("xxx")，大多数情况下@Named可以替换@Component使用
	使用@ComponentScan配置的默认扫描包是配置类所在的包和该包的子包，指定扫描的基础包可以这样：
@ComponentScan("package1")；也可以使用：@ComponentScan(basePackages="package1")；指定多个包作为扫描基础包：
@ComponentScan(basePackages={"package1","package2"})
	通过配置指定类的class对象来将类所在的包作为扫描基础包：
@ComponentScan(basePackageClasses={Axe.class,Woodcutter.class})  //将Axe和Woodcutter所在的包作为扫描基础包
这里实际可以使用一个标记接口来代替具体的应用组件类
	自动装配：使用@Autowired注解声明组件的依赖对象，通常是将@Autowired注解应用在构造器上或setter方法上，实际上可以应用到
任何可以设置依赖对象的方法上(使用组件扫描的方式中完全可以直接将@Autowired放在依赖对象上，不定义setter方法也可以，)。
可以使用java依赖注入规范的@Inject注解替换@Autowired。
使用了@Autowired声明依赖某个对象，但是容器没有创建该类对象，spring创建上下文时会抛出异常，使用@Autowired(required=false)
可以避免这种异常抛出，但是需要在程序中判断引用的对象是否为null。如果有多个依赖类（接口）类型，创建上下文也会抛出异常。
	
	使用JaveConfig进行显示配置bean：
		@Configuration
		public class MyAppConfig {
			@Bean
			public Axe axe(){
				return new AxeB();
			}
		}
	采用JavaConfig配置bean之间的关系时，@Autowired声明的依赖对象必须使用某种方式注入，构造器参数注入或setter方法注入：
		@Autowired
		public WoodcutterB(Axe axe){
			this.axe = axe;
		}
		///
		@Bean
		public Woodcutter woodcutter(){
			return new WoodcutterB(axe());
		}
	这里axe()会被容器拦截，所以其实每次返回的都是同一个bean
	也可以使用另外一种方式：
		@Bean
		public Woodcutter woodcutter(Axe axe){
			return new WoodcutterB(axe);
		}
	这种方式不关心传入的axe是如何创建的，可以是通过@Bean配置，也可以是通过XML配置，也可以是自动扫描方式
	
	历史上，早期的spring是采用XML来配置bean已经bean之间的关系的，现在不推荐使用这种方式，因为这不是一种方便的做法。
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
			<bean id="axe" class="package1.impl.AxeC"/>
		</beans>
	XML配置文件存在的两个问题是：一是容器只能根据bean的默认构造方法来创建对象，而JavaConfig中则可以使用多种方式自定义
对象创建的方式，二是全类名是以字符串的方式提供的，正确性无法得到保障，往往需要使用IDE来进行校验。
	XML中配置使用构造器注入依赖有两种方式：使用<constructor-arg>和spring3引入的c-命名空间
		<bean id="woodcutter" class="package1.impl.WoodcutterC">
			<constructor-arg ref="axe"/>
		</bean>
	c-命名空间：
		xmlns:c="http://www.springframework.org/schema/c"
		<bean id="woodcutter" class="package1.impl.WoodcutterC" c:axe-ref="axe"/> //这里axe-ref引用了构造器的参数名
		也可以这样用：
		<bean id="woodcutter" class="package1.impl.WoodcutterC" c:_0-ref="axe"/>  //这里_0-ref引用构造器参数下标
	构造器注入字面量：
		<constructor-arg value="red axe"/>
		<bean id="axe" class="package1.impl.AxeC" c:_0="orange axe"/>
	构造器注入集合：
		<constructor-arg>
			<list>
				<value>hello</value>
				...
			</list>
		</constructor-arg>
	这里使用list，也可以使用<set>二者没有区别，都可以用于构造器参数类型是List\Set\数组的参数注入；<list>内部使用<value>
注入字面量，也可以使用<ref>axe</ref>注入bean引用
	使用setter方法注入属性：
		<bean id="axe" class="package1.impl.AxeC">
			<constructor-arg value="red axe"/>
			<property name="price" value="50"/>
		</bean>
	<property>内部也可以使用<list>注入集合
	使用p命名空间：
		xmlns:p="http://www.springframework.org/schema/p"
		<bean id="axe2" class="package1.impl.AxeC" c:_0="orange axe" p:price="20"/>
		<bean id="woodcutter2" class="package1.impl.WoodcutterC" p:axe-ref="axe"/>
	使用util命名空间：
		xmlns:util="http://www.springframework.org/schema/util"
		<bean>外部定义集合：
		<util:list id="list1">
			<value>xxx</value>
			...
		</util:list>
		使用p命名空间前缀引用util:list
		<bean id="xx" class="..." p:tracks-ref="list1"/>
	混合使用几种配置方式：
	基于JavaConfig为主的配置的典型用法是：使用一个顶层java配置文件，在该java类中引用其它java配置文件和xml配置文件：
		@Configuration
		@Import({MyAppConfig.class})
		@ImportResource("classpath:applicationContext.xml")
		public class TopLevelConfig {
		}
	基于XML为主的配置的典型用法是：使用一个顶层XML配置文件，在该XML文件中引用其它java配置文件和xml配置文件：
		<bean class="config.MyAppConfig"/>
		<import resource="applicationContext.xml"/>
	
													第三章
	不同的应用运行环境往往意味着应用需要做出一些调整，如果开发环境的应用运行良好，在迁移到生产环境时，我们希望最好
不要变动太大。数据库配置等和环境关联密切的配置又确实需要调整，spring为此提供了一些解决方案。
	spring可以在运行时根据环境来创建和环境相关的bean，而不需要重新构建应用。
	基于JavaConfig的配置：
	在配置类上使用@Profile("env")注解声明当前配置类对应的环境，只有对应的profile被激活，才会使用此类中的bean声明。
spring3.2开始也可以在方法上使用这个注解：
		@Configuration
		public class MyAppConfig {
			@Bean
			@Profile("dev")
			public Axe axe(){
				return new AxeB();
			}
			
			@Bean
			@Profile("proc")
			public Axe axe(){
				return new AxeC();
			}
		}
	基于XML文件的配置：
	在<beans>元素上使用属性 profile="env"声明当前配置文件对应的环境，也可以在<beans>里面嵌套<beans>:
	<beans ...>
		<beans profile="dev">
			<bean id="axe" class="package1.impl.AxeB"/>
			...
		</beans>
		<beans profile="proc">
			<bean id="axe" class="package1.impl.AxeC"/>
			...
		</beans>
	</beans>
	激活profile:
	spring应用上下文使用spring.profiles.active 和 spring.profiles.default属性确定激活哪个profile配置，优先使用前者。
没有使用profile修饰的bean总是会被创建，不指定激活的profile则不会创建任何使用profile修饰的bean。
	可以在以下位置配置spring.profiles.active 和 spring.profiles.default的值：
		web应用中DispatcherServlet的初始化参数；
		web应用的上下文参数；
		JNDI条目；
		环境变量；
		JVM系统参数；
		测试类上使用@ActiveProfiles({"dev"})注解声明
	spring4的条件化配置：
	spring4新增了注解：@Conditional，用在使用@Bean修饰的方法上，当条件为true就创建这个bean，否则不创建这个bean：
		@Bean
		@Conditional(MyCondition.class)
		public Axe axe(){
			return new AxeB();
		}
	这里MyCondition 需要实现spring 的Condition接口，该接口中声明了一个方法：
boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); ConditionContext接口的实例可以获取环境信息：
Environment、bean工厂、资源加载器等，AnnotatedTypeMetadata接口实例可以获取该@Conditional注解修饰的方法上的所有注解的信息。
		public class MyCondition implements Condition{
			public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata){
				Environment env = context.getEnvironment();
				return env.containsProperty("proc");
			}
		}
	spring4开始，@Profile注解使用了@Conditional改写。
	前面提到过，自动装配中如果存在多个同类型的bean，在注入时spring会抛出异常，这就是自动装配的歧义性问题。spring
有两种方式处理这个问题：一种是标示首选的bean，另一种是使用限定符。
	基于JavaConfig的配置中可以用 @Primary注解和 @Component或 @Bean配合使用标示首选bean：
		@Configuration
		public class MyAppConfig {
			@Bean
			public Axe axe(){
				return new AxeB();
			}
			
			@Bean
			@Primary
			public Axe axe2(){
				return new AxeC();
			}
		}
	基于XML文件的配置中可以使用：<bean ... primary="true"/>
	标示首选bean的方式只能解决部分问题，因为可以同时标示多个同类型的bean为首选bean，这样就还是存在歧义性。
	spring提供@Qualifier("xxx") 注解声明bean的限定符，@Qualifier("xxx")既用在声明bean的地方，比如和
@Component或 @Bean配合使用定义bean的限定符，也用在声明bean的依赖处：和@Autowired配合使用。还可以使用
@Qualifier注解定义自己的限定符注解：
		@Target(ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE)
		@Retention(RetentionPolicy.RUNTIME)
		@Qualifier
		public @interface Golden{}
	使用：
		@Configuration
		public class MyAppConfig {
			@Bean
			@Golden
			public Axe axe(){
				return new AxeB();
			}
			
			@Bean			
			public Axe axe2(){
				return new AxeC();
			}
		}
		///
		@Autowired
		@Golden
		private Axe axe;
	bean的作用域问题：默认构造的bean都是单例，也就是说如果有多个bean依赖某类型的bean，其实依赖的都是同一个bean，如果
希望把某个bean声明为非单例，可以使用注解：@Scope或者是scope属性：
		@Bean
		@Scope(ConfigurableBeanFactory.SCOPE_PROROTYPE)
		public Axe axe(){
			return new AxeB();
		}
		或
		<bean id="axe" class="..." scope="prototype"/>
	web应用中声明bean为会话作用域：
		@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopeProxyMode.INTERFACE)
	这里的proxyMode用于将这个bean注入单例的bean中时，使用一个代理对象代替当前bean，因为在初始化容器时当前会话域的bean
还没有被创建。实际调用会话作用域bean的方法时该代理对象会委托实际的会话bean处理。proxyMode=ScopeProxyMode.INTERFACE是基于
接口的代理，如果是类，需要使用CGLig代理：proxyMode=ScopeProxyMode.TARGET_CLASS
	基于XML的配置中使用:
		<bean id="xxx" class="..." scope="session">
			<aop:scoped-proxy/>
		</bean>
	scoped-proxy默认基于CGLib的类代理，可以使用属性proxy-target-class=false设置使用接口代理
	注入外部值：为了避免某些硬编码，spring支持从外部文件中读取配置的值并注入到bean中
		@Configuration
		@PropertyResource("classpath:app.properties")
		public class ExpressiveConfig{
			@Autowired
			Environment env;
			
			@Bean
			public Axe axe(){
				return new AxeD(env.getProperty("axed.name","stone axe"),env.getProperty("axed.price", Integer.class, 50));
			}
		}
	Environment提供了很多方法用来获取外部信息以及环境信息。
	使用占位符：${xxx}
	构造函数中使用：
		@Autowired
		public AxeD(@Value("${axed.name}") String name, @Value("${axed.price}") int price){
			this.name = name;
			this.price = price;
		}
	需要声明PropertySourcesPlaceholderConfigurer类型的bean：
		@PropertySource("classpath:/resources/app.properties")
		@Bean
		public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer(){
			PropertySourcesPlaceholderConfigurer config = new PropertySourcesPlaceholderConfigurer();
			return config;
		}
	XML文件中使用：
		<context:property-placeholder file-encoding="UTF-8" location="classpath:/resources/app.properties" ignore-resource-not-found="true" />
		<bean id="axed" class="package1.impl.AxeD" 
			c:_name="${axed.name}
			c:_price="${axed.price} "
		/>
	可以在构造器和属性注入中使用spEL表达式，spEL具有很强的能力，包括：使用bean的id引用bean、访问bean的属性和方法、
进行算术运算逻辑运算、进行正则表达式匹配、操作集合等
	读取系统属性：
		@Autowired
		public AxeD(@Value("#{systemProperties[axed.name]}") String name, @Value("{systemProperties[axed.price]}") int price){
			this.name = name;
			this.price = price;
		}
	引用bean的属性：
		<property name="price" value="#{axe2.price}"/>
	链式调用bean的方法：
		<property name="name" value="#{axe2.getName().toUpperCase()}"/>
	T表达式和运算符：
		#{2*T(java.lang.Math).PI*circle.radius}
	三元运算符：
		#{axe.name ?: "golden axe"}
	匹配正则表达式：
		#{email.address matches '[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.com'}
	操作集合：
		#{peter.teles[2]}
		#{peter.teles.?[nums matches '159[0-9]+']}
		
										第四章
	横切关注点：分散地分布在应用中的功能，这些功能在概念上是和业务逻辑相分离的，但是往往又是必须要
保留的。面向切面编程所要解决的问题就是将这些功能和业务逻辑分离开。
	横切关注点往往是通用的功能，如日志、安全、事务等，实现这些通用功能的传统方式主要有两种：继承和
委托。继承的问题在于构建的应用的对象体系将会非常脆弱，如果想要调整某个功能在某一处应用的具体形式，
就会遇到问题：要么全局修改，要么放弃。委托的问题在于调用增加了复杂性。
	切面提供了一个替代继承和委托的新方案，通用功能点的定义仍然在一个地方完成，但是使用声明的方式来
定义在什么地方以什么方式（在什么时间）被应用。切面的非常重要的地方在于应用切面不需要更改目标类。
	什么是切面？切面是横切关注点被模块化组织在一起后的类。
	AOP术语：
	通知：定义了一个横切关注点要做的事和什么时候使用，通知的具体实现分为两个部分，通知的执行时机由
spring框架提供API，具体要做的事由我们自己实现。spring提供5种通知执行的时间点，也是通知的5种类型:
前置通知、后置通知（不管连接点目标执行是否成功都执行）、环绕通知、返回通知（在连接点目标成功返回才
执行）、异常通知。
	连接点：应用中（语义上）可以应用通知的时机。可以是某个对象方法调用前、方法调用抛出异常时，甚至
是对象的字段被修改时、对象构造时等。spring目前只支持方法调用期间应用通知。
	切点：切点在切面类中定义通知在什么地方应用，切点的定义匹配通知要织入的一个或多个连接点。通常使用
明确的类名和方法名或者正则表达式来定义切点。
	切面：通知和切点的结合后的类。
	引介：为当前类或接口引入新的方法的一种机制，引介不需要修改当前代码，本质上还是代理
	织入：根据切面和目标对象创建代理对象的过程。织入根据生成代理的时机可以分为三种类型：
		编译期：在编译阶段使用特殊的编译器直接编译产生代理的class文件。（AspectJ支持）
		类加载期：在JVM加载类时，使用特殊的类加载器根据目标对象的字节码对象和切面类的字节码对象产生
代理对象的字节码对象。（AspectJ5支持）
		运行期：创建目标对象后根据目标对象和切面对象动态创建代理对象。（Spring使用）
	spring提供4种类型的AOP支持：
		传统的spring经典AOP实现；
		纯POJO切面；（基于XML提供配置）
		@AspectJ注解驱动的切面；
		注入式AspectJ切面
	前三种都是使用的动态代理实现，所以只支持对方法调用应用通知。
	Spring AOP中使用AspectJ的切点表达式来定义切点，但是只支持AspectJ切点指示器的一个子集：
		args()、@args、execution()、this()、target、@target()、within()、@within()、@annotation
这里面只有execution是实际进行匹配的，其它的指示器用来限制匹配。
				返回值类型						方法名
		execution(int service.intface.GoodsResourse.*(String))
		方法执行时触发		类全限定名				  参数类型
		这里可以使用实现类，也可以使用接口，效果是一样的。
		模糊匹配：
		execution(* service..*.*(..))
		使用within()限定类的位置：
		execution(* service..*.*(..)) && within(service.*)
											限定类为service包下的类（不包括service的子包）
	spring提供了一个@bean指示器，可以限定为指定ID的bean启用通知：
		execution(int service..*.*(..)) && bean('goodsResourse')   //这里可以在bean前加一个!进行取非
	在基于java类的切点定义中，使用&&和and是一样的，但是在基于xml的配置中只能使用and
	基于注解的切面：
		@Aspect
		@Component
		public class CommonAspect {
			@Pointcut("execution(int service..*.*(String))")
			public void pointCut(){}

			@Before("pointCut()")
			public void registGoodsOp(){
				System.out.println("CommonAspect.registGoodsOp...");
			}

			@Before("execution(int service..*.*(..))")
			public void registOpArgs(){
				System.out.println("CommonAspect.registOpArgs...");
			}

			@After("pointCut()")
			public void registOpResult(){
				System.out.println("CommonAspect.registOpResult...");
			}
			
			@Around("pointCut()")
			public void aroundDo(ProceedingJoinPoint joinPoint){
				try {
					System.out.println("before do the task...");
					joinPoint.proceed();
					System.out.println("after the task is finished...");
				}catch (Throwable e){
					System.out.println("exception happended: "+e.getMessage());
				}
			}
		}
	spring使用AspectJ注解来声明通知执行的时机：
		@Before	通知方法在目标方法调用前执行
		@After	通知方法在目标方法返回或抛出异常后执行
		@AfterReturning	通知方法在目标方法返回后执行
		@AfterThrowing	通知方法在目标方法抛出异常后执行
		@Around	通知方法将目标方法封装起来
	@Pointcut注解用于在一个切面中定义可重用的切点。
	@Around注解标记的方法接受一个ProceedingJoinPoint类型的对象作为参数，这个参数是必须的，在方法中，
通过joinPoint.proceed();调用目标方法，这样完全可以在方法中根据条件不调用或多次调用目标方法。joinPoint
对象除了调用目标方法外，还可以拿到目标方法签名和调用时传入的参数。
	处理参数：
		@Pointcut("execution(* service..*.*(String)) && args(goodsTypeNum)")
		public void pointCut(String goodsTypeNum){}

		@Before("pointCut(goodsTypeNum)")
		public void registGoodsOp(String goodsTypeNum){
			System.out.println("args is: "+goodsTypeNum);
			System.out.println("CommonAspect.registGoodsOp...");
		}
	需要注意的是@Pointcut注解中的参数类型、args(paramName)要和其修饰的方法的参数类型、参数名一致，
@Before注解后的参数名要和它修饰的方法的参数名一致。
	引介：
		需要引入的接口和方法：
		public interface GoodsPriceResourse {
			double getHistoryPrice(String date);
		}
		引介切面：
		@Aspect
		@Component
		public class ExtraAspect {
			@DeclareParents(value = "service.intface.GoodsResourse+",defaultImpl = GoodsPriceResourseImpl.class)
			public static GoodsPriceResourse goodsPriceResourse;
		}
		value指定要引入新的接口的bean的类型，defaultValue指定引入接口的实现类
		这里配置value时不是直接写接口，后面的+表示应用到接口的实现类上。
		使用：
		GoodsResourse goodsResourse = (GoodsResourse)context.getBean("goodsResourse");
        GoodsPriceResourse goodsPriceResourse = (GoodsPriceResourse)goodsResourse;
        double price = goodsPriceResourse.getHistoryPrice("2018-12-25");
        System.out.println("price on 2018-12-25 is: "+price);
	
	在XML配置文件中声明切面：
	spring提供以下的aop元素来声明切面：
		<aop:aspectj-autoproxy>
		<aop:config>
		<aop:aspect>
		<aop:pointcut>
		<aop:before>
		<aop:after>
		<aop:after-returning>
		<aop:after-throwing>
		<aop:around>
		<aop:declare-parents>
		<aop:advisor>
	实例：
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			   xmlns:aop="http://www.springframework.org/schema/aop"
			   xsi:schemaLocation="http://www.springframework.org/schema/beans
					http://www.springframework.org/schema/beans/spring-beans.xsd
					http://www.springframework.org/schema/aop
					http://www.springframework.org/schema/aop/spring-aop.xsd">
			<bean id="goodsResourse" class="service.impl.GoodsResourseImpl">
			</bean>
			<bean id="goodsPriceResourse" class="service.impl.GoodsPriceResourseImpl">
			</bean>
			<bean id="commonAspect" class="aspect.CommonXmlAspect"></bean>
			<aop:aspectj-autoproxy proxy-target-class="false"/>
			<aop:config>
				<aop:pointcut id="pointcut" expression="execution(* service..*.*(..))"/>
				<aop:aspect ref="commonAspect">
					<aop:before method="registGoodsOp" pointcut="execution(* service..*.*(..))"/>
					<aop:after method="registOpResult" pointcut="execution(* service..*.*(..))"/>
					<aop:around method="aroundDo" pointcut-ref="pointcut"/>
				</aop:aspect>
			</aop:config>
		</beans>
	使用<aop:aspectj-autoproxy proxy-target-class="false"/>开启切面代理，proxy-target-class="false"
表示不使用基于类的代理，这里其实可以不配置这个属性，默认值就是false
	通知元素的属性pointcut="execution(* service..*.*(..))定义切点表达式，可以将这里的切点表达式放在
独立的元素<aop:pointcut>中：
		<aop:pointcut id="pointcut" expression="execution(* service..*.*(..))"/>
		通知使用pointcut-ref属性引用： <aop:before method="registGoodsOp" pointcut-ref="pointcut"/>
	<aop:pointcut>可以放在<aop:aspect>内，这时只有<aop:aspect>内的通知元素能引用定义的切点，如果将
<aop:pointcut>放在<aop:config>下，则该<aop:config>内所有的<aop:aspect>中的通知都可以引用这个切点。
	传递参数给通知：args(param)中的参数名需要和切面类的通知方法的参数名一致。
		<aop:pointcut id="pointcut" expression="execution(* service..*.*(String)) and args(param)"/>
	注意：这里的带参数限制的切点不能让环绕通知引用，因为环绕通知的参数只有joinpoint。
	配置引介切面：
		<aop:aspect>
            <aop:declare-parents
                    types-matching="service.intface.GoodsResourse+"
                    implement-interface="service.intface.GoodsPriceResourse"
                    default-impl="service.impl.GoodsPriceResourseImpl"/>
        </aop:aspect>
	default-impl属性可以替换为delegate-ref="goodsPriceResourse"，引用一个bean作为默认实现
	AspectJ切面类：MyAspectJAspect.aj
		public aspect MyAspectJAspect {
			public MyAspectJAspect(){}

			pointcut goodsServicePointcut() : execution(* addOne(..));

			afterReturning() : goodsServicePointcut(){
				System.out.println("do after");
			}

			private GoodsPriceResourse goodsPriceResourse;

			public void setGoodsPriceResourse(GoodsPriceResourse goodsPriceResourse){
				this.goodsPriceResourse=goodsPriceResourse;
			}
		}
	将这个切面使用spring管理：
		<bean id="myAspectJAspect" class="aspect.MyAspectJAspect" factory-method="aspectOf">
			<property name="goodsPriceResourse" ref="goodsPriceResourse"/>
		</bean>
	aspectj的切面对象不会有spring创建，所以spring只能使用factory-method="aspectOf"获取有aspectj自己
创建的对象。
	编译aspectj切面需要使用专门的编译插件：
		<plugin>
			<groupId>org.codehaus.mojo</groupId>
			<artifactId>aspectj-maven-plugin</artifactId>
			<version>1.8</version>
			<executions>
				<execution>
					<goals>
						<goal>compile</goal>
					</goals>
				</execution>
			</executions>
			<configuration>
				<complianceLevel>1.8</complianceLevel>
				<source>1.8</source>
				<target>1.8</target>
			</configuration>
		</plugin>
	
													第五章
	Spring提供一个MVC框架用于开发web应用，其目标是实现web组件之间的松耦合。
	springmvc处理http请求流程：
	HTTP请求从客户端发出后，到达目标主机后被web服务器如Tomcat接收，然后tomcat根据映射路径将请求转交给相应的servlet处理，在
springmvc中，请求被统一交给DispatcherServlet实例处理，这类servlet被称为前端控制器Servlet。DispatcherServlet实例通过
查询处理器映射来确定处理该请求的控制器，控制器这类组件通常将处理逻辑交给服务对象完成，然后控制器将处理后的数据保存到
模型对象中并返回逻辑视图名（也可能返回数据对象），DispatcherServlet实例收到控制器实例返回的逻辑视图名后查找视图解析
器得到实际的视图实现，视图实现实例使用模型对象的数据来渲染视图，最后渲染后的视图被返回给客户端。
	传统的web程序开发模式中，使用web.xml文件来配置servlet，servlet3.0开始可以使用基于java类的配置而不再必须使用web.xml
来定义配置：servlet3.0环境中，servlet容器会在类路径中查找实现了javax.servlet.ServletContainerInitializer接口的类，这个
实现类将被用来配置servlet容器。spring提供了这个接口的一个实现类：SpringServletContainerInitializer，这个类实例又查找
WebApplicationInitializer接口的实现，配置内容将由这个实现提供。spring3.2提供了一个这个接口的默认实现：
AbstractAnnotationConfigDispatcherServletInitializer。所以可以通过继承这个类来配置servlet：
		public class MinimsgWebAppInitializer
				extends AbstractAnnotationConfigDispatcherServletInitializer {
			@Override
			protected Class<?>[] getRootConfigClasses() {
				return new Class<?>[]{RootConfig.class};
			}

			@Override
			protected Class<?>[] getServletConfigClasses() {
				return new Class<?>[]{WebConfig.class};
			}

			@Override
			protected String[] getServletMappings() {
				return new String[]{"/"};
			}
		}
	AbstractAnnotationConfigDispatcherServletInitializer实例会同时创建DispatcherServlet实例和一个ContextLoaderListener实例.
	上面这个扩展AbstractAnnotationConfigDispatcherServletInitializer的配置类不需要添加任何注解，同时覆写了三个方法：
	getServletMappings方法将（一个或多个）请求路径映射到DispatcherServlet实例上，这里使用"/"表示进入应用的所有请求都会被
转交给DispatcherServlet实例处理。
	getServletConfigClasses方法返回一个或多个配置类的class对象，DispatcherServlet创建时会根据这个方法返回的配置类
class对象来创建一个spring web应用上下文（容器），这个应用上下文将会管理与web相关的组件bean，如控制器、视图解析器和
处理器映射等。
	getRootConfigClasses方法返回一个或多个配置类的class对象，ContextLoaderListener创建时根据这个方法返回的配置类
class对象创建另一个spring应用上下文（容器），这个应用上下文将会管理与业务模型相关的bean。
	(注：tomcat从7.0开始支持servlet3.0)
	web配置类：
		@Configuration
		@EnableWebMvc
		@ComponentScan("com.zhangwei.minimsg.web")
		public class WebConfig extends WebMvcConfigurerAdapter {

			@Override
			public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer){
				configurer.enable();
			}

			@Bean
			public ViewResolver viewResolver(){
				InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
				viewResolver.setPrefix("/WEB-INF/views/");
				viewResolver.setSuffix(".jsp");
				viewResolver.setExposeContextBeansAsAttributes(true);
				return viewResolver;
			}
		}
	@EnableWebMvc注解是必须的，用来标记启用springmvc，@ComponentScan标记只扫描web相关的bean。
	这个配置类配置了一个视图解析器，这个视图解析器将逻辑视图名xxx解析为物理视图：/WEB-INF/views/xxx.jsp
	这个配置类继承了WebMvcConfigurerAdapter并覆写了方法：configureDefaultServletHandling，用来将静态资源交给
servlet容器默认的servlet处理。这里需要注意的是，如果将静态资源放在WEB-INF目录下，那么servlet容器的默认servlet
是不能访问到的，解决方法就是把静态资源放到WEB-INF目录外，如果需要将静态资源放在WEB-INF下，可以使用spring的资源处
理器，指明具体的静态资源路径：
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/resources/", "/WEB-INF/resources/");
		}
	非web应用上下文：
		@Configuration
		@ComponentScan(basePackages = {"com.zhangwei.minimsg"},
			excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION,value = EnableWebMvc.class)})
		public class RootConfig {
		}
	@ComponentScan指定不扫描web组件相关的bean。
	简单的控制器：
		@Controller
		public class HomeController {
			@RequestMapping(value = "/",method = RequestMethod.GET)
			public String home(){
				return "home";
			}
		}
		另一种映射写法：
		@Controller
		@RequestMapping({"/","/homePage"})
		public class HomeController {
			@RequestMapping(method = RequestMethod.GET)
			public String home(){
				return "home";
			}
		}
	@Controller和@Component实际作用是一样的，但是语义上更明确。
	@RequestMapping定义了路径到方法的映射，value属性用于定义路径，method定义访问方法。
	使用springmvc提供的测试工具：
		@Test
		public void testHomePage() throws Exception{
			HomeController controller = new HomeController();
			MockMvc mock = MockMvcBuilders.standaloneSetup(controller).build();
			mock.perform(MockMvcRequestBuilders.get("/"))
					.andExpect(MockMvcResultMatchers.view().name("home"));
		}
	向模型对象中填充数据：
	@RequestMapping(value = "/msges",method = RequestMethod.GET)
    public String getMsgList(Model model){
        model.addAttribute(repository.findMiniMsgs(Integer.MAX_VALUE,20));
        return "msges";
    }
	Model是spring提供的类，也可以使用Map替换。上面的写法中，model中属性的key通过推断得到：
		List<MiniMsg> -> miniMsgList	//如果返回单个对象，推断规则：MiniMsg -> miniMsg
	key也可以手动设置：model.addAttribute("miniMsgList"，repository.findMiniMsgs(Integer.MAX_VALUE,20));
	另一种写法：
		@RequestMapping(value = "/msges",method = RequestMethod.GET)
		public List<MiniMsg> getMsgList(){
			return repository.findMiniMsgs(Integer.MAX_VALUE,20);
		}
	这种写法返回的对象会被放到模型对象中，其key也是通过推断得到，逻辑视图名也通过推断得到（就是请求路径名）
	
	springmvc提供3种方式从客户端提交数据到服务器的控制器方法：查询参数、表单参数、路径变量
	查询参数：
		@RequestMapping(value = {"/msgpagelist"},method = RequestMethod.GET)
		public String getPageMsgList(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
									 @RequestParam(value="count",defaultValue="20")int count,
									 Model model){
			model.addAttribute(repository.findMiniMsgs(max,count));
			return "msges";
		}
	上面的写法中，定义了两个可以从客户端传输数据的参数：max和count，使用：
		http://localhost:8080/minimsg/msgpagelist?max=88888888888&count=10
	如果客户端不提供这两个参数将使用defaultValue设置的值：
		http://localhost:8080/minimsg/msgpagelist
	注意：Java规则中，当有一个注解的参数期望一个原始类型(例如int)或一个字符串时，这个值必须是一个常量表达式。
常量表达式是指编译器在编译时能够计算出的值，只有特定类型的操作可以在一个常量表达式中使用。
	① private static final String MAX_LONG_AS_STRING = Long.toString(Long.MAX_VALUE);
	上面的写法会报错：Atrribute value must be constant，因为Long.toString()需要在运行时执行，所以结果不是常量。
	② private static final String MAX_LONG_AS_STRING = Long.MAX_VALUE+"";
	第二种写法可以在编译期得到值，所以可以实现常量转换
	@RequestParam还可以设置一个属性：required=true/false 用于设置是否必须提供该参数。
	访问特定的某个资源时，可以使用两种路径设计：一种是面向资源的：/msg/12；另一种是带有参数的操作：
/msg/show?msgId=12；第二种方式本质上是通过http发起的RPC。
	使用面向资源的路径设计：
		@RequestMapping(value = "/msg/{msgId}",method = RequestMethod.GET)
		public String getMsg(@PathVariable("msgId") Long id, Map model){
			model.put("msg",repository.findOne(id));
			return "miniMsgDetail";
		}
	@RequestMapping的value属性中使用占位符{msgId},@PathVariable的value属性需要和这个占位符保持一致，如果方法的参数
命名和占位符一样，则可以省略@PathVariable的value属性：
		@RequestMapping(value = "/msg/{msgId}",method = RequestMethod.GET)
		public String getMsg(@PathVariable Long msgId, Map model){...}
	处理表单提交：
		@RequestMapping(value = "/register",method = RequestMethod.GET)
		public String showRegisteForm(){
			return "registerForm";
		}

		@RequestMapping(value = "/register",method = RequestMethod.POST)
		public String regist(User user){
			userRepository.saveOne(user);
			return "redirect:/user/"+user.getUserName();
		}
	上面两个方法映射路径相同，不同的只是提交的方法，第一个方法返回注册的表单：
		<form method="post">
            <label>First Name:</label><input name="firstName" type="text"/><br>
            <label>Last Name:</label><input name="lastName" type="text"/><br>
            <label>Username:</label><input name="userName" type="text"/><br>
            <label>Password:</label><input name="password" type="password"/><br>
            <input type="submit" value="regist"/>
        </form>
        防止中文乱码需要加入编码：
        <%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
	表单中只指定了提交方法为post，默认会把表单提交给访问表单页面的路径，也就是/register
	第二个方法返回的逻辑视图名具有前缀："redirect:"表示将重定向到另一个映射路径。此外可以使用
"forward:"前缀进行转向。
	@RequestMapping(value = "/register",method = RequestMethod.POST)
	public String regist(User user){...}
	这种写法中参数对象没有使用任何注解修饰，客户端以url参数、form-data、x-www-form-urlencoded
都可以提交数据到控制器方法：
		①
		POST http://localhost:8080/user/register?id=11&name=sss
		②
		POST http://localhost:8080/user/register
		Content-Type: multipart/form-data; boundary=--------------------------149543072435003070231446
		
		id=111&name=sdfsdf
		③
		POST http://localhost:8080/user/register
		Content-Type: application/x-www-form-urlencoded

		id=111&name=sdfsdf
	客户端使用json格式的参数（Content-Type: application/json），控制器不会报错，但是无法设置参数对象的属性值。
	@RequestMapping(value = "/register",method = RequestMethod.POST)
	public String regist(@RequestBody User user){...}
	@RequestBody 注解用于声明参数的MIME类型为application/json，一旦使用了这个注解，参数就必须是json对象，其他
格式的参数不能解析，并且spring会抛出异常：HttpMediaTypeNotSupportedException，返回http状态码为415
	校验参数：使用JSR 303的API和hibernate提供的实现：Hibernate Validator
		@NotNull
		@Size(min=5,max=16)
		private String userName;
		@NotNull
		@Size(min=5,max=16)
		private String password;
	添加校验：
	@RequestMapping(value = "/register",method = RequestMethod.POST)
    public String regist(@Valid User user, Errors errors){
        if(errors.hasErrors()){
            return "registerForm";
        }
        userRepository.saveOne(user);
        return "redirect:/user/"+user.getUserName();
    }
	校验不通过会转到注册表单页面.
	
                                            第六章
    springmvc实现了控制逻辑和视图渲染的分离，这样就可以避免修改其中某一个时干扰另一个的问题。springmvc使用视图解析器
根据控制器返回的逻辑视图名查找对应的物理视图实现，然后渲染视图并返回。
    springmvc定义的视图解析器接口：ViewResolver：
        public interface ViewResolver{
            View resolveViewName(String viewName, Locale locale) throw Exception;
        }
    视图接口:View
        public interface View{
            String getContentType();
            void render(Map<String,?> model, 
                    HttpServletRequest request, HttpServletResponse response) throw Exception;
        }
    虽然我们可以实现自己的视图解析器和视图，但是通常不需要这么做，因为spring提供了13个视图解析器实现，大多数情况下我
们只需要选用其中的常用的实现就可以了：
        BeanNameViewResolver;   将逻辑视图名解析为spring应用上下文中的bean
        ContentNegotiatingViewResolver; 根据客户端需要的媒体类型选择其他合适的视图解析器
        InternalResourceViewResolver;   将视图名解析为web应用内部的资源文件（通常为jsp）
        TilesViewResolver;  将视图解析为apache Tile定义
        ThymeleafViewResolver;  将视图解析为Thymeleaf模板
        ...
    InternalResourceViewResolver根据配置将视图名解析为资源文件，使用bean配置：
        @Bean
        public ViewResolver viewResolver(){
            InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
            viewResolver.setPrefix("/WEB-INF/views/");
            viewResolver.setSuffix(".jsp");
            viewResolver.setExposeContextBeansAsAttributes(true);
            return viewResolver;
        }
    该配置中：
        home将解析为"WEB-INF/views/home.jsp"
        books/detail将解析为"WEB-INF/views/books/detail.jsp"
    InternalResourceViewResolver默认使用InternalResourceView作为处理jsp文件的View实现，如果需要在
jsp文件中使用jstl的某些特性（如Locale），需要配置JstlView作为视图实现：
        viewResolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
    在jsp中使用sun提供的jstl标签库可以简化很多写法，spring也提供两套标签库来进一步简化基于spring的应用视图开发。一
个用于表单到模型的绑定，另一个提供通用的工具类特性。
    在jsp页面中引入spring表单标签库：
        <%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
    spring表单标签库提供14个标签，这些标签可以绑定模型对象的属性：
        <sf:form method="post" commandName="user">
            <label>First Name:</label><sf:input path="firstName"/><br>
            <label>Last Name:</label><sf:input path="lastName"/><br>
            <label>Username:</label><sf:input path="userName"/><br>
            <label>Password:</label><sf:password path="password"/><br>
            <label>Email:</label><sf:input path="email" type="email"/><br>
            <input type="submit" value="regist"/>
        </sf:form>
    上面的表单绑定了一个模型对象，所以在对应的控制器方法中返回的模型中应该提供这样的对象：  
        @RequestMapping(value = "/register",method = RequestMethod.GET)
        public String showRegisteForm(Model model){
            User user = new User();
            user.setFirstName("zhang");
            user.setEmail("759109612@qq.com");
            model.addAttribute(user);
            return "registerForm";
        }
    表单错误回显：
    指定字段错误回显：<sf:errors path="firstName" cssClass="error"/><br>
    也可以泛指所有字段：<sf:errors path="*" element="div" cssClass="error"/><br>
    在Bean中设置错误提示：
        @Size(min=5,max=16,message="{username.size}")
    这里引用配置文件的内容，默认文件名为ValidationMessages.properties，放在类根路径下：
        username.size=username less than {min} or more than {max}
    配置文件中又引用Bean的注解的内容。
    使用单独的配置文件来保存错误提示信息可以很方便地进行国际化处理。
    在jsp中引入spring通用工具标签库：
        <%@ taglib uri="http://www.springframework.org/tags" prefix="st" %>
    这个标签库提供一些实用的标签，如<st:message>：
        <st:message code="minimsg.welcome"/>
    使用<st:message>需要配置对应的MessageSource接口实现，可以选用spring提供的ResourceBundleMessageSource
和ReloadableResourceBundleMessageSource，后者可以绑定文件系统中的文件，并且可以在程序运行时重新加载修改的
文件。
    @Bean
	public MessageSource messageSource() {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		messageSource.setBasename("message");
		return messageSource;
	}
    类加载根路径下新增message.properties文件：
        minimsg.welcome=你好，欢迎光临
    <st:url>标签可以自动添加web应用上下文，转义显示链接地址，和提供默认参数:
        <st:url href="/user/register" htmlEscape="true">
            <st param name="firstName" value="zhangwei"/>
            register
        </st:url>
    <st:escapeBody>用于转义html特殊字符：
        <st:escapeBody><a>welcome</a></st:escapeBody>
    Apache提供一种页面布局实现：Apache Tiless，可以将逻辑视图名解析为一个tiles定义，这个tiles定义中
可以引用多个jsp文件，同时有一个主页面，该主页面中可以引用tiles定义中的其他页面实现布局。这里不再介绍
具体用法。
    thymeleaf模板引擎是一种可以替代jsp的页面技术，是在html基础上加入新的名称空间提供更强功能的技术：
    一个thymeleaf模板文件，实际上就是一个html文件：/WEB-INF/templates/home.html
        <!DOCTYPE html>
        <html xmlns="http://www.w3.org/1999/xhtml"
            xmlns:th="http://thymeleaf.org" >
        <head>
            <meta charset="UTF-8"></meta>
            <title>Insert title here</title>
            <link rel="stylesheet" type="text/css"
                th:href="@{/resources/style.css}"></link>
        </head>
        <body>
            <h1>welcome to minimsg!</h1>
            <a th:href="@{/msglist}">minimsg list</a>
            <a th:href="@{/user/register}">register</a>
        </body>
        </html>
    配置thymeleaf视图解析器、模板引擎和模板解析器：
        @Bean
        public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
            ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
            viewResolver.setTemplateEngine(templateEngine);
            return viewResolver;
        }
        
        @Bean
        public SpringTemplateEngine templateEngine(TemplateResolver templateResolver) {
            SpringTemplateEngine templateEngine = new SpringTemplateEngine();
            templateEngine.setTemplateResolver(templateResolver);
            return templateEngine;
        }
        
        @Bean
        public TemplateResolver templateResolver() {
            TemplateResolver templateResolver = new ServletContextTemplateResolver();
            templateResolver.setPrefix("/WEB-INF/templates/");
            templateResolver.setSuffix(".html");
            templateResolver.setTemplateMode("HTML5");
            return templateResolver;
        }
    thymeleaf表单绑定属性：
        <form method="POST" th:object="${user}">
            <input type="text" th:field="*{userName}" 
                    th:class="${#fields.hasErrors('userName')}" ? 'error' : ''
            />
        </form>
    这里的${}是变量表达式，表示后端上下文中的某个对象，*{}是选择表达式，表示选中对象的某个属性。
    
											第七章
	配置其他的servlet和filter：
	public class MyServletInitializer implements WebApplicationInitializer {
		@Override
		public void onStartup(ServletContext servletContext) throws ServletException {
			ServletRegistration.Dynamic myServletReg = servletContext.addServlet("myServlet", MyServlet.class);
			myServletReg.addMapping("/myServlet");

			FilterRegistration.Dynamic myFilterReg = servletContext.addFilter("myFilter", MyFilter.class);
			System.out.println("check myFilterReg: "+myFilterReg);
			myFilterReg.addMappingForUrlPatterns(null,false,"/myServlet");
		}
	}
	为DispatcherServlet配置filter：
		public class MinimsgWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
			...
			@Override
			protected Filter[] getServletFilters(){
				return new Filter[]{new MyFilter()};
			}
		}
	基于web.xml的springMVC配置：
		<?xml version="1.0" encoding="UTF-8"?>
		<web-app version="2.5"
				xmlns="http://java.sun.com/xml/ns/javaee"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
				http://java.sun.com/xml/ns/j2ee/web-app_2_5.xsd">
			<context-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>/WEB-INF/spring-root-context.xml</param-value>
			</context-param>
			
			<listener>
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
			</listener>
			
			<servlet>
				<servlet-name>appServlet</servlet-name>
				<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
				<init-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>/WEB-INF/appServlet-context.xml</param-value>
				</init-param>
				<load-on-startup>1</load-on-startup>
			</servlet>
			<servlet-mapping>
				<servlet-name>appServlet</servlet-name>
				<url-pattern>/</url-pattern>
			</servlet-mapping>
		</web-app>
	appServlet-context.xml	
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			http://www.springframework.org/schema/context/spring-context.xsd">

			<context:component-scan base-package="com.zhangwei.newmsg.controller"/>

			<bean id="viewResolver"
				class="org.springframework.web.servlet.view.InternalResourceViewResolver">
				<property name="prefix" value="/WEB-INF/views/"/>
				<property name="suffix" value=".jsp"/>
			</bean>
		</beans>
	spring-root-context.xml
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xsi:schemaLocation="http://www.springframework.org/schema/beans
				http://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/context
				http://www.springframework.org/schema/context/spring-context.xsd">
			<context:component-scan base-package="com.zhangwei.newmsg"/>
		</beans>
    
	处理multipart格式的数据：
	设置表单数据的格式为multipart，将把表单数据拆分为多个部分，每个部分对应一个输入域（表单上传文件需要使用这种格式）。
	配置multipart解析器:
	使用 StandardServletMultipartResolver（servlet3.0开始提供）
		@Bean
		public MultipartResolver multipartResolver(){
			return new StandardServletMultipartResolver();
		}
	配置上传文件大小及保存位置：
		在web.xml中配置：（需要servlet3.0之后的web.xml）
			<multipart-config>
				<location>e:/tem_file/</location>
				<max-file-size>2097152</max-file-size>
				<max-request-size>4194304</max-request-size>
			</multipart-config>
		基于Java配置（web应用初始化类继承AbstractAnnotationConfigDispatcherServletInitializer）：
			@Override
			protected void customizeRegistration(ServletRegistration.Dynamic registration) {
				registration.setMultipartConfig(new MultipartConfigElement("e:/tem_file/files/",2097152,4194304,0));
			}
		基于Java配置（web应用初始化类实现 WebApplicationInitializer接口）：
			@Override
			public void onStartup(ServletContext servletContext) throws ServletException {
				ServletRegistration.Dynamic myServletReg = servletContext.addServlet("appServlet", DispatcherServlet.class);
				myServletReg.addMapping("/");
				registration.setMultipartConfig(new MultipartConfigElement("e:/tem_file/files/",2097152,4194304,0));
			}
	使用 Apache 的 CommonsMultipartResolver ：
		@Bean
		public MultipartResolver multipartResolver() throws IOException {
			CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
			multipartResolver.setUploadTempDir(new FileSystemResource("e:/tem_file/files/"));
			multipartResolver.setMaxUploadSize(2097152);
			multipartResolver.setMaxInMemorySize(0);
			return multipartResolver;
		}
	上传文件的表单：
		<form method="post" enctype="multipart/form-data">
			username: <input name="username" type="text"/><br/>
			age: <input name="age" type="number"/><br/>
			picture: <input type="file" name="picture" accept="image/png,image/jpeg,image/gif">
			<input type="submit" value="regist"/>
		</form>
	controller方法:
		@RequestMapping(value = "/register",method = RequestMethod.POST)
		public String registerUser(@RequestPart("picture") MultipartFile picture, User user){
			System.out.println(user);
			System.out.println("contentType: "+picture.getContentType());
			System.out.println("fileName: "+picture.getOriginalFilename());
			return "index";
		}
	@RequestPart参数类型还可以是byte[]，也可以使用servlet的Part接口类型。MultipartFile类型的文件可以调用：
		picture.transferTo(new File("e:/tem_file/files/"+picture.getOriginalFilename()));
写到文件系统中，Part类型对应写到文件系统的方法是write(String filename).
	使用Part类型接受上传文件实际上不需要配置multipart解析器。
	spring4.3.x 已经可以使用 @RequestParam 注解替换 @RequestPart
	
    处理异常：
    servlet 应该总是为请求返回一个响应，即使应用发送了异常。spring 提供多种将异常转换为响应的方式。
    一些特定的spring预定义异常将被自动转换为指定的 http 状态码，例如 NoSuchRequestHandlingMethodException 将被
转换为 http 状态码 404 。
    如果应用中不处理抛出的自定义异常或其他异常，将会自动返回 http 状态码 500 。
    spring提供一个注解：@ResponseStatus 用于映射应用中的自定义异常。
        @ResponseStatus(value=HttpStatus.NOT_FOUND, reason="data not exist")
        public class DataNotExistException extends RuntimeException {}
    spring 还提供另外一个注解：@ExceptionHandler 用于标记处理应用异常的方法。使用这个注解的方法只能在controller中
定义(可以处理controller中抛出或controller调用链后端抛出的异常)。
        @ExceptionHandler(AppRunningException.class)
        private String handleAppRunningException() {
            return "error";
        }
    spring3.2开始提供一个注解 @ControllerAdvice ，用于处理所有的控制器方法（使用 @RequestMapping 标记的方法）
异常。 @ControllerAdvice 使用了@Component注解，所以在包扫描时它标记的类可以被扫描到。可以把所有的 @ExceptionHandler
标记的方法都放到这个注解标记的类中，统一处理所有控制器方法抛出的异常。
        @ControllerAdvice
        public class AppExceptionHandler {
            @ExceptionHandler(AppRunningException.class)
            @ResponseBody
            private Map<String, Object> handleAppRunningException(Exception e,HttpServletRequest request,
                    HttpServletResponse response) {
                System.err.println("handleAppRunningException........"+e.getMessage());
                Map<String,Object> resultMap = new HashMap<>();
                resultMap.put("message", e.getMessage());
                return resultMap;
            }
            
            @ExceptionHandler(DataNotExistException.class)
            private String handleDataNotExistException(Exception e) {
                System.err.println("handleDataNotExistException........"+e.getMessage());
                return "error";
            }
        }
	需要注意，返回Map类型需要使用 @ResponseBody 注解修饰方法，并且需要单独引入jackson依赖。
    如果是返回视图名，这里其实不能向视图的模型中填充数据。
    使用post方法提交表单数据后，通常需要进行重定向，spring使用 return "redirect:/~" 的方式指定返回的字符串是重定向
请求而不是视图名。跨重定向存在传输数据问题，spring支持在重定义响应中填充数据（在模型中填充），然后浏览器将使用这些数
据作为重定向请求的请求参数。
    设置重定向请求数据： 
        @RequestMapping(value = "/register",method = RequestMethod.POST)
        public String registerUser(@RequestParam("picture") MultipartFile picture, User user, Model model) throws IOException {
            System.out.println("fileName: "+picture.getOriginalFilename());
            picture.transferTo(new File("d:/tem_file/files/"+picture.getOriginalFilename()));
            //重定向路径变量
            model.addAttribute("userId", "1521");
            //重定向url参数
             model.addAttribute("username", "zhangwei");
            return "redirect:/{userId}";
        }
    如果需要传递一个复杂对象作为重定向请求参数，就不能将对象返回给客户端再由客户端传递给服务端，通常是将这个对象保存
到session中。spring提供的处理方法是，重定向前将对象保存到Model的子接口RedirectAttributes实例中，返回重定向响应时
spring就将这个模型上的对象保存到session中，重定向后的新请求到达服务器后，就从session中取出保存的对象填充到新请求的
模型对象中，然后销毁session中的对象。
    第一次请求：
        @RequestMapping(value = "/findAll",method = RequestMethod.GET)
        public String findAll(RedirectAttributes model) {
            User user = new User();
            user.setId("1920");
            user.setUsername("xiaoming");
            user.setAge(33);
            model.addFlashAttribute("user",user);
            model.addAttribute("userid", user.getId());
            return "redirect:/{userid}";
        }
    重定向后的新请求：
        @RequestMapping(value = "/{userId}",method= RequestMethod.GET)
        public String hello(@PathVariable String userId, Model model){
            String name = null;
            //如果model中已经有user对象，这个对象可以渲染到视图上
            if(!model.containsAttribute("user")) {
                name = userService.getNameById(userId);
            }    	
            model.addAttribute("username",name);
            return "index";
        }

	
	
    



















































		