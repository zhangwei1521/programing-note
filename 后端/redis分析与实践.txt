										Redis分析与实践
	Redis入门：
	Redis是一个基于内存的轻量级键值数据库，或者说是一个数据结构服务器。Redis在内存中中实现了多种数据
结构的存储，并提供了操作这些数据结构的API。
	安装Redis：
	 1、mkdir -p /mytools/redis
	 2、cd /mytools/redis 
		wget http://download.redis.io/releases/redis-4.0.1.tar.gz
	 3、tar xzvf redis-4.0.1.tar.gz	
		cd redis-4.0.1
	 4、mkdir /mytools/redis/conf
		cp redis.conf /mytools/redis/conf/
	 5、cd deps
		make hiredis lua jemalloc linenoise
		cd ..
	 6、make
	 7、make prefix=/mytools/redis install
	Redis的版本号规则：major.minor.patch
	/mytools/redis/bin目录下的可执行文件：
		redis-server:	redis服务端
		redis-cli:		redis命令行工具
		redis-sentinel: redis-server的软链接
		redis-check-rdb:	redis RDB检查工具
		redis-check-aof:	redis AOF检查工具
		redis-benchmark:	redis基准/性能测试工具
	
	使用默认配置启动一个Redis实例：
		cd /mytools/redis
		bin/redis-server
	使用指定配置文件启动一个Redis实例：
		bin/redis-server conf/redis.conf
	以守护进程的方式在后台启动Redis实例：
		vim conf/redis.conf
		修改 daemonize 为 yes
	前台redis实例可以直接停止(Ctrl+C)，后台redis-server守护进程可以使用 kill pid-redis-server 停止
	使用命令行工具停止redis-server实例：
		bin/redis-cli shutdown
	一个redis实例就是一个运行中的redis-server进程，一台机器上可以运行多个redis实例，这些实例采用不
同的配置，比如监听不同的端口。
	通常不建议直接 kill redis-server进程，因为这样可能会导致数据未被持久化而丢失。使用shutdown命令
通常可以保证数据的完整性和一致性。
	事实上使用kill时如果向redis-server进程发送SIGTERM(15)信号也相当于使用shutdown命令。
	另外，启动redis-server实例时可以将参数加在命令中。
	
	使用redis-cli连接到redis:
		bin/redis-cli
		交互界面：127.0.0.1:6379>
	redis-cli默认连接本机的6379端口。使用-h 指定要连接的主机ip/地址，-p指定端口，-a指定密码，-s指定
Unix套接字。
	执行简单命令：set foo value1
	交互界面中可以使用shutdown命令关闭redis-server实例。
	获取redis实例状态信息：redis-cli交互环境中使用INFO命令，查看单项(内存)状态信息：
INFO sec(Memory)	
	直接在shell中获取redis实例状态信息：redis-cli INFO
	
	Redis使用单线程、非阻塞、多路复用的I/O模型。它有一个异步事件支持库，称为ae，这个库封装了各个操
作系统提供的polling支持，即内核对异步调用的支持。
	因为redis是单线程执行，所以在一个命令完成前，不能处理其它命令，这就带来了延迟问题。
	
	Redis通信协议：RESP，redis序列化协议。
	客户端发送给redis-server的命令都需要被转换为RESP格式的字符串数组：
		set foo bar 	->		"*3\r\n\$3\r\nset\r\n\$3\r\nfoo\r\n\$3\r\bbar\r\n"
		* 表示这是一个数组，3表示数组大小，\r\n是分隔符，\$3表示后面的参数的字符数，set是(命令)参数
	
	Redis数据类型：
	字符串：基本命令：
		set zhangsan male
		set "Extreme Pizza" "100 Broadway, New York"
		get zhangsan
		get "Extreme Pizza"
		get lisi 					(key不存在时返回 nil)
		strlen "Extreme Pizza"		(返回value的长度，key不存在时返回0)
		append zhangsan ", 25"		(原字符串末尾追加)
		setrange "Extreme Pizza" 14 "Washington DC"		(替换，14是index，index从0开始)
		setnx zhangsan "female, 24"		(key不存在时才设值，等同于 set key value nx)
		set zhangsan "female, 24" xx	(key存在时才设值，就是覆盖原值)
		mset zhangsan male lisi male "Extreme Pizza" "100 Broadway"
		mget zhangsan lisi "Extreme Pizza"
	Redis内部存储字符串值时使用3种编码方式：
		1、能够使用 64位有符号整数表示的数使用int存储，如12345
		2、长度小于等于44的使用embstr编码（redis4.x）
		3、大于44的使用raw编码（redis4.x）
	使用object命令查看redis值的内部编码：
		object encoding zhangsan
	
	列表：基本命令：
		lpush best-friends zhangsan lisi "John St"	(向左插入，"John St"将在最前面)
		lrange best-friends 0 -1	(列表从左向右index为0~N-1，从右到左index为-1~-N，这里
0 -1就表示整个列表)
		rpush best-friends wangwu   (向右插入)
		linsert best-friends before/after zhangsan liuxiaohua		(在指定值前面/后面插入)
		lindex best-friends 2		(返回指定索引处的值)
		lpushx/rpushx friends zhangsan 	(当key存在时才插入值)
		lpop/rpop best-friends		(从左端/右端弹出(删除)值)
		ltrim best-friends 2 3		(只保留索引位置为2、3的值)
		lset best-friends 1 lisi	(替换指定index处的值)
		blpop/brpop friends 0		(阻塞式弹出，0为超时时间(单位:秒)，0表示永久等待)
适用于：任务执行程序(redis客户端)等待任务调度程序分配任务
	redis内部使用quicklist存储列表对象，quicklist的两个配置选项：
		list-max-ziplist-size : 列表内部节点的最大大小，使用默认值即可
		list-compress-depth : quicklist两端不被压缩的节点的个数，我们在访问一个很长列表时可能
常用的数据在列表两端，这样调节这个参数就可以平衡压缩比和访问效率。
	
	哈希：
		hmset "kyoyo ramen" "address" "801 Mission St" "phone" "555-123-654" "rating" "5"
			  # 插入哈希类型，key为"kyoyo ramen",哈希key为"address"、"phone"、"rating"
		hmget "kyoyo ramen" address	#获取"kyoyo ramen"的"address"
		hmget "kyoyo ramen" address phone #获取"kyoyo ramen"的"address"和"phone"
		hget  "kyoyo ramen" address #获取单个属性值
		hexists "kyoto ramen" address  #判断哈希对象中是否含有某个属性
		hgetall "kyoto ramen"  #获取哈希对象所有的属性(不建议对有很多属性的哈希对象使用这个命令)
		hset "kyoto ramen" rating "6.0"	 #修改或新增一个属性
		hdel "kyoto ramen" rating	#删除哈希对象的某个属性
		对于不存在的哈希key或属性字段，hmget和hget都返回nil，hgetall返回empty list or set
		一个哈希对象最多可以具有2^32 - 1个属性字段，使用hgetall可能会导致阻塞，可以使用
hscan 来进行 增量读取，hscan使用指针游标，使用前应先检查或修改该游标，命令执行后会返回一个元素列表
和新的游标，新游标可用于下次读取。
		hscan "kyoto ramen" 0 match *address*	# 0指定游标，match *address*指定属性字段名包括
address，这个match部分是可选的，最后还可以使用可选的 count n 指定每次读取的数量，但是这个值默认为
10，即如果设置的 n 小于10不会生效。返回的数据分为两个部分，第一部分是下次开始继续读取的游标索引，
如果本次已经查询完所有属性字段列表，就会返回0；第二部分是返回的字段名和字段值。
	redis在内部使用两种编码存储哈希对象：
		ziplist：用于属性数量小于配置变量hash-max-ziplist-entries(默认512)的对象，并且属性字段名和
字段值都小于hash-max-ziplist-value(默认64字节)的配置值。
		hashtable: 用于不适用于ziplist编码的哈希对象。

	对于哈希对象和列表，使用前都不需要预先初始化空的对象和列表，插入数据的操作会自动完成创建工作。
同时当一个列表中的数据和哈希对象的属性被全部删除后，redis会自动删除列表和哈希对象占用的空间。
	
	SET集合：Set集合中不能有重复的元素，且元素间没有顺序
		sadd classmates mimi nana didi #添加集合元素
		sismember classmates mimi	#元素存在于集合中返回1，否则返回0，这里如果classmates实际是list，
会产生一个error，如果classmates根本就不存在，返回0
		srem classmates mimi  #删除元素
		scard classmates  #返回集合中元素的个数
		smembers classmates  #返回所有元素(对于具有很多元素的集合不建议使用这个命令，建议使用sscan)
		sscan classmates 0 match *i*	#用法和hscan相同
		sunion classmates friends 	#返回两个集合classmates和friends的并集
		sunionstore known-mans classmates friends #将求并集结果保存到新的集合known-mans
		sinter classmates friends  #返回交集
		sinterstore new-friends classmates friends  #将交集保存到新集合new-friends
		sdiff classmates friends #返回前一个集合和后一个集合的差集，这里需要注意集合的顺序和返回的
结果是有关的。也可以只带第一个集合，这样的效果和smembers相同。
		sdiffstore not-friends classmates friends	#将差集保存到新的集合not-friends
	当Set集合中元素都被删除后，redis会删除这个集合的键。
	一个Set集合最多可以含有2^23 - 1个元素。
	redis在内部使用两种编码存储Set集合：
		intset: 用于元素为整数，并且元素个数小于set-max-intset-entries(默认512)的集合
		hashtable: 用于不适用于intset编码的集合
	
	有序集合：
	zadd ranking:restaurants 100 "Olive Graden" 23 "PF Chang's" 34 "Outback Steakhouse" 
		45 "Red Lobster" 88 "Longhorn Steakhouse"	# 使用 “权重 值” 添加元素到有序集合
	zrem ranking:restaurants "Olive Graden"  #删除元素
	zincrby ranking:restaurants 10 "PF Chang's"		#增加指定元素权重
	zrevrange ranking:restaurants 0 -1	#返回所有的元素，按权重从大到小排序返回
	zrevrange ranking:restaurants 0 -1 withscores	#返回所有的元素和权重
	zrange ranking:restaurants 0 -1 withscores  	#按权重从小到大排序返回
	zrevrank ranking:restaurants "PF Chang's"	#查询指定元素的索引（位序）
	zscore ranking:restaurants "Olive Graden"	#查询指定元素的权重
	zunionstore totalranking 2 ranking:restaurants ranking2:restaurants weights 1 2 
[aggregate sum|max|min (聚合方式)]
		#求ranking:restaurants和ranking2:restaurants的并集(根据权重合并)并保存到新的集合totalranking
	zadd ranking:restaurants nx 50 "Olive Graden" 	#只有元素不存在时才添加
	zadd ranking:restaurants xx 150 "Olive Graden"  #只在元素存在时更新权重值
	当元素的权重相同时，redis使用字典顺序排序元素
	zinterstore newranking 2 ranking:restaurants ranking2:restaurants aggregate max #求交集(保留较大的元素)
	注意：没有zinter 和 zunion操作
	redis使用两种编码保存有序集合：
		ziplist: 元素个数小于zset-max-ziplist-entries(默认128)且元素大小小于zset-max-ziplist-value
(默认64字节)的有序集合。
		skiplist: 不适用于ziplist的有序集合
	
	HyperLogLog:是一种类似集合的数据结构，但是占用内存相比集合少很多，这个数据结构应该主要是用于计数(
它可以O(1)返回计数)。
	pfadd Counting:Olive  000123 000456  #添加元素
	pfcount Counting:Olive				 #返回元素总数
	pfmerge Counting:Olive-Graden counting:Olive counting:Graden  #求并集（重复元素只保留一个）
	
	Geo(Redis3.2开始引入)：存储数据元素的地理位置（经度、纬度）
	geoadd restaurants:CA -121.896321 37.916750 "Olive Graden" -117.910937 33.804047 "PF Chang's"
		#添加元素及元素的地理坐标
	geopos restaurants:CA "PF Chang's"	#查询元素的地理坐标
	georadius restaurants:CA -121.896310 37.916740 5 km  #返回指定坐标5km距离范围内的元素
	geodist restaurants:CA "Olive Graden" "PF Chang's" km #返回元素之间的距离，单位km
	georadiusbymember restaurants:CA "Olive Graden" 10 km #返回距离指定元素10km范围内的元素(参数必
须是该集合中的元素，返回结果中会包含参数自己)
	georadius/georadiusbymember restaurants:CA "Olive Graden" 10 km store/storedist neibors 
		#返回结果保存到新集合中
	georadius/georadiusbymember restaurants:CA "Olive Graden" 10 km withdist withcoord 
		#返回元素和距离、坐标
	geo集合实际上是一个有序集合，所以可以对geo集合使用有序集合的命令。
	redis使用一个52位的geohash编码保存geo集合元素的坐标。可以实现低于1m的精度，当然不可能完全准确，
所以保存的坐标和使用geopos返回的坐标有极小的差别。
	
	键管理：
	获取redis中键的个数：dbsize
	返回所有的键：keys * 或 scan 0(遵循scan语法)
	删除键：del key 或 unlink key(Redis4.0引入，用于大key的异步删除)
	判断键是否存在：exists key	
	获取键对应的数据类型：type key	(使用这个命令就可以看出来geo集合就是有序集合)
	重命名键：rename key-old key-new
	使用keys和del都可能导致阻塞，所以对于大数据量的操作建议使用scan和unlink
	
	
		
		
		
		
	
		