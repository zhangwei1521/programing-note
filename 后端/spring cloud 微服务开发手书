							spring cloud 微服务开发手书
第一章 基础知识
	微服务是什么？
	微服务是对单体系统进行分布式改造的一种设计架构模式，通过分布式的多个独立运行的服务进程代替单进程的单体应用，
服务之间使用轻量级的HTTP消息进行通信，每一个服务都只关注一组耦合度较高、业务一致的功能，并且每个服务维护自己的数据
存储、测试以及部署发布。不同的服务可以采用不同的语言进行开发。
	
	单体系统出了问题？
	单体系统随着需求的扩展，变得越来越复杂和臃肿，部署发布也变得耗时麻烦，并且不利于团队协作。
	
	微服务不是万能的：
	多个服务进程的编排会给运维带来新的挑战；服务间调用时接口变动需要保证一致性；分布式系统固有的复杂性：如网络问题、
分布式事务等。
	
	Martin Fowler提出的微服务架构九大特性：
	服务组件化、按业务组织团队、做产品的态度、智能端点和粗粒度的通信、去中心化治理（解耦单一开发平台）、去中心化
管理数据、基础设施自动化（自动化测试、自动化部署）、容错设计、演进式设计。
	
	各种微服务框架都是为了充分利用微服务架构的优点，同时尽可能地解决微服务带来的问题。
	
	为什么是spring cloud？
	spring cloud提供了实施微服务架构的所有框架，spring cloud组合了一批经过充分测试的基础框架（组件），同时提供了
一些新的边缘组件。
	
	spring cloud简介：
	它是一个基于spring boot实现的微服务开发框架工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、
集群状态管理、分布式会话等操作提供了一种简单的开发方式。
	spring cloud包含多个子项目（框架组件）：spring cloud config、 spring cloud netflix等。
	spring cloud的版本：大版本使用伦敦的地铁站名（按字母排序），bug修复版为SRX。例如：Brixton.SR5

	
第二章 spring boot基础
	为什么是spring boot？
	spring cloud 的各个子项目都是使用spring boot进行开发的；同时由于spring boot的快速开发、自动化配置等优秀特性，
在我们自己的项目中，最好也使用它来开发自己的微服务。
	
	spring boot做了什么？
	spring boot提供了大量的自动化配置以代替老式spring工程的样板式配置；spring boot还提供了一系列starter poms
（起步依赖模块）以帮助我们手动维护项目中复杂的依赖关系；spring boot支持嵌入式的web容器，可以很方便的进行容器化部署
发布。
	spring boot工程搭建参考SpringBoot笔记，下面是springboot的配置介绍。
	配置文件存放目录：src/main/resources，默认配置文件是application.properties；除了properties文件外，也可以使用yml
格式文件。yml文件的一个好处是可以在一个yml文件中通过spring.profiles属性来指定多个不同的环境配置。
另外，yml中定义的属性是有顺序的。
	自定义参数：配置文件中添加自定义参数，应用组件Bean可以使用@Value("${att_name}")或者@Value("#{att_name}")
注入该参数。在配置文件中可以使用${att_name}引用配置文件中定义的参数。配置文件中还可以使用${random}生成随机值：
	${random.value} #随机字符串
	${random.int} #随机int
	${random.long} #随机long
	${random.int(10)} #10以内的随机整数
	${random.int[10,20]} #10到20的随机整数
	
	命令行运行jar包添加参数： java -jar xxx.jar --server.port=8088
	多环境配置：创建多个不同环境的配置文件，命名格式：application-{profile}.properties；在主配置文件application.properties
中使用属性：spring.profiles.active={profile}指定使用哪个环境的配置文件。
	springboot加载配置属性顺序问题：
	1.命令行参数->2.操作系统环境变量->3.当前应用jar包外部的application-{profile}文件->4.当前应用jar包内部的application-{profile}文件
->5.当前应用jar包外部的application文件->6.当前应用jar包内部的application文件->7.@Configuration注解修饰类中@propertySource
修饰的属性变量值->8.springboot默认属性值。（其中有一些不常用的配置方式没有列出）。
	第3项和第5项表明可以使用jar包外部的配置文件来取代jar包内部的配置。
	微服务架构下需要收集微服务应用的各项指标情况，根据这些指标信息制定监控和预警规则。所以每一个微服务应用都需要有一套
提供应用指标信息的接口，而使用springboot构建的微服务应用可以使用spring-boot-starter-actuator实现这一套接口。
	spring-boot-starter-actuator提供的原生端点可以分为三种类型：
	应用配置类：应用配置、环境变量、自动化配置等信息；
	/autoconfig: 获取应用的自动化配置信息
	/beans:	获取应用上下文创建的所有bean
	/configprops: 获取应用中配置的属性信息（看起来像是配置端点的）
	/env: 获取应用所有可用的环境属性：包括配置文件中配置的属性、环境变量、JVM属性、命令行参数等
	/mapping: 返回springMVC的控制器映射关系信息，包括处理器映射器和实际处理方法等
	/info: 返回配置文件中以info开头的自定义属性
	
	度量指标类：内存信息、线程池信息、http请求统计信息等；
	/metrics: 获取应用的运行时信息，包括内存使用情况、线程信息、处理器信息、http会话信息等，可以使用/metrics/{name}获取
具体某一方面的信息
	/health: 应用的健康指标，主要是磁盘空间占用、数据源是否可用等信息
	/dump: 返回运行中的线程信息
	/trace: 返回跟踪的最近100条http请求和响应信息
	
	操作控制类：关闭应用等操作接口
	操作控制类端点默认是不启用的，需要配置：endpoints.shutdown.enabled=true(原生端点只提供了shutdown端点来关闭应用)

第三章 Eureka
	spring社区基于Netflix Eureka进行了封装，负责spring cloud微服务架构中的服务治理工作（微服务实例的自动注册和发现）。
当微服务数量太多的时候，静态配置、手动维护变得非常困难和麻烦，服务治理框架的解决方案是使用服务端注册中心统一登记服务
实例，服务实例则使用服务治理客户端向注册中心登记自己，同时也使用客户端作为服务发现组件，实现服务间的调用。客户端以
心跳的方式向注册中心报告服务实例的状态，注册中心可以据此排除不可用的服务实例。
	使用客户端服务发现可以基于服务名进行，从而和服务提供者的具体位置解耦，还可以使用负载均衡（使用其他组件实现）。
	服务注册中心的搭建：
	新建springboot工程：eureka-server
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka-server</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-dependencies</artifactId>
					<version>Brixton.SR5</version>
					<type>pom</type>
					<scope>import</scope>
				</dependency>
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableEurekaServer
	修改配置文件application.properties:
		server.port=1111
		eureka.instance.hostname=localhost
		#下面两行配置目的是不向自己注册自己
		eureka.client.register-with-eureka=false  
		eureka.client.fetch-registry=false
		#配置注册中心的地址（客户端配置）
		eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/
	
	启动eureka-server就可以通过http://localhost:1111/查看注册中心了。
	
	服务实例的注册和发现：
	新建springboot工程：hello-sevice
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-test</artifactId>
				<scope>test</scope>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<!-- 同上-->
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableDiscoveryClient
	Controller中注入DiscovertyClient:
		@Autowired
		private DiscoveryClient discoveryClient;
	使用DiscoverryClient：
		@RequestMapping(value="/hello", method=RequestMethod.GET)
		public String hello(){
			ServiceInstance instance = discovertyClient.getLocalServiceInstance();
			String host = instance.getHost();
			String id = instance.getServiceId();
			return "hello";
		}		
	修改配置文件application.properties:
		spring.application.name=hello-service
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
	
	高可用注册中心：服务注册中心非常重要，因此需要考虑故障的应对方法，Eureka server的设计考虑到了这一点，提供了服务
注册中心互相注册的机制，通过这种互相注册实现服务清单的互相同步。
	构建一个双节点的服务注册中心集群：
	为前面的服务注册中心工程 eureka-server 添加两个配置文件：application-peer1.properties和application-peer2.properties:
	application-peer1.properties
		spring.application.name=eureka-server
		server.port=1111
		eureka.instance.hostname=peer1
		eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/
	application-peer2.properties
		spring.application.name=eureka-server
		server.port=1112
		eureka.instance.hostname=peer2
		eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/
	修改host文件：
		127.0.0.1 peer1
		127.0.0.1 peer2
	分别启动两个eureka-server：
		java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1
		java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2
	注册hello-service到eureka-server集群上：修改hello-service配置文件：application.properties
		spring.application.name=hello-service
		eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/
	使用IP地址而不是主机名作为eureka服务注册中心的地址：添加配置项：
		eureka.instance.prefer-ip-address=true  
	
	使用Ribbon进行客户端负载均衡消费服务：
	将hello-service在两个端口启动，向注册中心注册两个hello-service服务：
		java -jar hello-sevice-0.0.1-SNAPSHOT.jar --server.port=8081
		java -jar hello-sevice-0.0.1-SNAPSHOT.jar --server.port=8082
	新建一个服务消费者项目：ribbon-consumer：
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-ribbon</artifactId>
				<scope>test</scope>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<!-- 同上-->
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：@EnableDiscoveryClient
	声明RestTemplate类型的bean,使用@LoadBalanced注解开启客户端负载均衡：
		@Bean
		@LoadBalanced
		RestTemplate restTemplate(){
			return new RestTemplate();
		}
	服务消费，使用hello-service服务：
		String hello = restTemplate.getForEntity("http://HELLO-SERVICE/hello",String.class).getBody();
	修改配置文件application：
		spring.application.name=ribbon-consumer
		server.port=9000
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
	Ribbon使用轮询的方式交替访问可用的服务，实现负载均衡
	
	Eureka服务治理基础架构的三个核心要素：服务注册中心、服务提供者、服务消费者
	服务治理机制：
	服务注册：服务提供者在启动时就会将自己的信息通过请求发送给服务注册中心，服务注册中心使用一个双层Map结构保存
服务实例信息，第一层key值是服务名，第二层key值是服务实例名。如果在启动时不希望注册服务到注册中心，可以使用如下配置：
		eureka.client.register-with-eureka=false  //该值默认为true
	服务同步：在高可用注册中心集群中，当服务提供者发送注册请求到一个注册中心时，该注册中心将会把这个注册请求转发给
集群内与之相连的其他注册中心，从而实现服务注册中心间服务清单的同步。
	服务续约：注册服务后，服务提供者会维护一个心跳向注册中心持续地报告自身状态。注册中心使用两个属性来确定客户端发送
心跳的间隔时间和服务失效时间：
		eureka.instance.lease-renewal-interval-in-seconds=30
		eureka.instance.lease-expiration-duration-in-seconds=90
	服务消费者：服务消费者启动的时候会向注册中心发送一个请求以获取注册中心注册的服务清单，注册中心（Eureka Server）会
维护一份只读的服务清单返回给客户端，并且30秒更新一次该清单。要从注册中心获取服务清单必须确保:
		eureka.client.fetch-registry=true
	客户端使用属性：
		eureka.client.registry-fetch-interval-seconds
	的值（默认为30秒）更新缓存的服务清单。
	服务调用：Eureka使用Region和Zone的概念划分服务分组，一个Region中可以包含多个Zone，每个客户端被注册到一个zone，因此
一个客户端对应一个Zone和一个Region，服务调用时优先访问同一个zone的服务提供者，找不到再访问同一个Region的服务提供者。
	服务下线：当服务实例正常关闭时，会向注册中心发送一个请求告知下线，注册中心将该服务设置为下线，并传播该事件。
	失效剔除：注册中心(Eureka Server)在启动时会创建一个定时任务，每隔一段时间（默认60秒）检测服务清单，将超时（默认90秒）
没有续约的服务剔除。通常是服务实例非正常结束（内存溢出等）导致注册中心进行失效剔除。
	自我保护：注册中心运行时统计每个服务实例在15分钟内心跳失败的比例，如果高于85%，注册中心就保护当前实例，这样这个服务
实例就不会过期被剔除，但是这样可能会造成客户端拿到的服务实例是不可用的，这需要服务消费者自己去实现容错处理。通常本地调试
容易触发自我保护，实际环境通常是网络不稳定触发自我保护。注册中心使用属性
		eureka.server.enable-self-preservation=false
关闭自我保护机制。
	设置Region属性：eureka.client.region=? #定义发现哪个region的服务
	设置zone属性：  eureka.client.availability-zones=?,?  #定义发现哪些zone的服务
	Region默认值为default，Zone默认值为defaultZone
	@EnableDiscoveryClient注解用于开启DiscoveryClient的实例，使用eureka客户端就是创建DiscoveryClient的实现类EurekaDiscoveryClient
的实例对象，该对象使用netflix的DiscoveryClient对象完成服务注册和发现。
	客户端配置：eureka.client作为前缀
	指定注册中心：eureka.client.serviceUrl.defaultZone = http://localhost:1111/eureka/ #默认值为http://localhost:8761/eureka/
				  eureka.client.serviceUrl.defaultZone = http://<username>:<password>@localhost:1111/eureka/ #添加安全校验
	启用客户端：  eureka.client.enabled = true #默认为true
	启用过滤：	  eureka.client.filterOnlyUpInstances = true  #默认为true
	...
	服务实例配置：eureka.intance作为前缀
	实例名配置：  eureka.intance.instanceId = ${spring.application.name}:${random.int}
	实例所属zone：eureka.intance.metadataMap.zone=guangzhou
	通常微服务实例需要使用spring-boot-starter-actuator提供应用运行状态数据，eureka注册中心默认使用/info端点作为服务实例状态页接口，
当开启了healthCheck后使用/health端点作为作为健康检查接口。如果应用设置了context-path，则actuator端点会添加一个前缀，需要修改/info
端点和/health端点配置：
	management.context-path = /hello
	eureka.instance.statusPageUrlPath = ${management.context-path}/info
	eureka.instance.healthCheckUrlPath = ${management.context-path}/health
	修改端点路径：
	endpoints.info = /appInfo
	eureka.instance.statusPageUrlPath = ${endpoints.info}
	eureka注册中心使用http暴露服务实例的端点，如果实例端点实际使用https暴露端点，需要配置绝对路径：
	eureka.instance.statusPageUrl = https://${eureka.instance.hostname}/info
	开启健康检查：
	eureka.client.healthcheck = true
	eureka.instance.appname = hello #默认使用spring.application.name
	配置随机端口号：server.port = 0 或 server.port = ${random.int[10000,19999]}

第四章 Ribbon
	Spring Cloud Ribbon是一个工具类框架，由于微服务间的调用和网关转发请求几乎都会使用Ribbon，因此Ribbon几乎存在于所有微服务和基础构件中。
	服务端负载均衡：通过硬件或者软件模块根据可用服务清单分发请求，并通过心跳方式更新服务清单。
	客户端负载均衡：客户端从注册中心获取所使用的服务清单，也通过心跳从注册中心更新该清单。Eureka、Consul都整合了Ribbon相关功能，可以和
客户端Ribbon配合提供服务清单。服务提供者不需要关心具体的负载均衡方式，只需要提供可用服务实例，服务消费者只需要引入Ribbon依赖，使用
@LoadBalanced修饰的RestTemplate来调用服务。
	RestTemplate使用：
	GET请求：
		  <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, ...urlVirable)	//ResponseEntity封装了请求响应，如 
HttpStatus 等，其父类是 HttpEntity，T getBody()方法将根据第二个参数T.class返回给定类型数据(对象)。
重载方法：<T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> urlVariables)
		  <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType)
使用:     ResponseEntity<String> result = restTemplate.getForEntity("http://HELLO-SERVICE/hello2?name={1}",String.class,"hello");
		  String hello = result.getBody();
	
		  <T> T getForObject(String url, Class<T> responseType, Object... urlVariables)   //相当于直接返回getForEntity返回值ResponseEntity 的body部分
重载方法：<T> T getForObject(String url, Class<T> responseType, Map<String, ?> urlVariables)
		  <T> T getForObject(URI url, Class<T> responseType)
	
	POST请求：
		  <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Object... uriVariables)
重载方法：<T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables)
		  <T> ResponseEntity<T> postForEntity(URI url, Object request, Class<T> responseType)
		  
		  <T> T postForObject(String url, Object request, Class<T> responseType, Object... uriVariables)
重载方法：<T> T postForObject(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables)
		  <T> T postForObject(URI url, Object request, Class<T> responseType)
		
	PUT请求：
		  void put(String url, Object request, Object... urlVariables)
重载方法：void put(String url, Object request, Map<String, ?> urlVariables)
		  put(URI url, Object request)
		  
	DELETE请求：
		void delete(String url, Object... urlVariables)
		void delete(String url, Map<String, ?> urlVariables)
		void delete(URI url)
	自动化配置：Ribbon使用一系列接口来定义客户端负载均衡的配置，这些接口具有多种不同的实现，但引入Ribbon后可以直接使用
它的自动默认配置。
	IClientConfig接口：客户端配置；IRule接口：负载均衡策略配置；IPing接口：实例检查策略；ILoadBalancer：负载均衡器
	自定义配置的方式：一种方式是配置上面这些接口的实现bean，另一种是Camden版本开始可以使用的在配置文件中指定接口的实现类。
配置bean：
		@SpringBootApplication
		@RibbonClient(name = "my-provider", configuration = MyRibbonConfig.class)
		//MyRibbonConfig类不能放在可被默认包扫描策略扫描到的地方，如果要放在一个被扫描到的位置，需要使用@ComponentScan的
		//excludeFilters 排除：@ExcudeAnnotation是自定义标记空注解
		//@ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, value = {ExcudeAnnotation.class})})
		public class HelloSeviceApplication {
			@Bean
			@LoadBalanced
			public RestTemplate restTemplate() {
				return new RestTemplate();
			}
			...
		}
		
		@Configuration
		@ExcudeAnnotation
		public class MyRibbonConfig {
			@Bean
			public IRule ribbonRule() {
				return new RandomRule();
			}
		}
配置文件配置接口实现类：
		#全局配置:
		ribbon.ConnectTimeout=250
		#指定服务名:
		my-provider.ribbon.NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule
		#不使用eureka维护ribbon的服务实例：
		ribbon.eureka.enabled=false
		my-provider.ribbon.listOfServers=localhost:8001,localhost:8002
	跨区域容错配置：可以将实际位于A区的服务配置为B区的服务，这是因为Ribbon默认是使用区域亲和策略的，如果B区实际部署的
服务都不可用，仍然可以使用那些不在B区但是配置zone为B区的服务：
		eureka.intance.metadataMap.zone=guangzhou
	服务治理的CAP原理：C——一致性	A——可用性	P——可靠性
	eureka强调AP，而zookeeper强调CP。由于eureka强调AP特性，可能导致ribbon获得的服务实例是不可用的，比如触发eureka对某个
服务的保护机制。spring cloud从Camden版本开始整合了Retry功能，可以配置ribbon的重试特性：
		#开启重试机制
		spring.cloud.loadbalancer.retry.enabled=true
		hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
		#请求连接的超时时间
		my-provider.ribbon.ConnectTimeout=250
		#请求处理的超时时间
		my-provider.ribbon.ReadTimeout=1000
		#对所有请求都进行重试
		my-provider.ribbon.okToRetryAllOperations=true
		#切换实例的次数（不包含当前实例）
		my-provider.ribbon.maxAutoRetriesNextServers=2
		#对当前实例的重试次数（不包含第一次）
		my-provider.ribbon.maxAutoRetries=1
	
	Ribbon依赖：
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-ribbon</artifactId>
		</dependency>
	其实 spring-cloud-starter-eureka 已经包含了ribbon依赖，所以不需要再单独引入ribbon
	使用 LoadBalancerClient 获取服务实例：
		loadbalancerClient.choose("virtual-host-name");
	这里的虚拟主机名默认和服务名是一致的，但是可以通过以下配置修改：
		eureka.instance.virtual-host-name 或 eureka.instance.secure-virtual-host-name
	配置了loadbalenced的restTemplate.getForEntity 方法不能和loadbalancerClient.choose
在同一个方法中调用，二者会发生冲突
	
第五章 Hystrix
	高负载的问题：如果服务提供者响应的时间太久，消费者就会一直等待直到响应或超时，每一次
服务调用通常对应着一个线程或进程，也就是占用着一部分系统资源，一直等待使得系统资源得不到
释放，如果有更多的请求到来就会导致资源耗尽，服务变得不可用。这种由于服务提供者故障导致服
务消费者也变得不可用的现象称为“雪崩效应”
	要防止雪崩效应，服务调用就需要具有容错能力，表现为两个方面：一是为网络请求设置超时时间，
二是提高断路支持（断路器）。
	设置超时可以让发送请求占用的资源及时得到释放，断路器可以实现快速失败，从而不再浪费CPU
时间去等待不可用的服务调用。断路器还需要提供自动恢复功能，在调用的服务恢复后关闭断路器。
	断路器的状态转换：
	断路器关闭（依赖服务正常）-->断路器打开（失败率达到阈值）-->半开状态（允许一个请求去调用
依赖服务进行测试，如果成功就关闭断路器，否则打开断路器）==>关闭断路器/打开断路器
	Hystrix提供的功能包括：包裹请求（HystrixCommand命令包裹服务调用逻辑，在独立线程中执行）、
跳闸机制（断路）、资源隔离（每个依赖提供一个线程池，当线程池满后后来的服务调用请求就直接失败）、
监控、回退、自我修复。
	基本用法：
	服务端调用方添加依赖：
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-hystrix</artifactId>
		</dependency>	
	启动类添加注解：
		@EnableCircuitBreaker
	调用其它服务的方法添加注解：
		@HystrixCommand(fallbackMethod = "callFallBack")
	回调方法：
		public String callFallBack(){
			return "service error";
		}
	@HystrixCommand的配置：
	@HystrixCommand(fallbackMethod = "callFallBack",commandProperties={
		//单次服务调用超时时间
		@HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="5000"),
		//设置统计的滚动窗口的时间段大小（统计窗口刷新时间间隔）
		@HystrixProperty(name="metric.rollingStats.timeoutInMilliseconds",value="10000"),//
	},threadPoolProperties={
		//线程池大小
		@HystrixProperty(name="coreSize",value="10"),
		//排队等待发起请求的队列大小
		@HystrixProperty(name="maxQueueSize",value="10")
	})
	单次请求失败、超时、被拒绝在断路器打开时也是会调用回退方法的。
	Hystrix默认阈值是50秒20请求失败。
	结合springboot的actuator可以在health端点查看hystrix的状态。
	Hystrix的隔离策略：THREAD(新开一个线程来使用HystrixCommand进行服务调用，并发量受线程池大小限制)、
SEMAPHORE(信号量，在原服务请求线程上进行服务调用)，默认使用THREAD
	Spring Cloud默认为feign集成了Hystrix，只有Hystrix在项目的classpath下，feign默认就会启用
HystrixCommand.
	为feign客户端添加回退方法：
		@FeignClient(name="hello-service",fallback=FeignClientFallback.class)
		public interface HelloFeignClient {
			@RequestMapping("/hello")
			public String callHello();
		}
		
		@Component
		class FeignClientFallback implements HelloFeignClient{
			public String callHello(){
				return "feign fallback";
			}
		}
	使用@FeignClient的fallbackFactory属性查看回退原因:
	@FeignClient(name="hello-service",fallback=FeignClientFallbackFactory.class)
	
	class FeignClientFallbackFactory implements FallbackFactory<HelloFeignClient>{
		@Override
		public HelloFeignClient create(Throwable cause){
			return new HelloFeignClient(){
				@Override
				public String callHello(){
					System.out.println("reason of fallback: "+cause);
					return cause.toString;
				}
			}
		}
	}
	为feign禁用hystrix:feign配置类配置feignBuilder的bean：
		@Configuration
		public class HelloFeignConfig {
			@Bean
			@Scope("prototype")
			public Feign.Builder feignBuilder(){
				return Feign.builder();
			}
		}
	全局禁用hystrix:
		feign.hystrix.enabled=false
	
	HystrixCommand在执行时会记录执行结果和运行指标，如每秒请求数、请求成功数等，这些数据可用于分析
系统状态。Hystrix模块hystrix-metrix-event-stream可以以text/event-stream的格式暴露上述信息。通过
actuator的hystrix.stream端点可以获取这些信息。
	使用Hystrix Dashboard显示hystrix统计信息：
	Hystrix Dashboard依赖：
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
		</dependency>
	启动类上添加注解：@EnableHystrixDashboard
	指定启动端口：server.port=8030
	访问：localhost:9030/hystrix 就可以看到hystrix dashboard
	在 hystrix-dashboard主页输入服务调用方的hystrix端点路径：localhost:9001/hystrix.stream,设置
title为任意值，点击monitor stream查看端点提供的hystrix信息
	使用turbine监控多个微服务：
	turbine工程依赖：
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-turbine</artifactId>
		</dependency>
	启动类上添加注解：@EnableTurbine
	配置文件：
		server.port=8031
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
		turbine.appConfig=feign-consumer,ribbon-consumer
		turbine.clusterNameExpression="'default'"
	在hystrix-dashboard主页输入turbine的路径：http://localhost:8031/turbine.stream
	除了这种直接通过配置服务名的方式收集监控信息外，还可以引入消息中间件，让hystrix将收集的信息作为
消息发送给消息中间件，turbine再从消息中间件获取这些信息。
	
		
第六章 Feign
	Feign是netflix开源的HTTP客户端，具有声明式、模板化的特点。使用Feign可以实现方便、优雅地调用服务。
	Spring Cloud 对原生的Feign进行了增强，添加了对Spring MVC注解的支持，同时整合了Eureak和Ribbon。
	Feign依赖：
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-feign</artifactId>
		</dependency>	
	客户端Feign接口：
		@FeignClient(name="hello-service")
		public interface HelloFeignClient {
			@RequestMapping("/hello")
			public String callHello();
		}
	@FeignClient注解的name属性值是一个服务名，用来创建ribbon负载均衡器。还可以再添加一个属性url，直接
指定服务的地址。
	启动类添加注解：@EnableFeignClients
	调用类中注入feign客户端：
		@Autowired
		private HelloFeignClient helloFeignClient;
	feign使用默认配置创建客户端接口的实现，可以通过自定义配置修改feign客户端的行为：
	自定义feign配置类：
		@Configuration
		public class HelloFeignConfig {
			@Bean
			public BasicAuthRequestInterceptor basicAuthRequestInterceptor(){	
				//如果服务调用需要BasicAuth认证，就在这里配置用户名和密码
				return new BasicAuthRequestInterceptor("user","password");
			}
			
			@Bean
			public Contract feignContract(){	
				//配置使用feign原生注解
				return new feign.Contract.Default();
			}
		}
	在feign客户端接口中引入配置类：
		@FeignClient(name="hello-service",configuration = HelloFeignConfig.class)
		public interface HelloFeignClient {
			@RequestMapping("/hello")
			public String callHello();
		}
	这里的feign配置类HelloFeignConfig不能放在@ComponentScan扫描到的地方，否则会被应用到所有的feign客户端
	Feign还支持使用Feign Builder API来手动创建Feign客户端，这种方式可以灵活地控制feign客户端的行为：
	将启动类上的@EnableFeignClients注解去掉，然后去掉feign客户端接口的@FeignClient注解，
	在服务调用者控制器上添加注解：@Import(FeignClientsConfiguration.class)	//引入feign默认配置类
	将服务调用者控制器中的feign客户端接口注入改为构造方法注入：
		@Autowired
		public FeignConsumerController(Decoder decoder, Encoder encoder, Client client, Contract contract){
			this.helloFeignClient = Feign.builder().client(client).encoder(encoder).decoder(decoder).
					contract(contract).requestInterceptor(new BasicAuthRequestInterceptor("user","password")).
					target(HelloFeignClient.class,"http://hello-service/");
		}
	Decoder等是feign包下的API
	Feign使用继承：
	服务提供者定义接口：
		public interface UserService{
			@RequestMapping(value="/user/{id}",Method=RequestMethod.GET)
			User getUser(@PathVariable("id") long id);
		}
	服务提供者实现接口：
		@RestController
		public class UserServiceImpl implements UserService{
			...
		}
	服务调用者的feign客户端继承接口：
		@FeignClient("user-service")
		public interface UserFeignClient extends UserService{}
	这种方式的好处是简化开发，问题在于造成了服务消费者依赖了服务提供者，即代码的耦合。是否使用这种
方式，需要结合具体场景来考虑。
	feign对压缩的支持：
	#压缩请求：
	feign.compression.request.enabled=true
	#指定支持的媒体类型
	feign.compression.request.mime-types=text/xml,application/xml,application/json
	#指定开启请求压缩的最小值
	feign.compression.request.min-request-size=2048
	让feign打印日志：
	在feign配置类：HelloFeignConfig 中新增一个bean：
		@Bean
		Logger.Level feignLoggerLevel(){
			return Logger.Level.FULL;
		}
	配置文件添加日志级别：
		logging.level.com.zhangwei.feignconsumer.service.HelloFeignClient=DEBUG
	这里日志级别可选的值有：NONE(不记录日志)、BASIC(记录请求响应简单说明)、HEADERS(记录请求响应头)、FULL(全记录)
	Feign客户端传递多参数：
	如果是 GET 方法调用，多参数需要都写出来或使用map：
		@RequestMapping(value="/user",method=RequestMethod.GET)
		public User getUser(@RequestParam("name") String name, @RequestParam("age") int age);
		或
		@RequestMapping(value="/user",method=RequestMethod.GET)
		public User getUser(@RequestParam Map<String,Object> param);
	POST请求可以直接使用@RequestBody传递对象
	










	