													jvm 学习
	第一章 内存分区

	执行一个 java 程序时，实际上是启动一个 jvm 进程，这个 jvm 进程向操作系统申请一块内存空间，然后将申请的内存分为两大部分，一部分留给虚拟机自己使用，
另一部分用于用户线程的执行。
	根据 jvm 规范，分配给用户线程的内存可以分为 5 大块，分别是：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中 程序计数器、虚拟机栈、本地方法栈
都是线程私有的，堆和方法区是线程共享。
	程序计数器(PC)保存下一条待执行的字节码指令地址，如果有多个用户线程，虚拟机就会为每个线程创建一个程序计数器，所以也可以称其为线程计数器。jmv 根据
自己(配置)的规则决定在某时刻选择某个线程的程序计数器指向的指令执行。程序计数器不会发生 OutOfMemoryError。
	每一个用户线程开始执行时，虚拟机就会创建一个虚拟机栈（可以称为线程栈），线程执行时每进入一个方法，虚拟机就创建一个栈帧并压入虚拟机栈，栈帧中保存方法执
行时的局部变量，包括基本数据类型、对象引用等。方法执行结束退出后，这个方法的栈帧就被弹出虚拟机栈。如果虚拟机栈的大小是不能动态增加的，就有可能会发生 
StackOverflowError，如果虚拟机栈的大小可以动态增加，当所能使用的内存空间用完后，就会发生 OutOfMemoryError。
	本地方法栈和虚拟机栈类似，只不过它是用来保存本地方法调用时的数据，每次调用本地方法虚拟机就创建一个栈帧并压入本地方法栈。这个内存区也可能发生栈溢出
（StackOverflowError）和内存溢出（OutOfMemoryError）。HotSpot虚拟机将本地方法栈和虚拟机栈放在一起管理。
	堆是虚拟机保存对象、数组的内存区，每次执行 new 操作（或 clone、反序列化）创建对象时，虚拟机就在堆空间分配一块空间用来保存对象数据，这个对象空间可
分为三部分，第一部分是对象头，保存一些元信息，如对象的哈希值等，第二部分是实例数据区，保存对象的字段数据，最后一部分是填充区，因为虚拟机要求每个对象空间
大小必须是8字节的整数倍，对象头部分通常是8个字节，而实例数据区可能不是8字节的整数倍，所以需要填充区来补齐空间。创建对象后对象的初始数据会被设置为默认值，
然后才根据用户代码设置对象字段的值。在堆空间中创建对象，可以设置根据线程先创建线程对象块，然后在线程对象块内创建对象，也可以设置不创建线程对象块，这样就
需要同步创建对象的操作。堆是进程垃圾回收的主要作用区，堆一般都被设计为可扩展的，但如果可能内存被用完，就会发生 OutOfMemoryError。
	方法区保存加载的类的信息（字段、方法等）、字节码指令、运行时常量池等。方法区可以进行垃圾回收，也可以不进行，jvm 规范没有明确规定，但是卸载掉不使用的
类通常有助于改善程序性能。方法区内存用完且不能再分配时将抛出 OutOfMemoryError。
	直接内存不属于虚拟机规范的内容，但是在NIO中，通过Channel和Buffer进行IO操作时，就会通过 native 函数库分配一块堆外内存，堆空间中的 DirectByteBuffer
对象直接引用这块堆外内存，所以可以通过操作 DirectByteBuffer 对象操作堆外内存提高性能。如果请求的直接内存不能被分配，就会抛出 OutOfMemoryError。
