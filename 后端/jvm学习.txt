													jvm 学习
	第一章 内存分区

	执行一个 java 程序时，实际上是启动一个 jvm 进程，这个 jvm 进程向操作系统申请一块内存空间，然后将申请的内存分为两大部分，一部分留给虚拟机自己使用，
另一部分用于用户线程的执行。
	根据 jvm 规范，分配给用户线程的内存可以分为 5 大块，分别是：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中 程序计数器、虚拟机栈、本地方法栈
都是线程私有的，堆和方法区是线程共享。
	程序计数器(PC)保存下一条待执行的字节码指令地址，如果有多个用户线程，虚拟机就会为每个线程创建一个程序计数器，所以也可以称其为线程计数器。jmv 根据
自己(配置)的规则决定在某时刻选择某个线程的程序计数器指向的指令执行。程序计数器不会发生 OutOfMemoryError。
	每一个用户线程开始执行时，虚拟机就会创建一个虚拟机栈（可以称为线程栈），线程执行时每进入一个方法，虚拟机就创建一个栈帧并压入虚拟机栈，栈帧中保存方法执
行时的局部变量，包括基本数据类型、对象引用等。方法执行结束退出后，这个方法的栈帧就被弹出虚拟机栈。如果虚拟机栈的大小是不能动态增加的，就有可能会发生 
StackOverflowError，如果虚拟机栈的大小可以动态增加，当所能使用的内存空间用完后，就会发生 OutOfMemoryError。
	本地方法栈和虚拟机栈类似，只不过它是用来保存本地方法调用时的数据，每次调用本地方法虚拟机就创建一个栈帧并压入本地方法栈。这个内存区也可能发生栈溢出
（StackOverflowError）和内存溢出（OutOfMemoryError）。HotSpot虚拟机将本地方法栈和虚拟机栈放在一起管理。
	堆是虚拟机保存对象、数组的内存区，每次执行 new 操作（或 clone、反序列化）创建对象时，虚拟机就在堆空间分配一块空间用来保存对象数据，这个对象空间可
分为三部分，第一部分是对象头，保存一些元信息，如对象的哈希值等，第二部分是实例数据区，保存对象的字段数据，最后一部分是填充区，因为虚拟机要求每个对象空间
大小必须是8字节的整数倍，对象头部分通常是8个字节，而实例数据区可能不是8字节的整数倍，所以需要填充区来补齐空间。创建对象后对象的初始数据会被设置为默认值，
然后才根据用户代码设置对象字段的值。在堆空间中创建对象，可以设置根据线程先创建线程对象块，然后在线程对象块内创建对象，也可以设置不创建线程对象块，这样就
需要同步创建对象的操作。堆是进程垃圾回收的主要作用区，堆一般都被设计为可扩展的，但如果可能内存被用完，就会发生 OutOfMemoryError。
	访问对象：JVM规范没有规定虚拟机栈的reference应该以什么方式去访问引用的对象，目前主流的访问方式有使用句柄和直接指针两种。使用句柄访问实现时，虚拟机
会在堆中创建一个句柄池，虚拟机栈的reference存储句柄池中的句柄的地址，句柄中则保存对象的实例数据和类型数据的具体地址。使用直接指针实现时，reference就直接
保存对象的地址，这时堆中的对象就需要保存对象的类型数据的相关信息。使用句柄的好处在于当堆中对象移动后，只需要修改句柄的实例数据指针，虚拟机栈的reference不
需要修改，使用直接指针则需要在移动对象后修改reference的内容，但是使用直接指针要比使用句柄访问对象的数据更快。Hotspot使用直接指针要访问对象数据。
	方法区保存加载的类的信息（字段、方法等）、字节码指令、运行时常量池等。方法区可以进行垃圾回收，也可以不进行，jvm 规范没有明确规定，但是卸载掉不使用的
类通常有助于改善程序性能。方法区内存用完且不能再分配时将抛出 OutOfMemoryError。JDK 1.8 之前 hotspot将方法区实现为堆空间中的永久代。JDK 1.8 用元数据空间
代替了永久代，元数据空间是一个与堆不相连的本地内存区域，元空间的最大可分配空间理论上就是系统可用的内存空间，同时对元数据空间的管理独立于 JVM 对堆的管理
（不再依赖不同的 GC 算法）。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起
就是 JVM 的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。
	直接内存不属于虚拟机规范的内容，但是在NIO中，通过Channel和Buffer进行IO操作时，就会通过 native 函数库分配一块堆外内存，堆空间中的 DirectByteBuffer
对象直接引用这块堆外内存，所以可以通过操作 DirectByteBuffer 对象操作堆外内存提高性能。如果请求的直接内存不能被分配，就会抛出 OutOfMemoryError。
	虚拟机参数设置：
		java -Xmx100M -Xms50M -Xmn30M -Xss128k -XX:NewRatio=2 -XX:+UseSerialGC Demo1
		java -jar -Xmx1024M -Xms1024M -Xmn512M -XX:SurvivorRatio=8 Demo2.jar
	参数：
		-Xmx100M	//设置堆最大内存为100MB
		-Xms50M		//设置堆初始内存为50MB
		-Xmn30M		//设置堆中新生代内存为30MB
		-Xss128k	//设置每个用户线程的虚拟机栈大小为128KB
		-XX:NewRatio=2			//设置新生代和老年代空间占比为1:2
		-XX:SurvivorRatio=8		//设置Survivor块和Eden块空间占比为1:8
		-XX:+UseSerialGC		//设置新生代使用Serial收集器

	第二章 垃圾回收

	虚拟机栈、本地方法栈、程序计数器都是线程私有的内存区，当线程运行结束后这些内存区域就可以被回收了，但是程序运行期间创建的对象位于堆空间中，这些对象可能
不会因为创建它们的线程终止就变为不可用，它们可能会在其他线程中使用，所以不能立即被回收，这就需要虚拟机进行额外的关注，虚拟机需要在适当的时间回收不再被使用
的对象占用的堆内存。方法区保存加载的类的信息，虚拟机可以在程序运行期间回收那些不会再被使用的类占用的空间。
	常见的识别对象不再被使用的方法有两种，一种是引用计数法，另一种是可达性分析法。
	引用计数法是在对象内部设置一个引用计数器，当对象被创建时，引用计数器设为1，对象被其他变量引用时，引用计数器就加一，当引用该对象的某个变量被销毁时，引用
计数器就减一。虚拟机在垃圾回收时间段内检查堆中的对象的引用计数器，回收那些引用计数器值为0的对象。引用计数法的主要问题在于难以处理循环引用，即对象A引用对象B，
对象B也引用对象A，这样即使对象A、B的外部引用都被销毁了，它们的引用计数器仍不为0，这样虚拟机就无法回收它们。所以主流的jvm都不使用引用计数法来实现垃圾回收。
	虚拟机参数：在程序运行时打印垃圾回收信息：
		-verbose:gc -XX:+PrintGCDetails
	可达性分析法是从一组称为 GC Roots 的对象出发向下搜寻其他对象，形成一条条引用链，引用链上的对象是仍在使用的对象，而不在引用链上的对象就是不再使用的对象。
	jvm中的 GC Roots 对象包括以下几种：
			虚拟机栈栈帧本地变量表中引用的对象；
			方法区中静态属性引用的对象；
			方法区中常量引用的对象；
			本地方法栈中本地方法引用的对象
	jvm的可达性分析算法中的两次标记：虚拟机在可达性分析完成后对那些不在所有的引用链上的对象进行第一次标记，然后判断这些对象是否需要执行finalize方法，当对象没有
重写finalize方法或该对象的finalize方法已经执行过，这个对象就是不需要执行finalize方法的对象，可以被虚拟机直接回收。如果对象需要执行finalize方法，这个对象就会被
加入F-Queue队列，稍后虚拟机将启动一个低优先级的线程来执行F队列中对象的finalize方法，但是虚拟机不保证等待这个线程结束后才进行垃圾回收，也就是说当这个线程开启后
GC线程就可能对F队列中的对象进行第二次标记，如果对象在finalize方法中重新将自己加入引用链，这个对象就被移出将被回收的对象名单，否则这个对象将被第二次标记，标记后
GC线程就会回收这个对象。一个对象的finalize只会被执行一次，所以一个将被回收的对象自我拯救的机会只有一次，但是通常不建议使用这个方法，因为这个方法的设计目的不在
于此。
	虚拟机规范不要求必须回收方法区，但是hotspot将方法区实现为堆空间中的永久代，并且支持回收其中的部分空间，主要是不再使用的类和废弃常量。
	回收算法：标记-清除、复制、标记-整理、分代收集。
	主流jvm使用可达性分析来确定对象是否需要被回收，所以上面的回收算法都分为两个过程：标记和回收。标记过程就是可达性分析的两次标记过程，回收策略则有所不同。
	标记-清除算法回收阶段只是简单地将标记为需要回收的对象销毁，这样实现很简单，但是销毁对象并不高效，另一个问题是会产生空间碎片，多次GC后产生了大量的可用空间
碎片，但是没有连续的大空间，如果这时需要创建一个大对象，就会触发一次新的GC，GC结果可能仍不能满足需要，此时却仍有大量可用空间，这样就导致了内存利用效率的降低。
	复制算法中堆空间（通常是新生代）被分为两部分（这两块内存可以不一样大），创建对象总是在其中一块，回收时将存活的对象复制到另一块，然后将原来创建对象的那一块
整体清除。这种算法的问题在于保存对象的空间被人为地减小了，而且复制对象也会产生额外的开销。hotspot在新生代使用复制算法，将新生代空间分为3块：一个Eden块和两个
Survivor块，每次都在Eden和一个Survivor中创建对象，回收时将存活的对象复制到另一个Survivor块中，然后回收前两块，下次创建对象就在保存复制对象的Survivor块和Eden块
中进行。默认配置中，Eden块占新生代的80%，每个Survivor占10%。不管怎么划分复制空间和生产空间，都不能规避一个问题，回收后存活对象需要的空间超过了复制空间的大小。
这种问题通常采用空间分代来解决，hotspot中使用老年代来处理。
	标记-整理算法在回收不可用对象时不是直接清除，而是将存活对象移动到空间的一端，设置一个指针指向移动后存活对象空间的边界，然后清除该指针另一侧的空间。
	分代收集算法不是一种新的回收方式，而是将整个堆空间根据对象的存活周期分为多个块，在各个块采用合适的收集算法。jvm一般将堆空间分为新生代和老年代，新生代采用
复制算法，老年代采用标记-整理算法。
	可达性分析时用户线程必须停止执行，这样引用链才能保持稳定。准确式GC技术使得寻找GC Roots不需要一个一个去搜索方法区和虚拟机栈。hostspot中维护了一个oopMap对象，
在类加载时，类中常量、静态变量的位置就确定了，oopmap就将这些位置保存起来，JIT过程中局部变量表中的引用对象的地址也被保存到oopmap中。虚拟机不会在执行每条指令时都
保存oopmap，而是选择那些可以“让程序较长时间停止”的位置（称为安全点）保存oopmap。GC线程启动后，用户线程会继续执行到最近的安全点才停止，这通常采用主动式中断实现
（GC线程启动后，虚拟机在用户线程的安全点设置一个标记，用户线程执行时去检查这个标记，检测到就中断挂起），另一种方案是抢先式中断，但是几乎没有被使用。线程休眠等
操作时（线程的对象引用关系不会变化），虚拟机将会设置一个标记，GC线程启动后检查到这个标记就可以对这个线程的对象进行GC。
	hotspot中的垃圾收集器：Serial、ParNew、Parallel、Serial Old、Parallel Old、CMS、G1
	Serial是一个古老的单线程收集器，优点是简单高效，缺点是GC时必须停止其他所有工作线程，通常用于client模式下新生代的GC。
	ParNew收集器是Serial的多线程版本，除了使用多线程外，其他特性和Serial基本相同，也用于新生代GC。
	Parallel收集器也是一个新生代多线程收集器，和ParNew不同在于，ParNew（以及其他收集器）关注点在于减少GC期间用户线程的暂停时间，而Parallel则是关注系统吞吐率
（用户代码执行时间/(用户代码执行时间+GC时间)）。Parallel使用以下两个参数控制吞吐率：
		-XX:MaxGCPauseMillis 100	//大于0的毫秒值
		-XX:GCTimeRatio n			//大于0小于100 GC时间占比计算公式：1/(1+n)
	Parallel开启自动调节模式：
		-XX:+UseAdaptiveSizePolicy
	Serial Old是Serial的老年代版本，使用标记-整理算法。
	Parallel Old是Parallel的老年代版本。
	CMS收集器用于老年代的GC，采用标记-清除算法（Concurrent Mark Sweep）。CMS的目标是实现最短回收停顿时间，所以比较适合那些重视服务响应速度的应用。CMS将GC过程分为
4个阶段：初始标记、并发标记、重新标记、并发清除。
	初始标记阶段需要停止用户线程，但是只是标记GC Roots直接关联的对象，所以耗时很短。
	并发标记阶段进行GC Roots Tracing，标记不在引用链上的所有对象，这个阶段不需要停止用户线程。
	重新标记阶段将并发标记阶段用户线程修改的对象重新标记，需要停止用户线程，耗时也不多。
	并发清除阶段清除已标记的对象，不需要停止用户线程。
	CMS收集器GC的4个阶段中只有耗时较短的初始标记和重新标记需要停止用户线程，所以能获得很短的回收停顿时间。
	CMS收集器的问题：并发清除期间可能产生浮动垃圾，需要到下一次GC才能回收；另一个问题是标记-清除算法会导致空间碎片问题。
	CMS收集器虽然可以做到并发回收，但是并发回收也会占用CPU资源，所以仍然存在GC时系统变慢的问题。
	如果老年代使用CMS收集器，新生代就只能使用ParNew收集器。
	G1收集器是一种新的收集器，采用标记-整理算法，而且G1可以管理整个堆内存，也可以在使用分代模型时只管理老年代或新生代的GC。G1可以实现可预测的回收停顿，指定运行时GC
的时间占比。
	G1收集器将堆空间划分为多个大小相等的独立区域，称为Region，GC时不需要再对整个堆进行处理，而是只处理一部分Region。G1跟踪每个Region的垃圾堆积价值（回收空间和时间的
经验值，即历史GC综合值），每次选择回收价值最大的Region进行GC。
	JDK1.8 64位JDK server模式默认使用Parallel作为新生代收集器，默认使用Parallel Old作为老年代收集器。

	jvm运行模式：
	32位虚拟机默认为client模式启动，可以通过修改配置文件（JAVA_HOME/jre/lib/i386/jvm.cfg）和启动参数切换为server模式。
	64位虚拟机默认为server模式启动，不能切换为client模式。配置文件为：JAVA_HOME/jre/lib/amd64/jvm.cfg
	Client模式启动速度较快，Server模式启动较慢。Client模式启动的JVM采用的是轻量级的虚拟机，Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化。
	
	GC日志
		[GC (System.gc()) [PSYoungGen: 22032K->632K(29696K)] 42512K->21120K(98304K), 0.0017566 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[Full GC (System.gc()) [PSYoungGen: 632K->0K(29696K)] [ParOldGen: 20488K->526K(68608K)] 21120K->526K(98304K), 
		[Metaspace: 2692K->2692K(1056768K)], 0.0123980 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
		Heap
		 PSYoungGen      total 29696K, used 22544K [0x00000000fdf00000, 0x0000000100000000, 0x0000000100000000)
		  eden space 25600K, 88% used [0x00000000fdf00000,0x00000000ff504208,0x00000000ff800000)
		  from space 4096K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x0000000100000000)
		  to   space 4096K, 0% used [0x00000000ff800000,0x00000000ff800000,0x00000000ffc00000)
		 ParOldGen       total 68608K, used 20480K [0x00000000f9c00000, 0x00000000fdf00000, 0x00000000fdf00000)
		  object space 68608K, 29% used [0x00000000f9c00000,0x00000000fb000010,0x00000000fdf00000)
		 Metaspace       used 2698K, capacity 4486K, committed 4864K, reserved 1056768K
		  class space    used 297K, capacity 386K, committed 512K, reserved 1048576K
	认识GC日志：
	GC (System.gc())表示这是通过 System.gc()触发的新生代GC，如果是由虚拟机自动触发的GC就没有(System.gc())部分，PSYoungGen表示这是新生代的Parallel收集器工作时打印
的日志，22032K->632K(29696K)表示GC前新生代已用内存为22032K，GC后新生代使用内存为632K，括号里(29696K)表示新生代总内存大小。42512K->21120K(98304K)表示GC前堆空间已使
用大小为42512K，GC后堆空间已使用内存大小为21120K，括号里(98304K)表示堆空间总内存大小。0.0017566 secs表示GC时间，[Times: user=0.00 sys=0.00, real=0.00 secs] 表示GC
过程中用户线程执行时间、GC线程执行时间和总时间。
	Full GC (System.gc())表示这是通过 System.gc()触发的新生代GC时新生代内存不足引发的老年代GC和新生代对象转移到老年代，ParOldGen表示这是Parallel Old收集器工作打印
的日志，20488K->526K(68608K)表示GC前老年代已用内存为20488K，GC后新生代使用内存为526K，括号里(68608K)表示老年代总内存大小。
	Metaspace表示元空间的数据，即方法区（以前的永久代）的GC数据。
	Heap部分详细的输出了堆空间的内存内容，包括新生代的eden区和两个survivor区（from和to），以及老年代和元空间。
	
	ClassLoader
	虚拟机在加载类阶段，使用几种不同的 ClassLoader 加载程序执行需要的类信息，JVM 中内置了三个重要的 ClassLoader，分别是 BootstrapClassLoader、ExtensionClassLoader 和 
AppClassLoader。
	BootstrapClassLoader 负责加载 JVM 运行时核心类，这些类位于 $JAVA_HOME/lib/rt.jar 文件中，java.util.*、java.io.* 等内置类就由BootstrapClassLoader加载。
	ExtensionClassLoader 负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 $JAVA_HOME/lib/ext/*.jar
中，有很多 jar 包。
	AppClassLoader 加载 Classpath 环境变量里定义的路径中的 jar 包和目录。
	jdk 内置一个 URLClassLoader，用于加载位于网络上静态文件服务器提供的 jar 包和 class文件。
	双亲委派：AppClassLoader 在加载一个未知的类名时，首先将这个类名交给父加载器 ExtensionClassLoader 加载，如果 ExtensionClassLoader 可以加载，那么 AppClassLoader 就不
需要自己加载，否则就需要在Classpath查找这个类，能找到就进行加载，否则就抛出异常。ExtensionClassLoader 在加载一个未知的类名时，也是首先将类名交给父加载器 BootstrapClassLoader 
加载，如果BootstrapClassLoader 不能加载，就自己去加载。
	class文件被加载后，jvm根据它构造出对应的 class 对象，这个class对象持有加载它的ClassLoader的引用。但是使用 BootstrapClassLoader 加载的class获取的classLoader引用为null。
	可以通常修改 BootstrapClassLoader 的加载路径，让 BootstrapClassLoader 加载其他的类：
		// /a:表示追加路径到 BootstrapClassLoader 的加载路径
		java -Xbootclasspath/a:d:tem_file VmDemo1


	JVM监控工具：
	jps(Java Virtual Machine Process Status Tool) ： jps主要用来输出JVM中运行的进程状态信息。语法格式如下：
		jps [option] [hostid]		//不指定hostid就默认为当前主机或服务器。
	option有效值：
		-q 不输出类名、Jar名和传入main方法的参数
		-m 输出传入main方法的参数
		-l 输出main类或Jar的全限名
		-v 输出传入JVM的参数
	使用：
		jps -m -l -v
	
	 jstack：主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：
	 	jstack [option] pid
		jstack [option] executable core
		jstack [option] [server-id@]remote-hostname-or-ip
	option有效值：
		-l long listings，打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况
		-m mixed mode，输出Java堆栈信息，同时输出C/C++堆栈信息（比如Native方法）
	使用：
		jstack pid | grep 0xtid
	
	 jmap：用来查看堆内存使用状况，一般结合jhat使用，语法格式如下：
	 	jmap [option] pid
		jmap [option] executable core
		jmap [option] [server-id@]remote-hostname-or-ip
	option有效值：
		-heap 查看进程堆内存使用情况，包括使用的GC收集器、堆配置参数和各代中堆内存使用情况。
		-clstats 打印使用的类加载器信息
		-histo 打印堆内存中的对象数目、大小统计柱状图（列表），-histo:live只打印存活对象数据
		-dump:<option> 把进程内存使用情况dump到文件中
	使用：
		jmap -heap 7544
		jmap -dump:format=b,file=tem_file\dump1.dat 7544
	使用jhat查看dump出来的文件：
		jhat -port 9998 tem_file\dump1.dat
	如果dump文件太大，需要设置较大的可用堆空间：
		jhat -J-Xmx512M -port 9998 tem_file\dump1.dat
	在浏览器中访问9998端口查看dump文件内容。

	jstat：JVM统计监测工具，语法格式：
		jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]
	//vmid是Java虚拟机ID，通常就是进程ID，interval是采样时间间隔。count是采样数目。
	统计GC信息：
		jstat -gc 7544 250 4
		表示每隔250ms采集一次，总共采集4次。
	输出结果(JDK8)：
		  S0C     S1C    S0U    S1U      EC       EU        OC         OU       MC      MU     CCSC   CCSU      YGC   YGCT   FGC      FGCT     GCT
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
	S0C、S1C表示Survivor0和Survivor1区总内存容量，S0U、S1U表示Survivor0和Survivor1区已使用内存容量，EC、EU表示Eden区总内存容量和已使用内存，OC、OU表示老年代
总内存容量和已使用内存，MC、MU表示元空间总内存容量和已使用内存，CCSC、CCSU表示压缩类总内存空间大小和已使用内存，YGC、YGCT表示年轻代垃圾回收次数和消耗时间，FGC、
FGCT表示老年代垃圾回收次数和消耗时间，GCT表示垃圾回收消耗总时间。
	统计类加载:
		jstat -class 7544
	统计编译信息：
		jstat -compiler 7544

	hprof：用于展现CPU使用率，统计堆内存使用情况，语法格式：
		java -agentlib:hprof[=options] ToBeProfiledClass
		java -Xrunprof[:options] ToBeProfiledClass
		javac -J-agentlib:hprof[=options] ToBeProfiledClass
	统计CPU使用信息( CPU Usage Sampling Profiling(cpu=samples))：
		java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello
	//每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，保存在当前目录下。
	CPU Usage Times Profiling(cpu=times)使用字节码注入技术,能够获得更加细粒度的CPU消耗信息:
		javac -J-agentlib:hprof=cpu=times Hello.java































