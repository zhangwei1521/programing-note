													jvm 学习
	第一章 内存分区

	执行一个 java 程序时，实际上是启动一个 jvm 进程，这个 jvm 进程向操作系统申请一块内存空间，然后将申请的内存分为两大部分，一部分留给虚拟机自己使用，
另一部分用于用户线程的执行。
	根据 jvm 规范，分配给用户线程的内存可以分为 5 大块，分别是：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中 程序计数器、虚拟机栈、本地方法栈
都是线程私有的，堆和方法区是线程共享。
	程序计数器(PC)保存下一条待执行的字节码指令地址，如果有多个用户线程，虚拟机就会为每个线程创建一个程序计数器，所以也可以称其为线程计数器。jmv 根据
自己(配置)的规则决定在某时刻选择某个线程的程序计数器指向的指令执行。程序计数器不会发生 OutOfMemoryError。
	每一个用户线程开始执行时，虚拟机就会创建一个虚拟机栈（可以称为线程栈），线程执行时每进入一个方法，虚拟机就创建一个栈帧并压入虚拟机栈，栈帧中保存方法执
行时的局部变量，包括基本数据类型、对象引用等。方法执行结束退出后，这个方法的栈帧就被弹出虚拟机栈。如果虚拟机栈的大小是不能动态增加的，就有可能会发生 
StackOverflowError，如果虚拟机栈的大小可以动态增加，当所能使用的内存空间用完后，就会发生 OutOfMemoryError。
	本地方法栈和虚拟机栈类似，只不过它是用来保存本地方法调用时的数据，每次调用本地方法虚拟机就创建一个栈帧并压入本地方法栈。这个内存区也可能发生栈溢出
（StackOverflowError）和内存溢出（OutOfMemoryError）。HotSpot虚拟机将本地方法栈和虚拟机栈放在一起管理。
	堆是虚拟机保存对象、数组的内存区，每次执行 new 操作（或 clone、反序列化）创建对象时，虚拟机就在堆空间分配一块空间用来保存对象数据，这个对象空间可
分为三部分，第一部分是对象头，保存一些元信息，如对象的哈希值等，第二部分是实例数据区，保存对象的字段数据，最后一部分是填充区，因为虚拟机要求每个对象空间
大小必须是8字节的整数倍，对象头部分通常是8个字节，而实例数据区可能不是8字节的整数倍，所以需要填充区来补齐空间。创建对象后对象的初始数据会被设置为默认值，
然后才根据用户代码设置对象字段的值。在堆空间中创建对象，可以设置根据线程先创建线程对象块，然后在线程对象块内创建对象，也可以设置不创建线程对象块，这样就
需要同步创建对象的操作。堆是进程垃圾回收的主要作用区，堆一般都被设计为可扩展的，但如果可能内存被用完，就会发生 OutOfMemoryError。
	访问对象：JVM规范没有规定虚拟机栈的reference应该以什么方式去访问引用的对象，目前主流的访问方式有使用句柄和直接指针两种。使用句柄访问实现时，虚拟机
会在堆中创建一个句柄池，虚拟机栈的reference存储句柄池中的句柄的地址，句柄中则保存对象的实例数据和类型数据的具体地址。使用直接指针实现时，reference就直接
保存对象的地址，这时堆中的对象就需要保存对象的类型数据的相关信息。使用句柄的好处在于当堆中对象移动后，只需要修改句柄的实例数据指针，虚拟机栈的reference不
需要修改，使用直接指针则需要在移动对象后修改reference的内容，但是使用直接指针要比使用句柄访问对象的数据更快。Hotspot使用直接指针要访问对象数据。
	方法区保存加载的类的信息（字段、方法等）、字节码指令、运行时常量池等。方法区可以进行垃圾回收，也可以不进行，jvm 规范没有明确规定，但是卸载掉不使用的
类通常有助于改善程序性能。方法区内存用完且不能再分配时将抛出 OutOfMemoryError。JDK 1.8 之前 hotspot将方法区实现为堆空间中的永久代。JDK 1.8 用元数据空间
代替了永久代，元数据空间是一个与堆不相连的本地内存区域，元空间的最大可分配空间理论上就是系统可用的内存空间，同时对元数据空间的管理独立于 JVM 对堆的管理
（不再依赖不同的 GC 算法）。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起
就是 JVM 的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。
	直接内存不属于虚拟机规范的内容，但是在NIO中，通过Channel和Buffer进行IO操作时，就会通过 native 函数库分配一块堆外内存，堆空间中的 DirectByteBuffer
对象直接引用这块堆外内存，所以可以通过操作 DirectByteBuffer 对象操作堆外内存提高性能。如果请求的直接内存不能被分配，就会抛出 OutOfMemoryError。
	虚拟机参数设置：
		java -Xmx100M -Xms50M -Xmn30M -Xss128k -XX:NewRatio=2 -XX:+UseSerialGC Demo1
		java -jar -Xmx1024M -Xms1024M -Xmn512M -XX:SurvivorRatio=8 Demo2.jar
	参数：
		-Xmx100M	//设置堆最大内存为100MB
		-Xms50M		//设置堆初始内存为50MB
		-Xmn30M		//设置堆中新生代内存为30MB
		-Xss128k	//设置每个用户线程的虚拟机栈大小为128KB
		-XX:NewRatio=2			//设置新生代和老年代空间占比为1:2
		-XX:SurvivorRatio=8		//设置Survivor块和Eden块空间占比为1:8
		-XX:+UseSerialGC		//设置新生代使用Serial收集器

	第二章 垃圾回收

	虚拟机栈、本地方法栈、程序计数器都是线程私有的内存区，当线程运行结束后这些内存区域就可以被回收了，但是程序运行期间创建的对象位于堆空间中，这些对象可能
不会因为创建它们的线程终止就变为不可用，它们可能会在其他线程中使用，所以不能立即被回收，这就需要虚拟机进行额外的关注，虚拟机需要在适当的时间回收不再被使用
的对象占用的堆内存。方法区保存加载的类的信息，虚拟机可以在程序运行期间回收那些不会再被使用的类占用的空间。
	常见的识别对象不再被使用的方法有两种，一种是引用计数法，另一种是可达性分析法。
	引用计数法是在对象内部设置一个引用计数器，当对象被创建时，引用计数器设为1，对象被其他变量引用时，引用计数器就加一，当引用该对象的某个变量被销毁时，引用
计数器就减一。虚拟机在垃圾回收时间段内检查堆中的对象的引用计数器，回收那些引用计数器值为0的对象。引用计数法的主要问题在于难以处理循环引用，即对象A引用对象B，
对象B也引用对象A，这样即使对象A、B的外部引用都被销毁了，它们的引用计数器仍不为0，这样虚拟机就无法回收它们。所以主流的jvm都不使用引用计数法来实现垃圾回收。
	虚拟机参数：在程序运行时打印垃圾回收信息：
		-verbose:gc -XX:+PrintGCDetails
	可达性分析法是从一组称为 GC Roots 的对象出发向下搜寻其他对象，形成一条条引用链，引用链上的对象是仍在使用的对象，而不在引用链上的对象就是不再使用的对象。
	jvm中的 GC Roots 对象包括以下几种：
			虚拟机栈栈帧本地变量表中引用的对象；
			方法区中静态属性引用的对象；
			方法区中常量引用的对象；
			本地方法栈中本地方法引用的对象
	jvm的可达性分析算法中的两次标记：虚拟机在可达性分析完成后对那些不在所有的引用链上的对象进行第一次标记，然后判断这些对象是否需要执行finalize方法，当对象没有
重写finalize方法或该对象的finalize方法已经执行过，这个对象就是不需要执行finalize方法的对象，可以被虚拟机直接回收。如果对象需要执行finalize方法，这个对象就会被
加入F-Queue队列，稍后虚拟机将启动一个低优先级的线程来执行F队列中对象的finalize方法，但是虚拟机不保证等待这个线程结束后才进行垃圾回收，也就是说当这个线程开启后
GC线程就可能对F队列中的对象进行第二次标记，如果对象在finalize方法中重新将自己加入引用链，这个对象就被移出将被回收的对象名单，否则这个对象将被第二次标记，标记后
GC线程就会回收这个对象。一个对象的finalize只会被执行一次，所以一个将被回收的对象自我拯救的机会只有一次，但是通常不建议使用这个方法，因为这个方法的设计目的不在
于此。
	虚拟机规范不要求必须回收方法区，但是hotspot将方法区实现为堆空间中的永久代，并且支持回收其中的部分空间，主要是不再使用的类和废弃常量。
	回收算法：标记-清除、复制、标记-整理、分代收集。
	主流jvm使用可达性分析来确定对象是否需要被回收，所以上面的回收算法都分为两个过程：标记和回收。标记过程就是可达性分析的两次标记过程，回收策略则有所不同。
	标记-清除算法回收阶段只是简单地将标记为需要回收的对象销毁，这样实现很简单，但是销毁对象并不高效，另一个问题是会产生空间碎片，多次GC后产生了大量的可用空间
碎片，但是没有连续的大空间，如果这时需要创建一个大对象，就会触发一次新的GC，GC结果可能仍不能满足需要，此时却仍有大量可用空间，这样就导致了内存利用效率的降低。
	复制算法中堆空间（通常是新生代）被分为两部分（这两块内存可以不一样大），创建对象总是在其中一块，回收时将存活的对象复制到另一块，然后将原来创建对象的那一块
整体清除。这种算法的问题在于保存对象的空间被人为地减小了，而且复制对象也会产生额外的开销。hotspot在新生代使用复制算法，将新生代空间分为3块：一个Eden块和两个
Survivor块，每次都在Eden和一个Survivor中创建对象，回收时将存活的对象复制到另一个Survivor块中，然后回收前两块，下次创建对象就在保存复制对象的Survivor块和Eden块
中进行。默认配置中，Eden块占新生代的80%，每个Survivor占10%。不管怎么划分复制空间和生产空间，都不能规避一个问题，回收后存活对象需要的空间超过了复制空间的大小。
这种问题通常采用空间分代来解决，hotspot中使用老年代来处理。
	标记-整理算法在回收不可用对象时不是直接清除，而是将存活对象移动到空间的一端，设置一个指针指向移动后存活对象空间的边界，然后清除该指针另一侧的空间。
	分代收集算法不是一种新的回收方式，而是将整个堆空间根据对象的存活周期分为多个块，在各个块采用合适的收集算法。jvm一般将堆空间分为新生代和老年代，新生代采用
复制算法，老年代采用标记-整理算法。
	可达性分析时用户线程必须停止执行，这样引用链才能保持稳定。准确式GC技术使得寻找GC Roots不需要一个一个去搜索方法区和虚拟机栈。hostspot中维护了一个oopMap对象，
在类加载时，类中常量、静态变量的位置就确定了，oopmap就将这些位置保存起来，JIT过程中局部变量表中的引用对象的地址也被保存到oopmap中。虚拟机不会在执行每条指令时都
保存oopmap，而是选择那些可以“让程序较长时间停止”的位置（称为安全点）保存oopmap。GC线程启动后，用户线程会继续执行到最近的安全点才停止，这通常采用主动式中断实现
（GC线程启动后，虚拟机在用户线程的安全点设置一个标记，用户线程执行时去检查这个标记，检测到就中断挂起），另一种方案是抢先式中断，但是几乎没有被使用。线程休眠等
操作时（线程的对象引用关系不会变化），虚拟机将会设置一个标记，GC线程启动后检查到这个标记就可以对这个线程的对象进行GC。
	hotspot中的垃圾收集器：Serial、ParNew、Parallel、Serial Old、Parallel Old、CMS、G1
	Serial是一个古老的单线程收集器，优点是简单高效，缺点是GC时必须停止其他所有工作线程，通常用于client模式下新生代的GC。
	ParNew收集器是Serial的多线程版本，除了使用多线程外，其他特性和Serial基本相同，也用于新生代GC。
	Parallel收集器也是一个新生代多线程收集器，和ParNew不同在于，ParNew（以及其他收集器）关注点在于减少GC期间用户线程的暂停时间，而Parallel则是关注系统吞吐率
（用户代码执行时间/(用户代码执行时间+GC时间)）。Parallel使用以下两个参数控制吞吐率：
		-XX:MaxGCPauseMillis 100	//大于0的毫秒值
		-XX:GCTimeRatio n			//大于0小于100 GC时间占比计算公式：1/(1+n)
	Parallel开启自动调节模式：
		-XX:+UseAdaptiveSizePolicy
	Serial Old是Serial的老年代版本，使用标记-整理算法。
	Parallel Old是Parallel的老年代版本。
	CMS收集器用于老年代的GC，采用标记-清除算法（Concurrent Mark Sweep）。CMS的目标是实现最短回收停顿时间，所以比较适合那些重视服务响应速度的应用。CMS将GC过程分为
4个阶段：初始标记、并发标记、重新标记、并发清除。
	初始标记阶段需要停止用户线程，但是只是标记GC Roots直接关联的对象，所以耗时很短。
	并发标记阶段进行GC Roots Tracing，标记不在引用链上的所有对象，这个阶段不需要停止用户线程。
	重新标记阶段将并发标记阶段用户线程修改的对象重新标记，需要停止用户线程，耗时也不多。
	并发清除阶段清除已标记的对象，不需要停止用户线程。
	CMS收集器GC的4个阶段中只有耗时较短的初始标记和重新标记需要停止用户线程，所以能获得很短的回收停顿时间。
	CMS收集器的问题：并发清除期间可能产生浮动垃圾，需要到下一次GC才能回收；另一个问题是标记-清除算法会导致空间碎片问题。
	CMS收集器虽然可以做到并发回收，但是并发回收也会占用CPU资源，所以仍然存在GC时系统变慢的问题。
	如果老年代使用CMS收集器，新生代就只能使用ParNew收集器。
	G1收集器是一种新的收集器，采用标记-整理算法，而且G1可以管理整个堆内存，也可以在使用分代模型时只管理老年代或新生代的GC。G1可以实现可预测的回收停顿，指定运行时GC
的时间占比。
	G1收集器将堆空间划分为多个大小相等的独立区域，称为Region，GC时不需要再对整个堆进行处理，而是只处理一部分Region。G1跟踪每个Region的垃圾堆积价值（回收空间和时间的
经验值，即历史GC综合值），每次选择回收价值最大的Region进行GC。
	查看虚拟机默认参数：
		java -XX:+PrintCommandLineFlags -version
	查看默认的垃圾收集器：
		java -XX:+PrintGCDetails -version
	JDK1.8 64位JDK server模式默认使用Parallel作为新生代收集器，默认使用Parallel Old作为老年代收集器。

	jvm运行模式：
	32位虚拟机默认为client模式启动，可以通过修改配置文件（JAVA_HOME/jre/lib/i386/jvm.cfg）和启动参数切换为server模式。
	64位虚拟机默认为server模式启动，不能切换为client模式。配置文件为：JAVA_HOME/jre/lib/amd64/jvm.cfg
	Client模式启动速度较快，Server模式启动较慢。Client模式启动的JVM采用的是轻量级的虚拟机，Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化。
	
	GC日志
    与GC日志有关的参数：
        -XX:+PrintGC 输出简要GC日志 
        -verbose:gc
        -XX:+PrintGCDetails 输出详细GC日志 
        -Xloggc:gc.log  输出GC日志到文件
        -XX:+PrintGCTimeStamps 输出GC的时间戳（以JVM启动到当期的总时长的时间戳形式） 
        -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2018-05-04T21:53:59.234+0800） 
        -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息        
        -XX:+PrintReferenceGC 打印年轻代各个引用（SoftReference，WeakReference，FinalReference等）的数量以及清理时长
    实际上，-verbose:gc是一个标准的选项， -XX:+PrintGC是一个实验的选项，在JDK1.8中 -verbose:gc和-XX:+PrintGC是等价的，但是在JDK 9中 -XX:+PrintGC被标记为deprecated
	测试代码：
		public class JvmDemo1 {
			public static void main(String[] args) {
				byte[] bArr1 = new byte[2*1024*1024];
				byte[] bArr2 = new byte[2*1024*1024];
				byte[] bArr3 = new byte[2*1024*1024];
				byte[] bArr4 = new byte[4*1024*1024];
			}
		}
	JVM参数：
		-verbose:gc -XX:+PrintGCDetails -Xmx20M -Xms20M -Xmn10M -XX:SurvivorRatio=8 -XX:+UseSerialGC
	GC日志：
		[GC (Allocation Failure) [DefNew: 7292K->628K(9216K), 0.0029765 secs] 7292K->6772K(19456K), 0.0032015 secs] 
		[Times: user=0.00 sys=0.02, real=0.02 secs]
	使用默认的Parallel收集器时，这段代码运行时没有发生GC，这应该是由于最后的4MB大于新生代可用空间，所以直接将其放到了老年代
	将最后一行代码改为：byte[] bArr4 = new byte[3*1024*1024]; 然后使用Parallel收集器将输出下面的GC日志：
		[GC (Allocation Failure) [PSYoungGen: 7292K->736K(9216K)] 7292K->6888K(19456K), 0.0103966 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
		[Full GC (Ergonomics) [PSYoungGen: 736K->0K(9216K)] [ParOldGen: 6152K->6771K(10240K)] 6888K->6771K(19456K), 
			[Metaspace: 2564K->2564K(1056768K)], 0.0175492 secs] [Times: user=0.00 sys=0.00, real=0.02 secs]
	这里发生了两次GC，第二次GC触发了Stop The World（STW）。第一次GC将Eden区的对象（数组）内容部分转移到老年代，将额外信息转移到一个survivor区，第二次GC又将survivor
区的内容也转移到老年代。
	程序退出前的内存情况：
		Heap
			PSYoungGen      total 9216K, used 7456K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
				eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd48160,0x00000000ffe00000)
				from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
				to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
			ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
				object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000)
			Metaspace       used 2570K, capacity 4486K, committed 4864K, reserved 1056768K
				class space    used 282K, capacity 386K, committed 512K, reserved 1048576K
	PSYoungGen即表示使用Parallel( Scavenge)收集器的年轻代，ParOldGen表示使用Parallel Old收集器的老年代。
	Metaspace表示元空间的数据，即方法区（以前的永久代）的GC数据。
	Heap部分详细的输出了堆空间的内存内容，包括新生代的eden区和两个survivor区（from和to），以及老年代和元空间。
	
	
	第三章 JVM监控工具：
	jps(Java Virtual Machine Process Status Tool) ： jps主要用来输出JVM中运行的进程状态信息。语法格式如下：
		jps [option] [hostid]		//不指定hostid就默认为当前主机或服务器。
	option有效值：
		-q 不输出类名、Jar名和传入main方法的参数
		-m 输出传入main方法的参数
		-l 输出main类或Jar的全限名
		-v 输出传入JVM的参数
	使用：
		jps -m -l -v
	
	 jstack：主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：
	 	jstack [option] pid
		jstack [option] executable core
		jstack [option] [server-id@]remote-hostname-or-ip
	option有效值：
		-l long listings，打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况
		-m mixed mode，输出Java堆栈信息，同时输出C/C++堆栈信息（比如Native方法）
	使用：
		jstack pid | grep 0xtid
	
	 jmap：用来查看堆内存使用状况，一般结合jhat使用，语法格式如下：
	 	jmap [option] pid
		jmap [option] executable core
		jmap [option] [server-id@]remote-hostname-or-ip
	option有效值：
		-heap 查看进程堆内存使用情况，包括使用的GC收集器、堆配置参数和各代中堆内存使用情况。
		-clstats 打印使用的类加载器信息
		-histo 打印堆内存中的对象数目、大小统计柱状图（列表），-histo:live只打印存活对象数据
		-dump:<option> 把进程内存使用情况dump到文件中
	使用：
		jmap -heap 7544
		jmap -dump:format=b,file=tem_file\dump1.dat 7544
	使用jhat查看dump出来的文件：
		jhat -port 9998 tem_file\dump1.dat
	如果dump文件太大，需要设置较大的可用堆空间：
		jhat -J-Xmx512M -port 9998 tem_file\dump1.dat
	在浏览器中访问9998端口查看dump文件内容。

	jstat：JVM统计监测工具，语法格式：
		jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]
	//vmid是Java虚拟机ID，通常就是进程ID，interval是采样时间间隔。count是采样数目。
	统计GC信息：
		jstat -gc 7544 250 4
		表示每隔250ms采集一次，总共采集4次。
	输出结果(JDK8)：
		  S0C     S1C    S0U    S1U      EC       EU        OC         OU       MC      MU     CCSC   CCSU      YGC   YGCT   FGC      FGCT     GCT
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
		23040.0 23040.0  0.0    0.0   303104.0 131445.0  699392.0   46369.5   65280.0 63552.4 7936.0 7604.5     51    0.322   6      0.658    0.980
	S0C、S1C表示Survivor0和Survivor1区总内存容量，S0U、S1U表示Survivor0和Survivor1区已使用内存容量，EC、EU表示Eden区总内存容量和已使用内存，OC、OU表示老年代
总内存容量和已使用内存，MC、MU表示元空间总内存容量和已使用内存，CCSC、CCSU表示压缩类总内存空间大小和已使用内存，YGC、YGCT表示年轻代垃圾回收次数和消耗时间，FGC、
FGCT表示老年代垃圾回收次数和消耗时间，GCT表示垃圾回收消耗总时间。
	统计类加载:
		jstat -class 7544
	统计编译信息：
		jstat -compiler 7544

	hprof：用于展现CPU使用率，统计堆内存使用情况，语法格式：
		java -agentlib:hprof[=options] ToBeProfiledClass
		java -Xrunprof[:options] ToBeProfiledClass
		javac -J-agentlib:hprof[=options] ToBeProfiledClass
	统计CPU使用信息( CPU Usage Sampling Profiling(cpu=samples))：
		java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello
	//每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，保存在当前目录下。
	CPU Usage Times Profiling(cpu=times)使用字节码注入技术,能够获得更加细粒度的CPU消耗信息:
		javac -J-agentlib:hprof=cpu=times Hello.java


	第四章 class文件结构：
	Java在设计初期就采用了两套规范，即Java语言规范和JVM虚拟机规范，实现平台无关的特性主要依靠虚拟机屏蔽不同硬件、操作系统间的差异，对于虚拟机而言，class文件就是
可执行文件，虚拟机不关心也不知道class文件是如何创建的，所以完全可以使用另一种语法编写程序源码，只要能把这些源码编译为规范的class文件，JVM就能理解执行。
	class文件是以字节（8位二进制位）为基本单位的二进制文件，字节之间遵循严格的顺序规范，逻辑单元由连续的字节构成。下面是class文件的逻辑单元：
		ClassFile{
			u4				magic;
			u2				minor_version;
			u2				major_version;
			u2				constant_pool_count;
			cp_info			constant_pool[constant_pool_count-1];
			u2				access_flags;
			u2 				this_class;
			u2				super_class;
			u2 				interfaces_count;
			u2				interfaces[interfaces_count];
			u2 				fields_count;
			fields_info 	fields[fields_count];
			u2 				methods_count;
			method_info 	methods[methods_count];
			u2 				attributes_count;
			attribute_info 	attributes[attributes_count];
		}
	依次是4字节的魔数，固定为cafe babe，2字节的次版本号（通常为 0000），2字节的主版本号（jdk1.8为 0034），2字节的常量池中常量个数，然后是常量池，常量池中常量实际
为前面的constant_pool_count-1。常量池后面是2字节的类访问限制描述符，然后是2字节的当前类名（引用常量池中常量），然后是2字节的当前类的父类类名（引用常量池中常量），然后
是2字节的当前类接口数量，然后是当前类的接口名（每2个字节引用常量池中的一个常量表示一个接口，如果当前类没有接口就没有这段数据结构），然后是2字节的类字段和实例字段数量，
然后是字段表，字段表后是2字节的方法数量，然后是方法表，然后是2字节的类属性表数量，然后是类的属性表（这里的属性不是类或对象的变量）。
	常量池解析：
	常量池中的常量，具有不同的类型，不同类型的常量结构（长度）不完全相同，但是都有一个字节作为tag信息，用于标识常量类型，下面是各种类型常量的说明：
		CONSTANT_Utf8_info，tag为1，表示UTF-8编码的字符串，其他内容包括2字节的字符串长度部分和字符串内容部分（长度由前面的字符串长度部分决定，单位为字节）；
		CONSTANT_Integer_info，tag为3，表示整形字面量，其他部分为4字节的int型常量值；
		CONSTANT_Float_info，tag为4，表示浮点型字面量，其他部分为4字节的float型常量值；
		CONSTANT_Long_info，tag为5，表示长整形字面量，其他部分为8字节的long型常量值；
		CONSTANT_Double_info，tag为6，表示双精度字面量，其他部分为8字节的double型常量值；
		CONSTANT_Class_info，tag为7，表示类或接口的符号引用，其他部分为2字节的类或接口全限定名常量项的索引；
		CONSTANT_String_info，tag为8，表示字符串类型的字面量，其他部分为2字节的字符串常量项的索引；
		CONSTANT_Fieldref_info，tag为9，表示字段的符号引用，其他部分包括2字节的字段名常量（CONSTANT_Class_info类型）索引和2字节的字段描述符常量（CONSTANT_NameAndType_info）索引；
		CONSTANT_Methodref_info，tag为10，表示类中方法的符号引用，其他部分包括2字节的方法名常量（CONSTANT_Class_info类型）索引和2字节的方法描述符常量（CONSTANT_NameAndType_info）索引；
		CONSTANT_InterfaceMethodref_info，tag为11，表示接口中方法的符号引用，其他部分包括2字节的方法名常量（CONSTANT_Class_info类型）索引和2字节的方法描述符常量（CONSTANT_NameAndType_info）索引；
		CONSTANT_NameAndType_info，tag为12，表示字段和方法的名称以及类型的符号引用，其他部分包括2字节的名称常量索引和2字节的描述常量索引。
	类(接口)访问限制描述:
		值		内部名				含义
		0x0001	ACC_PUBLIC		是否为public类型
		0x0010	ACC_FINAL		是否被声明为final，只有类可以设置
		0x0020	ACC_SUPER		JDK1.0.2以后这个标志都为真
		0x0200	ACC_INTERFACE	标识这是一个接口
		0x0400	ACC_ABSTRACT	是否为abstract类型，对于接口或抽象类来说，此标志值为真，其他类值为假
		0x1000	ACC_SYNTHETIC	标识这个类并非由用户代码产生
		0x2000	ACC_ANNOTATION	标识这是一个注解
		0x4000	ACC_ENUM		标识这是一个枚举
	实际的访问限制符可能有多个，比如public final，这个单元就是对应值的和，public final对应的值为0x0011，等于0x0001+0x0010
	字段表结构解析：
		field_info{
			u2 				access_flags;
			u2				name_index;
			u2 				descriptor_index;
			u2 				attributes_count;
			attribute_info	attributes[attributes_count];
		}
	方法表结构和字段表结构完全相同。
	字段、方法访问限制符描述：
		值		内部名				含义
		0x0001	ACC_PUBLIC		public类型
		0x0002	ACC_PRIVATE		private类型
		0x0004	ACC_PROTECTED	protected类型
		0x0008	ACC_STATIC		static类型
		0x0010	ACC_FINAL		final类型
		0x0040	ACC_VOLATILE	volatile类型
		0x0080	ACC_TRANSIENT	transient类型
		0x1000	ACC_SYNTHETIC	标识这个字段（方法）并非由用户代码产生
		0x4000	ACC_ENUM		枚举类型
	属性表（attribute_info）解析(不同属性的属性格式有部分不同，下面是所有属性公有的部分)：
		attribute_info{
			u2 				attribute_name_index;        //属性名称索引
			u4				attribute_length;            //属性长度
			//...
		}
	有效属性：
		属性名称			使用位置				含义
		Code				方法表				Java代码编译成的字节码指令
		ConstantValue		字段表				final关键字定义的常量值
		Deprecated		类、方法表、字段表		 被声明为deprecated的方法和字段
		Exceptions			方法表				方法抛出的异常
		InnerClasses		类文件				内部类列表
		LineNumberTable		Code属性			Java源码的行号与字节码指令的对应关系
		LocalVariableTable	Code属性			方法的局部变量描述
		SourceFile			类文件				源文件名称
		Synthetic	类、方法表、字段表			 标识方法或字段为编译器自动生成的
	Code属性结构解析：
		Code_attribute{
			u2 				attribute_name_index;
			u4				attribute_length;
			u2 				max_stack;
			u2 				max_locals;
			u4				code_length;
			u1				code[code_length];
			u2				exception_table_length;
			exception_info	exception_table;
			u2				attributes_count;
			attribute_info	attributes[attributes_count];
		}
	Code属性的属性表中通常会有LineNumberTable、LocalVariableTable属性。
	LineNumberTable属性结构解析：
		LineNumberTable_attribute {
			u2 				attribute_name_index;
			u4 				attribute_length;
			u2 				line_number_table_length;
			{   
				u2 start_pc;            //字节码行号
				u2 line_number;         //java源码行号
			} line_number_table[line_number_table_length];
		}
	SourceFile属性结构解析：
		SourceFile_attribute{
			u2 				attribute_name_index;
			u4 				attribute_length;
			u2  			sourcefile_index;
		}
	
	实例：Hello.java
		public class Hello {
			private static String HELLO_WORLD = "Hello World!";
			public static void main(String[] args) {
				System.out.println(HELLO_WORLD);
			}
		}
	编译后class文件：
		cafe babe 0000 0034 0022 0a00 0700 1309 0014 0015 0900 0600 160a 0017 0018 0800 1907 001a 0700 1b01 000b 4845 4c4c 4f5f
		574f 524c 4401 0012 4c6a 6176 612f 6c61	6e67 2f53 7472 696e 673b 0100 063c 696e	6974 3e01 0003 2829 5601 0004 436f 6465
		0100 0f4c 696e 654e 756d 6265 7254 6162	6c65 0100 046d 6169 6e01 0016 285b 4c6a	6176 612f 6c61 6e67 2f53 7472 696e 673b
		2956 0100 083c 636c 696e 6974 3e01 000a	536f 7572 6365 4669 6c65 0100 0a48 656c	6c6f 2e6a 6176 610c 000a 000b 0700 1c0c
		001d 001e 0c00 0800 0907 001f 0c00 2000	2101 000c 4865 6c6c 6f20 576f 726c 6421	0100 0548 656c 6c6f 0100 106a 6176 612f
		6c61 6e67 2f4f 626a 6563 7401 0010 6a61	7661 2f6c 616e 672f 5379 7374 656d 0100	036f 7574 0100 154c 6a61 7661 2f69 6f2f
		5072 696e 7453 7472 6561 6d3b 0100 136a	6176 612f 696f 2f50 7269 6e74 5374 7265	616d 0100 0770 7269 6e74 6c6e 0100 1528
		4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0021 0006 0007 0000 0001 000a	0008 0009 0000 0003 0001 000a 000b 0001
		000c 0000 001d 0001 0001 0000 0005 2ab7	0001 b100 0000 0100 0d00 0000 0600 0100	0000 0100 0900 0e00 0f00 0100 0c00 0000
		2600 0200 0100 0000 0ab2 0002 b200 03b6	0004 b100 0000 0100 0d00 0000 0a00 0200	0000 0400 0900 0500 0800 1000 0b00 0100
		0c00 0000 1e00 0100 0000 0000 0612 05b3	0003 b100 0000 0100 0d00 0000 0600 0100	0000 0200 0100 1100 0000 0200 12
	根据各单元长度分段：
		cafe babe		//magic
		0000			//minor_version=0
		0034			//major_version=52,即jdk1.8
		0022			//constant_pool_count，共34-1=33个常量
		//常量池开始
		0a 0007 0013	1 //CONSTANT_Methodref_info,后面是方法名常量索引和方法描述符常量索引，即第7个常量和第19个常量，
		09 0014 0015	2 //CONSTANT_Fieldref_info,后面是字段名常量索引和字段描述符常量索引，即第20个常量和第21个常量，
		09 0006 0016	3 //CONSTANT_Fieldref_info,后面是字段名常量索引和字段描述符常量索引，即第6个常量和第22个常量，
		0a 0017 0018 	4 //CONSTANT_Methodref_info,后面是方法名常量索引和方法描述符常量索引，即第23个常量和第24个常量，
		08 0019 		5 //CONSTANT_String_info,后面是字符串常量索引，即第25个索引，即 Hello World!
		07 001a 		6 //CONSTANT_Class_info，后面是类或接口全限定名常量项索引，即第26个常量，即 Hello
		07 001b			7 //CONSTANT_Class_info，后面是类或接口全限定名常量项索引，即第27个常量，即 java/lang/Object
		01 000b 4845 4c4c 4f5f 574f 524c 44								8	HELLO_WORLD
		01 0012 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b			9	Ljava/lang/String;
		01 0006 3c69 6e69 743e											10	<init>
		01 0003 2829 56													11	()V
		01 0004 436f 6465												12	Code
		01 000f 4c69 6e65 4e75 6d62 6572 5461 626c 65					13	LineNumberTable
		01 0004 6d61 696e												14	main
		01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956	15	([Ljava/lang/String;)V
		01 0008 3c63 6c69 6e69 743e										16	<clinit>
		01 000a 536f 7572 6365 4669 6c65 								17	SourceFile
		01 000a 4865 6c6c 6f2e 6a61 7661								18	Hello.java
		0c 000a 000b	19 //CONSTANT_NameAndType_info，后面是名称常量索引和描述常量索引，即第10个常量和第11个常量，即 <init>和()V
		07 001c 		20 //CONSTANT_Class_info，后面是类或接口全限定名常量项索引，即第28个常量，即 java/lang/System
		0c 001d 001e	21 //CONSTANT_NameAndType_info，后面是名称常量索引和描述常量索引，即第29个常量和第30个常量，即 out和Ljava/io/PrintStream;
		0c 0008 0009	22 //CONSTANT_NameAndType_info，后面是名称常量索引和描述常量索引，即第8个常量和第9个常量，即 HELLO_WORLD和Ljava/lang/String;
		07 001f 		23 //CONSTANT_Class_info，后面是类或接口全限定名常量项索引，即第31个常量，即 java/io/PrintStream
		0c 0020 0021	24 //CONSTANT_NameAndType_info，后面是名称常量索引和描述常量索引，即第32个常量和第32个常量，即 println和(Ljava/lang/String;)V
		01 000c 4865 6c6c 6f20 576f 726c 6421							25	Hello World!
		01 0005 4865 6c6c 6f 											26	Hello
		01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374					27	java/lang/Object
		01 0010 6a61 7661 2f6c 616e 672f 5379 7374 656d					28	java/lang/System
		01 0003 6f75 74													29	out
		01 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b	30	Ljava/io/PrintStream;
		01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d			31	java/io/PrintStream
		01 0007 7072 696e 746c 6e										32	println
		01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 56	33	(Ljava/lang/String;)V
		//常量池结束
		0021			//this_class access_flags，0021=0001+0020，即 public
		0006			//this_class， 即第6个常量，即 Hello
		0007			//super_class，即第7个常量，即 java/lang/Object
		0000			//interfaces_count，接口数为 0
		0001			//fields_count ，字段数为 1
		000a 			//field access_flags，000a=0002+0008,即 private static
		0008 			//field name_index,即第8个常量，即 HELLO_WORLD
		0009			//field descriptor_index,即第9个常量，即 Ljava/lang/String;
		0000 			//field attributes_count,属性数为0
		0003			//methods_count,方法数为 3 

		0001			//method access_flags,即 public 
		000a			//method name_index,即第10个常量，即 <init>
		000b 			//method descriptor_index,即第11个常量，即 ()V
		0001			//method attributes_count,这个方法有一个属性 
		000c			//index，第12个常量，即	Code属性，	
		0000 001d		//code属性长度，不包括这里的4个字节和index的2个字节，这里code属性总长为29个字节 
		0001 			//max_stack=1，操作数栈最大深度
		0001 			//max_locals=1，局部变量表最大Slot数量（一个Slot存放一个32位以内的数据类型）
		0000 0005 		//code_length,表示接下来的5个字节为方法的内容
		2ab7 0001 b1 
		0000			// method exception_table_length,这里异常表长度为0，所以后面没有异常表内容。 
		0001			// code属性的属性表长度，这里为1
		000d 			// name_index,即第13个常量，即LineNumberTable
		0000 0006 		// attribute_length,这里LineNumberTable长度为6个字节
		0001			// line_number_table_length;这里为1，即只有1组源码、字节码行号映射
		0000 0001 		// 表示字节码行号0000对应源码行号0001
		
		0009 			// 0009=0001+0008，即 public static
		000e 			// 第14个常量，即 main
		000f 			// 第15个常量，即 ([Ljava/lang/String;)V
		0001 			// 这个方法有1个属性
		000c 			// Code属性
		0000 0026 		// 这里code属性总长为38个字节
		0002 			// max_stack=2，
		0001 			// max_locals=1，
		0000 000a 		// code_length,表示接下来的10个字节为方法的内容
		b200 02b2 0003 b600 04b1 	//0xb2即getstatic指令，用于访问静态数据，后面的2个字节0002表示第二个常量，第二个常量引用了第20个和
									//第21个常量，即System和PrintStream；后面的字节b2和0003表示访问第三个常量，即Hello类的HELLO_WORLD,
									//字节b6是invokevirtual指令，后面的0004表示第4个常量，即PrintStream类的实例方法println，这里就是将
									//HELLO_WORLD作为参数传递给println方法执行；字节b1表示return指令。
		0000 			// 异常表长度为0
		0001 			// code属性的属性表长度，这里为1
		000d 			// LineNumberTable
		0000 000a 		// 这里LineNumberTable长度为10个字节
		0002 			// 2组源码、字节码行号映射
		0000 0004 		// 字节码行号0000对应源码行号0004
		0009 0005 		// 字节码行号0009对应源码行号0005

		0008 			// static
		0010 			// <clinit>
		000b 			// ()V
		0001 			// 这个方法有1个属性
		000c 			// Code属性
		0000 001e 		// 这里code属性总长为30个字节
		0001 			// max_stack=1，
		0000 			// max_locals=0，
		0000 0006 		// code_length,表示接下来的6个字节为方法的内容
		1205 b300 03b1 
		0000 			// 异常表长度为0
		0001  			// code属性的属性表长度，这里为1
		000d 			// LineNumberTable
		0000 0006 		// 这里LineNumberTable长度为6个字节
		0001 			// 1组源码、字节码行号映射
		0000 0002 		// 字节码行号0000对应源码行号0002
			
		0001 			// this_class attributes_count 类属性数量为1
		0011 			// 属性名常量索引，第十七个常量，即 SourceFile
		0000 0002 		// 属性长度：2个字节
		0012			// sourcefile_index,第18个常量，即 Hello.java
	注：常量池中字符串字面量常量如果含有中文，则采用UTF-8编码占用3个字节（实际上class文件中字符串常量默认使用UTF-8编码）
	使用javap:
		javap --help 显示javap用法；
		javap -v Demo1	输出常量池、方法表信息
		javap -c Demo1  输出反汇编后的代码，主要就是方法和静态代码块（可能是由编译器产生的）
		javap -l Demo1	输出方法行号表（LineNumberTable）和本地变量表（LocalVariableTable，需要使用javac -g 编译源码）

	JVM指令
	JVM的指令操作码占用一个字节，所以最多只能提供256条指令。一些指令不需要操作数（操作码中已经包含了操作数），另外一些指令后面带有一个或多个操作数。JVM使用操作数栈而
不是寄存器来保存操作数。
	方法实例：
		void spin() {
			int i;
			for (i = 0; i < 100; i++) {
				; // Loop body is empty
			}
		}
	编译上面方法所在的类，然后使用javap反编译class文件得到该方法的JVM指令：
		void spin();
		  Code:
			 0: iconst_0            
			 1: istore_1      
			 2: iload_1             
			 3: bipush        100   
			 5: if_icmpge     14    
			 8: iinc          1, 1  
			11: goto          2     
			14: return              
		  LineNumberTable:          
			line 4: 0               
			line 7: 14              
	每条指令基本格式如下：
		<index> <opcode> [<operand1> [<operand2>...]] [<comment>]
	注：实例方法写局部变量表都是从索引为1开始，第一个slot用于保存实例方法所在对象的this引用，对于静态方法，则是索引0开始使用。
	<index>是指令操作码在方法字节码指令数组中的索引，即方法的Code属性的code[]数组中的索引，code[]数组紧跟在Code属性的code_length后，长度由code_length指定。<index>可以
作为控制转移指令的跳转目标。
	<opcode>是指令的操作码助记符.
	<operandN>是指令操作数，一条指令可以有0至多个操作数，iconst_0没有操作数，bipush有1个操作数，iinc有2个操作数。如果操作数是常量池中的常量，操作数前会有一个#号。
	<comment>是指令行尾的注释，注释内容通常以//开始。
	指令16进制-助记符表：
		0x00		nop					None
		0x01		aconst_null			将null推送至栈顶
		0x02		iconst_m1			将int型-1推送至栈顶
		0x03		iconst_0[0-5]		将int型0[0-5]推送至栈顶
		0x09		lconst_0[0-1]		将long型0[0-1]推送至栈顶
		0x0b		fconst_0[0-2]		将float型0[0-2]推送至栈顶
		0x0e		dconst_0[0-1]		将double型0[0-1]推送至栈顶
		0x10		bipush				将单字节的常量值(-128~127)推送至栈顶
		0x11		sipush				将一个短整型常量(-32768~32767)推送至栈顶
		0x12		ldc					将int,float或String型常量值从常量池中推送至栈顶
		0x13		ldc_w				将int,float或String型常量值从常量池中推送至栈顶(宽索引，即后面的1个操作数占2个字节)
		0x14		ldc2_w				将long或double型常量值从常量池中推送至栈顶(宽索引)
		0x15		iload				将指定的int型本地变量推送至栈顶
		0x16		lload				将指定的long型本地变量推送至栈顶
		0x17		fload				将指定的float型本地变量推送至栈顶
		0x18		dload				将指定的double型本地变量推送至栈顶
		0x19		aload				将指定的引用类型本地变量推送至栈顶
		0x1a		iload_0[0-3]		将第1个[1-4]int型本地变量推送至栈顶(将本地变量表中第1个变量推送到操作数栈顶，因为是int型，所以是取本地变量表的前4个字节)
		0x1e		lload_0[0-3]		将第1个[1-4]long型本地变量推送至栈顶
		0x22		fload_0[0-3]		将第1个[1-4]float型本地变量推送至栈顶
		0x26		dload_0[0-3]		将第1个[1-4]double型本地变量推送至栈顶
		0x2a		aload_0[0-3]		将第1个[1-4]引用类型本地变量推送至栈顶
		0x2e		iaload				将int型数组指定索引的值推送至栈顶
		0x2f		laload				将long型数组指定索引的值推送至栈顶
		0x30		faload				将float型数组指定索引的值推送至栈顶
		0x31		daload				将double型数组指定索引的值推送至栈顶
		0x32		aaload				将引用类型数组指定索引的值推送至栈顶
		0x33		baload				将boolean或byte型数组指定索引的值推送至栈顶
		0x34		caload				将char型数组指定索引的值推送至栈顶
		0x35		saload				将short型数组指定索引的值推送至栈顶
		0x36		istore				将栈顶int型数值存入指定本地变量
		0x37		lstore				将栈顶long型数值存入指定本地变量
		0x38		fstore				将栈顶float型数值存入指定本地变量
		0x39		dstore				将栈顶double型数值存入指定本地变量
		0x3a		astore				将栈顶引用类型数值存入指定本地变量
		0x3b		istore_0[0-3]		将栈顶int型数值存入第1个[1-4]本地变量
		0x3f		lstore_0[0-3]		将栈顶long型数值存入第1个[1-4]本地变量
		0x43		fstore_0[0-3]		将栈顶float型数值存入第1个[1-4]本地变量
		0x47		dstore_0[0-3]		将栈顶double型数值存入第1个[1-4]本地变量
		0x4b		astore_0[0-3]		将栈顶引用型数值存入第1个[1-4]本地变量
		0x4f		iastore				将栈顶int型数值存入指定数组的指定索引位置
		0x50		lastore				将栈顶long型数值存入指定数组的指定索引位置
		0x51		fastore				将栈顶float型数值存入指定数组的指定索引位置
		0x52		dastore				将栈顶double型数值存入指定数组的指定索引位置
		0x53		aastore				将栈顶引用型数值存入指定数组的指定索引位置
		0x54		bastore				将栈顶boolean或byte型数值存入指定数组的指定索引位置
		0x55		castore				将栈顶char型数值存入指定数组的指定索引位置
		0x56		sastore				将栈顶short型数值存入指定数组的指定索引位置
		0x59		dup					复制栈顶数值并将复制值压入栈顶
		.........
		0x63		dadd				将栈顶两double型数值相加并将结果压入栈顶
		0x82		ixor				将栈顶两int型数值"按位异或"并将结果压入栈顶
		0x83		lxor				将栈顶两long型数值"按位异或"并将结果压入栈顶
		0x84		iinc				将指定int型变量增加指定值(如i++, i--, i+=2等: iinc 1,1)，在所有字节码指令中，只有此指令可直接用于操作局部变量。
		0x93		i2s					将栈顶int型数值强制转换为short型数值并将结果压入栈顶
		0x97		dcmpl				比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶
		0x98		dcmpg				比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶
		0x9b		iflt				当栈顶int型数值小于0时跳转
		0x9c		ifge				当栈顶int型数值大于等于0时跳转（ifge 10，跳转到10号索引处指令，操作数10占2个字节）
		0xa2		if_icmpge			比较栈顶两int型数值大小, 当结果大于等于0时跳转
		0xac		ireturn				从当前方法返回操作数栈栈顶int型变量
		0xa7		goto				无条件跳转
		0xb0		areturn				从当前方法返回对象引用
		0xb1		return				从当前方法返回void
		0xb4		getfield			获取指定类的实例域, 并将其压入栈顶（操作数是字段在常量中的索引：getfield     #18）
		0xb5		putfield			为指定类的实例字段赋值（操作数是字段在常量中的索引：putfield      #18）
		0xb6		invokevirtual		调用实例方法
		0xb7		invokespecial		调用调用实例初始化方法、私有方法和父类方法，需要以this作为首个参数
		0xb8		invokestatic		调用静态方法
		0xbb		new					创建一个对象, 并将其引用引用值压入栈顶
		0xc6		ifnull				为null时跳转（ifnull        6）
		.........
	JVM规范没有设计取反指令，而是使用异或指令来实现取反，对一个数进行取反，相当于-1与该数进行异或：~x = -1^x
	NaN：表示未定义或不可表示的值，在java中只要有操作数是NaN，那么对它进行任何数值比较和等值测试都会返回false。任何数值与NaN进行不等值比较都会返回true：
		NaN==10;	//false
		NaN>10;		//false
		NaN<10;		//false
		NaN!=10;	//true
	new指令执行后，并没有完成一个对象实例创建的全部过程，只有执行和完成了实例初始化方法后，实例才算创建完全：
			Object create() {
				return new Object();
			}
		字节码指令：
			java.lang.Object create()：
			0: new           #3 // class java/lang/Object. 创建对象，并将其引用值压入栈顶
			3: dup              // 复制栈顶引用值，并将复制值压入栈顶
			4: invokespecial #8 // Method java/lang/Object."<init>":()V. 调用实例初始化方法,从栈顶弹出一个引用
			7: areturn          // 从当前方法返回对象引用，返回栈顶引用
	invokevirtual指令用于调用对象的实例方法，带有一个表示索引的参数，占2个字节，表示运行时常量池中的索引，该索引处是某个方法的符号引用（提供类名称、方法名称及方法描述符信息）。
这条指令执行后会将调用方法返回的结果压入操作数栈顶。
	invokestatic指令表示调用静态方法，不需要传入实例引用this，因此不需要压入栈。

	
	第五章 类的加载
	类加载过程：加载、连接、初始化，其中连接可以细分为验证、准备、解析三个阶段。
	加载：类加载器根据一个类的全限定名读取此类的二进制字节流保存在JVM的运行期方法区中，然后JVM根据保存的二进制数据创建一个java.lang.Class对象。
	连接：对已保存在方法区中的类数据进行验证，然后为静态变量分配内存并设为初始值，然后将常量池中所有的符号引用转为直接引用。
		验证：格式验证（检查加载的二进制流数据（通常是class文件）符合jvm规范）、语义分析（检查是否违反语义规范，如没有实现接口中的方法）、字节码验证（goto指令的操作数是否超出方法
边界等）、符号引用验证（检查符号引用对应的直接引用是否存在，将延后到解析阶段进行）；验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
		准备：为类中的所有静态变量分配内存空间，并为其设置一个初始值（对于非final变量，这个值是虚拟机默认设置好的，例如int为0，对于final变量，这个值就是代码中设置的值）
		解析：将常量池中所有的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法）。这个阶段可能在初始化之后再执行。
	初始化：将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；如果执行的是static代码块，那么在初始化
阶段，JVM就会执行static代码块中定义的所有操作。
    验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的，可以使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。
    初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的。
	虚拟机规范中并没有强制约束何时进行类的加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随着发生）：
		1、遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：使用 new 关键字实例化对象
的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
		2、使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
		3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
		4、当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
		5、当使用 JDK.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法
句柄所对应的类没有进行过初始化，则需要先触发其初始化。
	这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：
		通过子类引用父类的静态字段，不会导致子类初始化；
		通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
		常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

    虚拟机在加载类阶段，使用几种不同的 ClassLoader 加载程序执行需要的类信息，JVM 中内置了三个重要的 ClassLoader，分别是 BootstrapClassLoader、ExtensionClassLoader 和 
AppClassLoader。
	BootstrapClassLoader 负责加载 JVM 运行时核心类，这些类位于 $JAVA_HOME/jre/lib/rt.jar 文件中，如：java.util.*、java.io.*等。
	ExtensionClassLoader 负责加载 JVM 扩展类，位于 $JAVA_HOME/jre/lib/ext/*.jar 文件内。
	AppClassLoader 加载 Classpath 环境变量里定义的路径中的 jar 包和目录。
	jdk 内置一个 URLClassLoader，用于加载位于网络上静态文件服务器提供的 jar 包和 class文件。
	双亲委派：AppClassLoader 在加载一个未知的类名时，首先将这个类名交给父加载器 ExtensionClassLoader 加载，如果 ExtensionClassLoader 可以加载，那么 AppClassLoader 就不
需要自己加载，否则就需要在Classpath查找这个类，能找到就进行加载，否则就抛出异常。ExtensionClassLoader 在加载一个未知的类名时，也是首先将类名交给父加载器 BootstrapClassLoader 
加载，如果BootstrapClassLoader 不能加载，就自己去加载。
	class文件被加载后，jvm根据它构造出对应的 class 对象，这个class对象持有加载它的ClassLoader的引用。但是使用 BootstrapClassLoader 加载的class获取的classLoader引用为null。
	可以通常修改 BootstrapClassLoader 的加载路径，让 BootstrapClassLoader 加载其他的类：
		// /a:表示追加路径到 BootstrapClassLoader 的加载路径
		java -Xbootclasspath/a:d:tem_file VmDemo1
    双亲委派加载模式是java推荐采用的类加载方式，所以现在如果要实现自己的类加载器，只需要继承ClassLoader(这是一个抽象类)并重写findClass方法就可以了，ClassLoader类的loadClass方法
会检查该类是否已加载，没有加载才会调用父加载器的loadClass方法尝试加载，只有当父加载器加载失败才会调用自己的findClass方法来进行加载。
    打印几种类加载器：（启动类加载器无法获取，将得到null）
        public class JvmDemo3 {
            public static void main(String[] args) {
                System.out.println(JvmDemo6.class.getClassLoader());
                System.out.println(Object.class.getClassLoader());
                System.out.println(JButton.class.getClassLoader());
                System.out.println(ZipFileSystem.class.getClassLoader());
            }
        }
    自定义类加载器，重写loadClass方法，将会重复加载已经加载的类：
        public class JvmDemo4 {
            public static void main(String[] args) throws Exception{
                MyClassLoader myClassLoader = new MyClassLoader();
                Object obj = myClassLoader.loadClass("com.zhangwei.javabase.jvm.JvmDemo4").newInstance();
                System.out.println(obj.getClass());
                System.out.println(obj.getClass()==JvmDemo4.class);
                System.out.println(obj instanceof com.zhangwei.javabase.jvm.JvmDemo4);
                //输出：
                //class com.zhangwei.javabase.jvm.JvmDemo4
                //false
                //使用自定义的类加载器加载类创建的对象，打印加载的类名仍是当前类，但是由于当前类已经被AppClassLoader加载，
                //所以使用instance运算符检查显示两个类型并不相同
            }
        }

        class MyClassLoader extends ClassLoader{
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf('.')+1)+".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if(is==null){
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    Class clazz = defineClass(name,b,0,b.length);
                    return clazz;
                } catch (IOException e){
                    throw new ClassNotFoundException(name);
                }
            }
        }
    自定义类加载器，重写findClass方法，不会重新加载已加载的类：
        public class JvmDemo5 {
            public static void main(String[] args) throws Exception{
                NewClassLoader newClassLoader = new NewClassLoader();
                Object obj = newClassLoader.loadClass("com.zhangwei.javabase.jvm.JvmDemo7").newInstance();
                System.out.println(obj.getClass());
                System.out.println(obj.getClass()==JvmDemo7.class);
                System.out.println(obj instanceof com.zhangwei.javabase.jvm.JvmDemo7);
                //输出：
                //class com.zhangwei.javabase.jvm.JvmDemo7
                //true
                //true
                //不重写loadClass方法，只重写findClass，已经加载的类不会重复加载
            }
        }

        class NewClassLoader extends ClassLoader{
            @Override
            protected Class<?> findClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf('.')+1)+".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if(is==null){
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    Class clazz = defineClass(name,b,0,b.length);
                    return clazz;
                } catch (IOException e){
                    throw new ClassNotFoundException(name);
                }
            }
        }



















