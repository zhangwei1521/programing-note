										第一章 java的历史和演进
	java继承了其它语言的优秀元素，也提出了自己的新特性、新概念。
计算机编程语言的出现和发展主要是由两个因素推动的，第一个是环境的需要和对环境的适应，第二个是编程思想的演进。
java从C和C++继承了大量的特性。

    C使用的结构化编程模式在编写大型应用程序时其复杂性超出了承受范围，个人认为是普通开发者无法驾驭这样的复杂性导致的。
这将导致企业的开发成本过高，在这种背景下，对开发人员要求更低、同时也更符合普通人思考模式的面向对象模式语言出现了。

    java出现的背景其实是为了实现平台独立，C++程序需要使用为不同CPU编写的编译器编译，C++程序本身也可能设计到操作系统
调用，出现了和操作系统的耦合，难以实现平台独立。而java被设计成基于虚拟机的语言，sun官方提供主流操作系统的虚拟机实现和SDK（包含编译器），
而且不用为每一种CPU提供一个编译器。个人理解是java编译器、虚拟机都只需要和操作系统打交道，而不需要关注CPU。
Internet上的服务器的硬件设施和操作系统的多样性要求开发的程序需要是平台独立的，这也是java兴起的一个重要推动力。
	目前主流的java版本仍然是1.8，学习也以1.8为准。

										第二章 java综述
	两种编程模式：第一种是面向过程编程模式，C语言便是代表，围绕“正在发生什么”编程，代码直接作用于数据；第二种是面向
对象编程模式，围绕“将影响谁”编程，定义了对象这种数据结构，对象封装了数据和操作数据的接口，通过调用对象的接口操作数据，通过组合对象解决复杂性问题。
	OOP三原则：
	封装，即定义对象（类）封装数据和对数据的操作；
	继承，对象（类）可以继承其它对象（类）获得属性和方法，可以减少程序复杂性；
	多态，接口方法只定义功能，不提供具体实现，不同实现类可以选择不同的实现方式。

	开发环境搭建：安装JDK1.8
	配置环境变量：JAVA_HOME	JDK安装路径
				 path		添加;%JAVA_HOME%\bin
				 CLASSPATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
				 //从jdk1.6开始，不需要再配置 classpath环境变量

	编译程序：javac Example.java
	运行程序：java Example
	打印classpath：System.out.println(System.getProperty("java.class.path"));
	关于dt.jar和tools.jar、rt.jar：
		dt.jar是BeanInfo(swing的BeanInfo)文件的DesignTime归档，集成开发环境（IDE）使用这些BeanInfo显示Java组件和设置属性编辑器。
		tools.jar是关于一些工具的类库，主要是jdk工具，包括javac,java,javap，javadoc等(集成开发环境也使用这些工具)。
		rt.jar位于：{Java_Home}/jre/lib/下，是JAVA基础类库，也就是在java doc里面看到的所有的类的class文件，
		rt.jar 默认就在Root Classloader的加载路径里面的，jre/lib目录下的，其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar
		也都在Root Classloader中，所以不需要手动添加到环境变量CLASSPATH中。
	
	新建类：com.zhangwei.javademo1.MainClass
	编译时进入最内层的目录(javademo1): javac MainClass.java
	执行时到最外层目录(com目录同级)：java com.zhangwei.javademo1.MainClass
	打包：在最外层目录(com目录同级)建manifest.txt文件：
		Manifest-Version: 1.0
		Main-Class: com.zhangwei.javademo1.MainClass
	
	manifest.txt最后一行为空行，并且manifest.txt文件换行符需要使用linux的换行符(windows回车换行符：\r\n无效，linux换行符：\n)
	打包命令：jar -cvfm aa.jar manifest.txt com
	执行jar：java -jar aa.jar
	
										第三章 数据类型
	强类型的语言有利于在代码编译时进行检测，因此可以避免很多不必要的问题，增强程序的安全性和健壮性。
	java的八种基本数据类型：
		整数型：byte、short、int、long；
		浮点型：float、double；
		字符：char；
		布尔值：boolean；
	int型最大值：2^31-1 = 2147483647；最小值-2^31 = -2147483648；
	java运行时字符类型使用utf-16编码存储，并且只使用16位即两个字节，所以java的char类型只能取unicode码点小于等于  
65535的字符。而unicode码点大于65535的字符由于需要4个字节才能保存，所以java直接就在编译期报错。
	从JDK7开始，java可以使用0b或0B开头后跟0和1表示二进制数，也可以使用下划线分隔数字，使得数位较多的数字更好读，例
如：	int x = 0b1011_1110_1001;
	java默认浮点字面值类型为双精度double型：1.1默认为double类型。
	字符型字面量可以使用这些形式：字符a的三种表示：'a'、97（unicode码点）、'\u0061'(16进制表示)、'\141'(8进制表示);
无法输入的字符还可以使用转义表示法：如换行符使用'\n'。8进制表示并不常用。
	汉字：𤭢	unicode码点为：150370 大于65535，因此无法作为java的单个字符输入，可以使用字符串表示：
String cs = "𤭢";但是cs.length()返回2。
	一个奇怪的错误与类型提升：
	byte b = 50;
	b = b * 2;
	上面的代码将会报错，这是由于b在参与运算b * 2时，进行了类型提升，实际参与运算的类型变成了int，结果也就成了int值
，而将结果赋值给byte型的b就出错了。
	实际上，在没有long、float、double类型变量参与运算时，byte、short、char都会提升为int型的值，有long参与就提升为
long型，有float参与就提升为float型，有double参与就提升为double型。
	java不允许使用未初始化的值。
	数组的声明：int arr[];初始化：int arr[] = new int[10];这种初始化后的数组中都是0；
	更常用的初始化方式：int arr[] = {1,2,3,4,5};
	多维数组：int arr2[] = new int[4][5];也可以只指定第一维的长度：int arr2[] = new int[4][];第二维的长度可以
不相同。
	声明数组的另一种写法： int[] arr;也可以是: int [] arr;
	同时声明多个实例变量：private String s1="1", s2="2";	//也可以不初始化
	局部变量也可以这样写：String s3="3",s4="4";
	实例变量不初始化可以直接使用，因为在创建实例时会赋予实例变量默认值，但是局部变量使用前必须被显式赋值，否则会编译不通过。
										第四章 运算符与条件语句
	左移运算符：<<	在不越界的情况下相当于乘以二： 2<<2 == 8
	右移运算符：>>	在不越界的情况下相当于除以二： 8>>2 == 2,右移使用了符号扩充，所以-1右移总是得到-1.
	无符号右移：>>>	右移不使用符号扩充：所以-1>>>2 == 2^30-1.
	if(c==1 & e++ < 100) d=100;这种写法表示无论c是否等于1，都会对e执行自增1，c等于1且e小于100则d赋值为100.

	switch语句：
	switch(exp){
		case const1:
			...;
			break;
		case const2:
			...;
			break;
		...
		default:
			...;
	}
	JDK7之前exp只能是byte、short、int或枚举类型，现在可以是String类型。case后只能是常量表达式，且不能重复。
	和break、continue连用的标签用来标记代码块，break或continue加标签只能跳到所在的代码块标签处，即break或continue
后的标签必须是当前代码块或当前代码块的上级代码块。
	^ :异或运算符，对两个操作数进行按位异或，即只有一个1取1，否则取0：-1 ^(-1 << 12) --> 4095
	
										第五章 类和对象
	每个类都定义了一种数据类型（数据结构），声明对象的对象名只是一个变量，通常称为对象引用，大体上可以认为是为对象所分配内存的地址，
但不能像操作指针那样去操作对象引用。new运算符在运行时动态为对象分配内存。
	默认构造函数自动将所有实例变量初始化为其对应类型的默认值：数字为0，布尔为false，对象为null，char为码点为0的字符
	finalize方法的一般形式：
	protected void finalize(){
		...;
	}
	finalize方法通常是jvm在销毁对象前调用以完成一些特殊工作。
	方法调用时的自动类型提升：
	如果只定义了test(double i)；实际上是可以使用test(1)的；
	方法的重载本质上是编程思想的进步，即在方法功能层面上的抽象，例如多个重载的构造方法功能上是一致的，都是为了创建和
初始化对象。
	包表达的是一群在一起的类；
	访问控制和修饰符：public表示可以在任何地方访问修改，private表示只能在类所定义的方法中访问和修改，默认（无访问
修饰符）表示同包下的类可以访问修改，protected表示子类可以继承的属性，跨包的子类中也不能访问父类对象的protected控制
属性，但可以继承。
子类和父类不在同一个包下，子类中也不能访问修改父类对象的默认访问控制属性。
	子类只能继承由 protected 和 public 和无修饰符的的属性，private属性不能被继承。子类跨包则不能继承默认访问控制的属性。
	静态内部类只能访问外部类的静态属性，非静态内部类可以定义在需要的任意代码块中。
	静态内部类并不会在主类被加载和初始化时加载，而是在实际使用(引用)时才被加载。类的加载和初始化总是线程安全的。
	静态内部类可以访问外部类的私有属性和方法。
	通过外部类的实例对象创建内部类对象：
	Demo1 demo1 = new Demo1();
    InnerClass inner = demo1.new InnerClass();
    可变长参数方法：（varargs方法）：
    void test(String msg, int ... v){
    	System.out.println(msg+" ; length of v is "+v.length);

    }
    调用： test("hello",1,2);
    	   test("hello",1,2,3);
    	   test("hello");
    变长参数实际是一个数组。
	
继承：
	继承的一个好处是可以实现代码复用，创建的子类模型不需要重新声明已经在父类中定义的熟悉和方法，这样写出来的代码就
显得清晰很多。
	可以使用超类的类型变量指向子类的实例对象，这有一些实际的好处，比如说作为多态的一种实现方式，但是需要注意使用
超类的类型变量只能访问在超类中定义的变量和方法，而不能使用实际子类定义的成员。
	子类的构造函数中使用super(args);调用父类的构造函数；并不会创建父类的对象，但是会为父类定义的属性分配内存（堆
空间中）；子类对象调用继承父类的方法时，首先找到与该方法静态绑定的父类字节码对象，再找到和父类字节码对象动态绑定的
父类属性所分配的内存空间。
	如果子类中定义了父类中已有的属性或方法，还是可以使用super访问父类中的对应属性或方法。
	方法的重写和重载是不一样的概念，重写是指子类的方法签名和父类的方法签名完全相同时隐藏父类方法的机制，而重载的方法
的签名是不同的。
	方法的重写是java动态方法调度的基础。所谓动态方法调度其实就是运行时多态，运行时根据对象实例的类型决定使用哪一个
重写方法。
	方法重写提供了“一个接口，多种方法”的特性。
	不能创建抽象类的实例对象，这也说明在构造子类对象实例时不会创建父类的对象。
	通常java在运行时动态分析对方法的调用（方法的源），这称为后期绑定；而final方法不能被重写，所以对final方法的调用
可以在编译期间解析，直接将final方法的源例程字节码和方法的编译代码内联在一起，这称为早期绑定。
	
											第六章 包和接口
	java使用文件系统的目录存储包，目录名和包名必须精确匹配。
	具有确定的包的对象，包名是对象的名称空间的一部分，所以使用java命令运行时不能只写类名。
	一个类implement一个接口时，如果没有全部实现接口中的方法，那么这个类需要被声明为抽象类；接口中未实现的方法将由
继承该类的子类进行实现。
	可以将接口声明为一个类或另一个接口的成员，这称为嵌套接口。引用嵌套接口时必须包含嵌套接口的外层类或接口名进行限定。
	JDK8提供接口的默认方法的动机主要有两点：一个是扩展原有接口的功能而不破坏已有的代码；第二个是为本质上可选的方法提供
默认实现（空实现）以免除实现类自己去提供空实现冗余代码。
	尽管可以提供接口的默认实现，但是仍然不能创建接口的实例对象，接口不能维持状态信息的基本特性没有发生变化。现在的接口
看起来和抽象类已经很相像了。
	default String getName(){
        return "hello";
    }
	接口的实现类可以重写接口中的默认方法实现。
	当一个类实现了多个接口，而每个接口都定义了默认实现的方法，则这个类确实相当于继承了多级父类的行为。
	JDK8新增了接口可以添加静态方法的特性，接口的静态方法像类的静态方法一样，通过接口名直接调用，但是实现类不会继承
接口的静态方法。
											第七章 异常处理
	异常是什么？
	异常是程序运行时发生的错误，在编译期不能确定运行时一定会出现错误，但是可能会在运行时发生错误，比如读取一个输入值
作为除数，如果输入0就会发生除零异常。
	异常分为系统抛出异常和手动抛出异常，系统抛出异常通常是违反了一些基础的环境约束，手动抛出的异常通常用于向方法调用
者反馈错误条件等。
	JDK7新增带资源的try语法：待续....
	异常的类型：公共父类：Throwable,其对应两个子类：Exception和Error，Exception代表用户应该捕获处理的异常，Error通常
是运行时环境本身出现错误，比如堆栈溢出，自己的程序一般不会处理。Exception的子类RuntimeException通常作为自定义的异常
的父类。
	如果自己不捕获处理异常，java运行时系统会使用默认的处理程序捕获处理：输出描述字符串，打印堆栈，结束程序。
	使用try...catch捕获异常可以让程序继续运行下去。
	Throwable重写了Object的toString方法，可以返回异常描述字符串。同时Throwable定义了getMessage方法返回这个字符串。
	必检异常：
	除了Error和RuntimeException及其子类的其他所有异常都必须被try...catch处理或者在方法签名中使用 throws 声明抛出。
	非必检异常：
	通常是RunctimeException的子类，如：ArithmeticExcetion,NullpointerException等。
	finally{...}代码块总是会执行。
	链式异常：
	Throwable(Throwable e) JDK1.4增加的构造链式异常的构造方法，增加方法：initCause(Throwable e)和getCause()设置和
返回内层异常。
	JDK7新增多重捕获语法：catch(AExcetion | BException e){...}
	使用自定义异常通常用于表示操作失败。
	非必检异常的用意：非必检异常表示的是语义上可能会出现的异常，如空指针异常，任何对象属性、方法的访问语义上都可能
抛出，但是设计成熟的程序不会抛出该异常。自定义异常不需要捕获的设计目的在于，这类异常通常只是在程序的最外层处理，中
间层并不需要麻烦地去捕获再抛出。
	java预定义的非必检异常通常不会发生（设计良好，经过充分测试的程序不应该发生这些异常），必检异常则不能得到这种保证，
比如文件异常（如文件错误），一旦发生这些异常就会严重影响程序执行，所以必须捕获处理。
	自定义异常表示的是由于不确定因素（比如网络故障）导致的程序必需元素的缺失或损坏导致程序不能正常执行时进行的情况，
比如网络故障导致的参数错误或丢失，这类问题不是程序设计上的漏洞，而且发生后会导致程序不能继续执行，对于这类异常通常也是
不能直接处理的，只能进行日志记录。
											第八章 并发编程
	多线程需要的开销比多进程要小，进程需要自己的地址空间，进程间通信开销大而且限制多，从一个进程上下文切换到另一个
进程上下文开销很大。多线程共享相同的地址空间，互相通信开销较小，上下文切换开销也很小。
	单线程的问题是遇到一些非CPU处理的耗时任务时，CPU只能空闲等待，如IO操作。多线程就是为了处理这种问题。
	单线程系统使用轮询事件循环机制，当某个处理事件阻塞时，系统将等待阻塞。多线程则允许某个线程阻塞时，其它线程继续
运行。同时，多线程可以更好地利用多核系统的处理能力。
	线程的状态：
	运行、挂起、恢复、阻塞。
	java为每一个线程都指定了优先级，是一些整数，指定的是一个线程相对于另外一个线程的优先程度。优先级决定了线程间的
上下文切换。发生上下文切换的时机：一是运行中的线程主动放弃控制，二是高优先级线程抢占控制权。windows系统下多个同优先
级的线程会循环获得CPU资源，其它操作系统则需要运行中的线程主动放弃。
	java的对象具有隐式监视器，在一个线程调用对象的同步方法时，就会获得监视器，从而其它线程不能调用该对象上的同步方法。
	Thread实例对象是线程的代理，定义了一些用于帮助管理线程的方法：getName()、getPriority()、isAlive()、join()、
run()、sleep()、start()等。
	子线程都是主线程产生的，通常主线程必须是最后结束执行的线程，需要执行各种关闭操作。
	Thread.currentThread()静态方法，获取运行中的线程的引用。Thread.sleep(n)静态方法，运行中的线程休眠n毫秒。
	线程组是将一类线程作为整体来控制状态的数据结构。
	创建线程的两种方式：实现Runnable接口和继承Thread。都需要实现或重写run方法。
	实现Runnable接口比继承Thread的好处是可以继承其它类。
	Thread的实例方法：isAlive()返回线程是否还在运行，join()方法等待线程执行完成后调用线程才继续执行。
	具有相同优先级的线程应该时不时地释放CPU控制权，以避免在某些系统中（非抢占式系统）一些线程不能执行。
	竞态条件：多个线程调用同一个对象的非同步方法。
	同步方法和同步代码块：
	方法使用 synchronized 修饰，当一个线程调用该方法时，则其它线程不能调用该对象上的所有同步方法。
	synchronized(obj){.....} obj是目标对象，即待执行方法所属的对象。同步代码块用于目标对象的方法不能被修改成同步方法，
所以在调用方法时对调用代码进行同步。
	使用wait()、notify()、notifyAll()实现线程间通信：
	wait()方法调用将挂起当前线程，直到有线程调用notify()或notifyAll()唤醒此线程。
	死锁问题：当一个线程调用了对象A的同步方法m，并且将要在m方法中调用对象B的同步方法x，同时另一个线程调用了对象B的某个
同步方法y，并且在方法y中调用对象A的同步方法n，这样线程一持有对象A的锁，需要获得对象B的锁，而线程二持有对象B的锁，需要
获得对象A的锁，形成了死锁，程序将不会结束。
	java 1.0时代使用Thread类定义的suspend()、resume()、stop()方法挂起、恢复、停止一个线程，但是现在不再使用了，它们都有
潜在的危险。现在的操作线程状态的手段主要是在run方法中根据一个对象标志变量决定是否挂起线程，同时在另外的方法中可以修改
该标志变量和唤醒挂起的线程。
	Thread定义了getState()方法返回线程的状态，返回值是Thread.State类型值，包括RUNNABLE、NEW等状态，事实上该返回值不能
反映之后一段时间的线程状态，所以并不能用来作同步使用，而是为了调试程序使用。

										第九章 枚举和注解
	java中的枚举是一种类类型，使用enum关键字定义枚举：
	enum Apple{
		Jonathan, GoldenDel, RedDel, Winesap, Cortland
	}
	每一个枚举常量都隐式的声明为枚举类公有的、静态的、final成员，即public static final XXX xxx。
	枚举常量的使用：Apple app;  app = Apple.Jonathan; if(app == Apple.Jonathan){...}  
	switch(app){
		case Jonathan:
			...
		case Winesap:
			...
	}
	所有枚举类都具有两个静态方法：values()和valueOf();
	Apple [] allApples = Apple.values();
	Apple app = Apple.valueOf("Jonathan");
	枚举类可以定义实例变量和构造方法：
	enum Apple {
		Jonathan(10), GoldenDel(9), RedDel, Winesap(15), Cortland(8);
		private int price;
		Apple(int price){
			this.price = price;
		}
		Apple(){
			this.price = 0;
		}
		int getPrice(){
			return this.price;
		}
	}
	枚举类的两个要点：定义的枚举类不能继承其他类，枚举类不能作为超类。
	所有的枚举类都继承自Enum类，Enum类定义了3个实例方法：
	final int ordinal();	//返回调用枚举常量的序数值（从0开始），如Apple.Jonathan.ordinal(); //0
	final int compareTo(enum-type e); 	//返回与参数枚举常量的序数值的差值正负结果： Apple.Jonathan.compareTo(Apple.GoldenDel);  // -n(负数)
	final boolean equals(enum-type e);  //比较两个枚举常量的相等性
	说明一下：equals比较时只需要两个枚举常量是同一个枚举类中相同的常量即可成立，而==比较的是引用；如果是通过网络传输的一个
枚举常量和本地的一个枚举常量比较，则使用equals比较成立，而二者引用是不同的。
	装箱、拆箱和自动装箱、自动拆箱：
	JDK1.5之前的基本数据类型封装类使用：
	Character(char c);		char charValue();
	Boolean(boolean b);		boolean booleanValue();
	...
	JDK1.5新增自动装箱和自动拆箱：
	Inteter iob = 100;
	++iob;
	Boolean b = true;
	if(b) ...
	Character c = 'x';
	不应该滥用自动装拆箱，否则会影响程序性能。
	JDK5新增了注解语法，用于在源文件中嵌入补充信息，主要是便于其它工具获取这些信息。
	注解定义语法：
	@Interface MyAnno {
		String str();
		int val();
	}
	注解定义语法不能使用extends继承其它类，实际上所有注解都扩展了Annotation接口,Annotation接口重写了toString、equals和
hashCode方法。
	注解使用：
	@MyAnno(str = "example", val = 100)
	public static void meMethod();
	保留策略：RetentionPolicy枚举类定义了三种枚举常量保留策略：SOURCE、CLASS、RUNTIME。
	使用内置注解@Retention声明注解的保留策略：(默认是RetentionPolicy.CLASS)
	@Retention(RetentionPolicy.RUNTIME)
	@Interface MyAnno {
		String str();
		int val();
	}
	Class、Method、Field、Constructor对象上定义了getAnnotation(Class<A> annoType)和getAnnotations()方法，前者返回指定
的注解，后者返回所有的注解。这两个方法来源于AnnotatedElement接口。Package也实现了该接口。该接口定义的另外的可用的方法
还有：
	Annotation [] getDeclaredAnnotations();			//返回所有的非继承的注解
	boolean isAnnotationPresent(Class<A> annoType);	//是否使用了指定注解修饰
	...
	注解属性的使用：
	MyAnno myAnno = ...;
	String str = myAnno.str();
	设置注解属性默认值：
	@Interface MyAnno {
		String str() default "test";
		int val() default 100;
	}
	标记注解：没有属性，使用时不使用括号：@Mark
	单成员注解：
	@Interface MyAnno {
		String value();
	}
	或者
	@Interface MyAnno {
		String value();
		int val() default 100;
	}
	使用：
	@MyAnno("hello")
	public static void test();
	或者：
	@MyAnno(value="hello",val=55)
	public static void test();
	内置注解：@Retention声明注解的保留策略；@Documented声明注解将被文档化；@Target声明注解能修饰的数据类型：其参数只能
是ElementType枚举类中的常量：FIELD、LOCAL_VARIABLE、METHOD等；@Inherited声明注解可以被修饰类的子类继承；
	类型注解的声明：
	@Target(ElementType.TYPE_USE)
	@interface Unique{}
	类型注解有什么用？首先类型注解用在类型之前，用于修饰类型，比如说使用上面的@Unique修饰一个类的构造方法（或者某种类型
的成员变量），然后第三方工具可以使用该注解来检查该类是否只声明了一个构造方法（某种类型的变量）。
	重复注解：
	@Retention(RetentionPolicy.CLASS)
	@Repeatable(MyAnnoContainer.class)
	@interface MyAnno{
		String str();
		int val();
	}

	@Retention(RetentionPolicy.CLASS)
	@interface MyAnnoContainer{
		MyAnno [] value();
	}
	应用：
	@MyAnno(str="aaa",val=11)
	@MyAnno(str="bbb",val=22)
	public void test(){}
	
	Annotation anno = m.getAnnotation(MyAnnoContainer.class);m是test方法的反射对象
										第十章 IO基础及其他
	java使用“流”进行输入输出抽象，“流”是一种对接对象，输入流和输入源对接，提供一系列方法从数据源获取数据，输出流提供一系列
方法将数据导出到目的地。java提供基于字节操作和字符操作的两类流。
	字节流家族：InputStream、
					BufferedInputStream、ByteArrayInputStream、DataInputStream、FileInputStream等
				OutputStream
					BufferedOutputStream、ByteArrayOutputStream、DataOutputStream、FileOutputStream等
	字符流家族：Reader
					BufferedReader、CharArrayReader、FileReader等
				Writer
					BufferedWriter、CharArrayWriter、FileWriter等
	System类有三个静态的预定义流成员变量：out、in、err. in是InputStream的实例对象，out和err是PrintStream的实例对象。
	可以使用BuffredReader读取控制台输入：
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		BufferedReader的read方法读取单个字符，readLine方法读取一行字符串。System.in采用按行缓冲。
	向控制台输出使用PrintWriter和使用System.out(PrintStream)的区别（好处）在于更好的国际化支持。
	读写文件：使用文件名构造FileInputStream和FileOutputStream 的实例对象都可能抛出文件不存在异常，对于输出流其实是指
不能打开文件或者创建文件，如果有原文件会先销毁原文件。
	JDK1.7之前需要手动关闭流，JDK1.7新增了“自动资源管理”的特性，对于实现了AutoCloseable接口的资源类，可以使用扩展的try
语法实现自动关闭资源，事实上所以流都实现了该接口，所以可以使用该新特性。
	try(FileInputStream fin = new FileInputStream("fileName")){
		...
	}
	try后括号中的资源实际上被隐式声明成final类型，所以不能修改。
	Applet简单介绍：所有的Applet需要继承Applet类，需要重写paint方法，大部分Applet没有main方法。
	开发阶段使用appletViewer查看和测试applet。
	transient修饰符：用来修饰不需要被永久性存储的实例变量。
	volatile修饰符：多线程中告诉各个线程使用最新的变量主副本。
	instanceof运算符：检查对象和类型（接口）是否匹配。
	strictfp修饰符：修饰类、接口、方法，指明使用严格浮点运算（java2开始浮点运算变得更宽松），基本用不到。
	本地方法：目的是为了获得更高的效率，声明方式：
	public native return-type method-name();
	通常使用C语言实现本地方法，将C代码集成到java代码中的机制称为JDI（java本地接口）
	定义本地方法的类中使用System.loadLibrary(String fileName) 加载动态链接库
	使用javah -jni className 生成头文件，其中包含本地方法的函数原型。
	编写C源码实现本地方法后编译生成dll动态链接文件。
	然后就可以运行java类调用本地方法了。
	assert用于开发期间快速测试，语法：
		assert condition;或 assert condition: exp;
	condition返回false则断言失败，直接抛出AssertException异常。
	运行时使用-ea选项启用断言，也可以使用使用-da:package-name禁用指定包中的断言。
	静态导入：
		两种语法：import static java.lang.Math.pow; 或 import static java.lang.Math.*;
		导入指定类中的指定静态成员或所有静态成员。
	this调用重载的构造方法辨析：如果初始化代码很多，则使用this重载可以精简代码，但是使用this重载构造方法效率比使用
完整实现的构造方法低。
	java8将API库的子集组织成3个所谓“紧凑配置文件”：compact1、compact2、compact3，后一个完整包含前一个，使用：
	javac -profile compactn Demo.java
	可以只加载需要使用的库，加载会更快。
											第十一章 泛型
	JDK1.5引入了泛型，泛型从两个方面影响或者说改变了java，一是增加了新的语法元素，二是改变了核心API中很多类和方法。
	使用泛型的类、接口或者方法可以以类型安全的方式使用各种类型的数据，这样可以为算法相同而数据类型不同的程序只编写
一个通用的程序单元。集合框架是受泛型影响最大的API了，引入泛型使得集合框架的使用更加安全。
	泛型的意思：参数化类型，或者说成是类型参数化，使用占位符定义，而使用时被实际类型替换。引入泛型之前，是通过使用
Object引用所有类型对象，这样的方式并不安全，比如手动类型转换时进行了非法的转换，则会导致运行时错误，而泛型不需要进行
手动类型转换，可以在编译期就避开这种问题。
	泛型类： 
	class Gen<T>{
		T t;
		public Gen(T t){
			this.t = t;
		}
		T getT(){
			return t;
		}
	}
	两个泛型类型：
	class TwoGen<K,V>{
		K k;
		V v;
		TwoGen(K k, V v){
			this.k = k;
			this.v = v;
		}
	}
	声明泛型类的实例对象时，只能使用引用类型：Gen<int> gen = new Gen<int>(55); // Error
	有界的泛型：
	class Stats<T extends Number>{
		T[] nums;
		Stats(T[] nums){
			this.nums = nums;
		}
		double average(){
			double sum = 0.0;
			for(int i =0; i < nums.length; i++){
				sum += nums[i].doubleValue();
			}
			return sum / nums.length;
		}
	}
	这样nums[i].doubleValue()就可以编译通过，并且不能使用Stats<String>这种非Number的子类泛型参数。
	事实上，还可以声明泛型类型的父接口，或者同时声明父类和父接口：
	class Gen<T extends MyClass & MyInterface>{...}
	通配符问题：当泛型类的某个方法需要接受另一个泛型类对象作为参数，而该参数对象的泛型可能不是当前对象的泛型类型：
	Stats<T extends Number>方法public boolean sameAvg(Stats<T> stats){...}
	Stats<Integer> istats = new Stats<Integer>(inums);
    Stats<Double> dstats = new Stats<>(dnums);
	istats.sameAvg(dstats);//不能通过编译
	问题在于编译时将istats中的泛型类型都替换为Integer了，所以传入泛型为Double的对象不能通过编译。
	解决方案是使用通配符 ? ，
	public boolean sameAvg(Stats<?> stats){...}这样stats就可以是任意泛型类型的Stats对象了。当然这里的泛型类型仍然只能
是Number的子类。
	有界的通配符：泛型类指定的泛型类型只能是某个类的子类，但是有些方法需要的参数泛型类对象的泛型不能是任意的有效泛型
类型：
	class NegNumber extends Number{//负数类}
	class PosNumber extends Number{//正数类}
	Gen类定义方法 public double sum2(Stats<?> stats){//对stats中的数组的元素先开方再求和}
	这里如果使用NegNumber作为泛型类型的对象是可以传入sum2方法的，但是会出现错误。
	使用有界的通配符： public double sum2(Stats<? extends PosNumber> stats){//对stats中的数组的元素先开方再求和}
	也可以定义通配符下界： <? super subClass> //这里不包括subClass
	泛型方法：<type-param-list> ret-type method-name(param-list){...}
	这里泛型参数类型声明需要放在返回值类型前面。泛型方法可以是静态的，也可以是非静态的。
	泛型构造函数：可以在非泛型类中定义泛型构造方法：
	class Gen{
		double num;
		<T extends Number> Gen(T t){
			this.num = t.doubleValue();
		}
	}
	泛型接口：
	public interface MinMax<T> {
		T min();
		T max();
	}
	实现接口：
	class MyClass<T> implements MinMax{...}
	这里需要把接口中的泛型声明写到子类后面
	class MyClass implements MinMax<Integer>{...} 这种写法是允许的
	为了某些需要和原始代码兼容，可以按照原始代码方式使用泛型类：Gen gen = new Gen(...);
	子类继承带泛型的父类时，必须也声明泛型：
	class Gen2<T> extends Gen<T>{...}
	也可以添加自己的泛型类型：
	class Gen2<T,V> extends Gen<T>{...}
	extends Gen<T>可以简写成 extends Gen
	非泛型类可以作为泛型类的超类
	运行时不能使用泛型类型信息：
	gen instanceof Gen<Integer> //编译不能通过
	gen instanceof Gen<?>       //OK
	(Gen<Integer>)gen 			//强制类型转换是允许的，但是并不安全
	JDK1.7新增了泛型类型推断，即所谓“菱形运算符”：Gen<Integer> igen = new Gen<>(55);
	模糊性错误：
	public class MyGenClass<K,V extends Number> {
		K k;
		V v;
		void set(K k){
			this.k = k;
		}
		void set(V v){
			this.v = v;
		}
	}
	这里重载的set方法可以通过编译，但是如果使用MyGenClass<Number,Number>类型对象调用set方法就会导致错误。
	泛型类不能继承Throwable，不能创建包括特定泛型类型的数组：
	Gen<Integer> gens = new Gen<Integer>[10];  //wrong
	可以使用通配符：
	Gen<?> gens = new Gen<?>[10];  //OK
	
	补充：java的SPI
	SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。它是一种动态替换的机制。
	使用方法：在JAR包的"src/META-INF/services/"目录下建立一个文件，文件名是接口的全限定名，文件的内容可以有多行，每行都是该接口对应的具体实现类的全限定名。
	src
		main
			java
				com.zhangwei
					inteface.LogWriter
					impl.ErrorLogWriter
			resources
				META-INF
					services
						com.zhangwei.inteface.LogWriter(文件名就是接口的全限定名，没有扩展名)
	com.zhangwei.inteface.LogWriter文件内容：
		com.zhangwei.impl.ErrorLogWriter
	测试：
		ServiceLoader<LogWriter> logWriterList = ServiceLoader.load(LogWriter.class);
        for(LogWriter logWriter : logWriterList){
            logWriter.log("lllllll");
        }
						
											第十二章 lambda表达式
	lambda表达式提升了java的表达能力。
	lambda表达式包括三个部分，参数列表、->、lambda体 ：(n)->n%2==0
	lambda表达式本质上是一个匿名方法，这个方法并不能独立执行，而是作为一个函数式接口的抽象方法的实现。
	函数式接口是一个仅包含一个抽象方法的接口，用来指定接口的特定用途，比如Runnable接口。
	函数式接口的实例仍然可以调用定义在Object上的一些方法：如equals
		public interface MyFuncInterface {
			int sum(int a, int b);
		}
	lambda表达式的参数列表可以声明参数的类型，也可以不声明参数类型，参数类型通常可以从上下文中推断出来。
	lambda表达式体可以只有一条语句，也可以是一个代码块。一条语句不需要写return，表达式结果将直接返回。
		MyFuncInterface myFunc;
        myFunc = (a,b)->a+b;
        System.out.println("--- "+myFunc.sum(2,3));
	lambda表达式参数和返回值类型都必须匹配函数式接口中的方法（编译器检查）。
	如果参数只有一个，也可以不写括号： n -> n%2;
	函数式接口可以引用任何和它兼容的lambda表达式。
		myFunc = (a,b)->(a+b)*1;
	如果有多个参数，参数类型要么全不写，或者全写上。
		(int n, m)-> m+n;	//Error
	表达式体为代码块的lambda表达式如果需要返回值，必须使用return xxx;返回
		public interface MyFuncInterface {
			int func(int n);
		}
		MyFuncInterface myFunc;
		myFunc = (n) ->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
	泛型函数式接口：
		public interface MyGenFuncInterface<T> {
			T func(T t);
		}
	引用lambda表达式：
		MyGenFuncInterface<String> myGenFuncS;
        myGenFuncS = (s)->{
            StringBuilder buffer = new StringBuilder();
            for(int i=s.length()-1;i>=0;i--){
                buffer.append(s.charAt(i));
            }
            return buffer.toString();
        };
        MyGenFuncInterface<Integer> myGenFuncI;
        myGenFuncI = (n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
	将lambda表达式作为参数传递：
		static String dealStr(MyFuncInterface myFunc, int n){
			return n+" 的处理结果是："+myFunc.func(n);
		}
		String resultS = dealStr((n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        },10);
	这种写法通常用在lambda表达式不会复用的地方，如果觉得这种写法不便阅读，可以使用函数式接口引用：
		MyFuncInterface myFunc = (n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
		String resultS = dealStr(myFunc,10);
	lambda表达式抛出必检异常，匹配的函数式接口也就必须使用throws声明抛出该类异常，否则不能使用该
lambda表达式作为该函数式的实例。
	外部变量捕获：lambda表达式内部可以使用外部局部变量，但是外部局部变量必须是实质上的final变量，即
设置值后不能再修改过，不论是在lambda表达式前还是后修改。lambda表达式内部也不能修改这些外部局部变量。
		int num;
		num = 100;
        //num = 90;	不允许再次修改值
        myFunc = (n)->{
            // num = 90; 不允许再次修改值
            return num+n;
        };
        System.out.println(myFunc.func(10));
        //num = 90; 不允许再次修改值
	lambda表达式内部可以显式或隐式引用调用实例的属性，而且可以在表达式内部修改实例的属性（非final属性）。
		private int num = 10;
		private static int nu = 100;
		public void test1(){
			MyFuncInterface myFunc;
			myFunc = (n)->{
				this.num = 90;
				this.nu = 10;
				return this.num+n;
			};
			System.out.println(myFunc.func(10));
		}
	引用方法作为函数式接口的实例：
	引用静态方法：		
		public interface StringFunc {
			String func(String str);
		}
		
		public class LambdaDemo2 {
			public static void main(String[] args) {
				String inStr = "lambda expression";
				strOps(MyStringOps::stringReverse,inStr);
			}

			static String strOps(StringFunc stringFunc,String str){
				return stringFunc.func(str);
			}
		}

		public class MyStringOps{
			public static String stringReverse(String str){
				StringBuilder buffer = new StringBuilder();
				for(int i=str.length()-1;i>=0;i--){
					buffer.append(str.charAt(i));
				}
				return buffer.toString();
			}
		}
	这里使用strOps(MyStringOps::stringReverse,inStr);将MyStringOps的静态方法：stringReverse作为
函数式接口StringFunc的实现，当然这需要静态方法和函数式接口的抽象方法相匹配。
	引用实例方法：
		MyStringOps:
		String stringToUpperCase(String str){
			return str.toUpperCase();
		}
		LambdaDemo2.main:
		MyStringOps stringOps = new MyStringOps();
        strOps(stringOps::stringToUpperCase,inStr);
	这里的实例方法和函数式接口的抽象方法是匹配的。
	另一种引用实例方法的模式：				
		public interface MyFunc<T> {
			boolean func(T t1,T t2);
		}
				
		public class LambdaDemo3 {
			static <T> int counter(T[] objs,MyFunc<T> myFunc,T obj){
				int count = 0;
				for(int i=0; i<objs.length;i++){
					if(myFunc.func(objs[i],obj)){
						count++;
					}
				}
				return count;
			}

			public static void main(String[] args) {
				HeighTemp[] heighTemps = {new HeighTemp(10),new HeighTemp(20),new HeighTemp(30),new HeighTemp(40),
					new HeighTemp(50),new HeighTemp(60)};
				int result = counter(heighTemps,HeighTemp::lessTemp,new HeighTemp(35));
				System.out.println("result: "+result);	// result: 2
			}
		}

		class HeighTemp{
			private int htemp;

			public int getHtemp(){return htemp;}
			public HeighTemp(int htemp){this.htemp = htemp;}

			public boolean lessTemp(HeighTemp heighTemp){
				if(this.htemp < heighTemp.htemp){
					return true;
				}
				else {
					return false;
				}
			}
		}
	这里是使用类名（HeighTemp::lessTemp）来引用实例方法，但是实例方法和函数式接口的方法是不一样的
	函数式接口的方法 boolean func(T t1,T t2);的第一个参数实际是调用方法的实例对象，这里是myFunc.func(objs[i],obj)
的objs[i]作为调用对象
	泛型函数式接口和泛型静态方法：	
		interface MyFunc2<T>{
			 int func(T t1,T t2);
		}
		class MyComparator{
			public static <T> int compare(T t1, T t2){
				if(t1 == t2) return 0;
				return -1;
			}
		}
		demo：
		static <T> int compareOp(MyFunc2<T> func2,T t1,T t2){
			return func2.func(t1,t2);
		}
		调用：
			compareOp(MyComparator::<Integer>compare,10,12);
		实际上这里的泛型类型可以从上下文推断出来，不需要写出来
	Collections.max(Collections<T> coll,Comparator<T> compartor)需要传入一个比较器实例对象，可以使用静态方法引用
代替比较器实例:
		class MyComparator{			
			static <T> int compare2(T t1, T t2){
				if(t1 == t2) return 0;
				else if(t1 < t2) return -1;
				return 1;
			}
		}
		
		Collections.max(list,MyComparator::compare2);
	函数引用(看起来没什么用)：
		public interface MyBeanFactory<R,T> {
			R newInstance(T t);
		}
		class MyClassA<T>{
			private T val;
			MyClassA(T val){this.val = val;}
			public void setVal(T val){this.val = val;}
			public T getVal(){return val;}
		}


		class MyClassB<T>{
			private T val;
			MyClassB(T val){this.val = val;}
			public void setVal(T val){this.val = val;}
			public T getVal(){return val;}
		}
		public class LambdaDemo4 {
			public static void main(String[] args) {
				MyBeanFactory<MyClassA<String>,String> beanFactory1 = MyClassA<String>::new;
				MyClassA<String> classA = beanFactory1.newInstance("12345");
				MyBeanFactory<MyClassB<Double>,Double> beanFactory2 = MyClassB<Double>::new;
				MyClassB<Double> classB = beanFactory2.newInstance(12.1);
			}
		}
	预定义函数式接口：新的包java.util.function中定义的函数式接口：
		interface Function<T, R>
			方法：R apply(T t);
		interface Consumer<T>
			方法：void accept(T t);
		interface UnaryOperator<T> extends Function<T, T>
			方法：T apply(T t);
		interface BiFunction<T, U, R>
			方法：R apply(T t, U u);
		interface BinaryOperator<T> extends BiFunction<T,T,T> 
			方法：T apply(T t, T u);
		interface Supplier<T> 
			方法：T get();
		interface Predicate<T>
			方法：boolean test(T t);

	补充：
	List<String> list = Arrays.asList("aaa","bbb");
	Iterator<String> iterator = list.iterator();
	while (iterator.hasNext()){
		String name = iterator.next();
		if(name.equals("aaa")){
			iterator.remove();
		}
	}
	执行报错：java.lang.UnsupportedOperationException: null		
			at java.util.AbstractList.remove(AbstractList.java:161)
	说明：在使用Arrays.asList()后调用add，remove这些method时出现java.lang.UnsupportedOperationException异常，
是由于Arrays.asList()返回java.util.Arrays$ArrayList，而不是ArrayList。
	Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等method在AbstractList中是默认throw 
UnsupportedOperationException而且不作任何操作。ArrayList override这些method来对list进行操作，但是Arrays$ArrayList
没有override remove()，add()等，所以throw UnsupportedOperationException。
	可以这样处理：
		List<String> list = new ArrayList<>(Arrays.asList("aaa","bbb"));

											第十三章 JavaBean
	Java Bean 是能够在各种不同的环境中重用的软件组件。
	内省：分析Bean的过程用以确定Bean的功能的技术。
	暴露Bean的属性、事件和方法的两种方式：一是使用约定的规则命名，二是提供一个实现了BeanInfo接口的附加类，由这个类
提供Bean的信息。
	属性命名规则：Bean的属性决定Bean的外观和行为，通过约定的getter和setter方法获取和设置属性的值，两种属性类型：
简单属性和索引属性，索引属性是指一个属性有多个值，比如属性是一个数组，可以使用带有索引参数的getter和setter方法
获取和设置指定索引的值。
	事件命名规则：Bean可以产生和监听事件，添加监听器方法：addTListener(TListener eventListener),T是事件的类型
	内省机制可以发现Bean的公开方法，受保护方法和私有方法不能被内省获得。
	BeanInfo接口定义了三个方法：
		PropertyDiscriptor[] getPropertyDiscriptors();
		EventSetDiscriptor[] getEventSetDiscriptors();
		MethodDiscriptor[] getMethodDiscriptor();
	返回的对象数组描述Bean的属性、事件和方法信息。
	BeanInfo实例命名：BeanNameBeanInfo，也可以选择继承SimpleBeanInfo这个类，重写其中的方法来暴露指定的信息，未被重写
的方法代表的信息将使用约定的命名规则来发现。
	Introspector类：这个类提供方法：
		static BeanInfo getBeanInfo(Class<?> bean) throw IntrospectionException;
这个方法可以使用内省机制返回bean的信息提供者BeanInfo实例（如果在bean的包下自己提供了BeanInfo实现，获取的BeanInfo实例
就是自己提供的那个类的实例）。
											第十四章 Servlet
	早期获取动态资源使用CGI程序（公共网关接口），HTTP请求先被CGI程序获取，CGI为每个请求创建一个进程，这个进程再和数据
库通信，这中方式的问题是性能不高，每个请求就产生一个进程，占用内存和CPU资源太多，而且每个进程都和数据库通信引起的频繁
的数据库连接和关闭连接也是很昂贵的代价。并且CGI可以使用各种语言开发，通常存在平台移植问题。
	servlet在web服务器的内存空间中运行，不创建单独的进程，同时servlet基于java，没有移植问题，而且java的安全管理机制很
完善，可以有效保护服务器上的资源。
	servlet的三个生命周期方法，在特定的时间由服务器调用它们：init()、service()、destroy()
	服务器接收到HTTP请求后根据请求中的资源路径映射到指定的servlet，如果servlet没有被加载，就找到这个servlet并加载到
服务器的内存空间中，然后调用servlet的init方法对servlet进行初始化处理（传递初始化参数配置servlet），然后调用servlet的
service方法处理HTTP请求。处理请求结束后servlet可以驻留在服务器的内存空间中，当服务器决定卸载servlet时才会调用servlet的
destroy方法回收资源。
	servlet-api.jar包含了开发servlet需要的api接口和类，它是由服务器开发者实现的，javaSE没有提供这些接口和类（servlet
接口都是在服务器提供的jar包中），javaEE提供了这些接口和类(应该是由javaEE定义的规范)。	
	编译servlet： javac MyServlet.java -classpath="...\tomcat...\lib\servlet-api.jar"
	编译得到的class文件应该放到tomcat的webapp目录下的工程的WEB-INF\classes\下。
	配置servlet：在工程的WEB-INF目录下的web.xml中配置：
		<servlet>
			<servlet-name>MyServlet</servlet-name>
			<servlet-class>aMyServlet</servlet-class>
		</servlet>
		<servlet-mapping>
			<servlet-name>MyServlet</servlet-name>
			<url-pattern>/servlet/myservlet</url-pattern>
		</servlet-mapping>
	启动tomcat后访问：http://localhost:8080/webappname/servlet/myservlet
	servlet相关类和接口主要位于两个包：javax.servlet和javax.servlet.http。
	javax.servlet包提供接口：
		Servlet：声明servlet的生命周期方法以及getServletConfig()
		ServletConfig：方法：getServletContext()、getInitParameter(String paramName)、Enumeration<String> getInitParameterNames()
		ServletContext: 方法：Object getAttribute(String name)[返回服务器空间中的属性]、getRealPath(String rPath)
		ServletRequest: 方法：Object getAttribute(String name)[返回请求中的属性]、getContentType()、getParameter(...)
、getInputStream()、getReader()、getRemoteHost()等
		ServletResponse: 方法：setContentType(...)、getOutputStream()
	javax.servlet包提供类：
		GenericServlet:实现了Servlet和ServletConfig接口
		ServletInputStream: 扩展了InputStream，由servlet容器实现，方法：int readLine(byte[] buffer, int offset, int size),
从输入流读取size个字节放入buffer从offset开始的位置
		ServletOuputStream: 扩展了OutputStream，由servlet容器实现，方法：print()、println()
		ServletException，继承ServletException 的UnAvailableException
	读取servlet请求参数：
		（ServletRequest request）
		Enumeration e = request.getParameterNames();
		while(e.hasMoreElements()){
			String pName = (String)e.nextElement();
			String param = request.getParameter(pname);
		}
	处理HTTP请求时通常使用http包下的类和接口：
	接口：
		HttpServletRequest:方法：getCookies()、getHeaders()、getMethod()、getSession()等
		HttpServletResponse：方法：addCookie(Cookie cookie)、sendError(...)、setDataHeader(...)、setStatus(int code)
		HttpSession:方法：Object getAttribute(...)、setAttribute(...)、removeAttribute(...)
	核心类：
		Cookie:包括这些信息：名称、值、截止日期、域和路径(需要携带cookie的请求域和路径)。方法：getName、getValue、
	getMaxAge、getDomain、getPath以及对应的set方法。cookie不设置到期时间，默认就是当前回话结束到期
		HttpServlet：方法：doDelete(...)、doGet(...)、doPost(...)、doPut(...)、doTrace(...)、service(...)等
		使用HttpServletRequest的getSession()获取session，如果不存在就创建session
		
	补充：java列表元素的多级比较排序：
		public class DemoEntity{
			public String attrA;
			public String attrB;
			public String attrC;
		}
		List<DemoEntity> list = ...;
		//排序
		Collections.sort(list, new Comparator<DemoEntity>(){
			@Override
            public int compare(DemoEntity o1, DemoEntity o2){
				if(o1.attrA != null && o2.attrA != null && !o1.attrA.equals(o2.attrA)){
					return o1.attrA.compareTo(o2.attrA);
				}
				else{
					if(o1.attrA == null && o2.attrA != null){
						return 1;
					}
					if(o1.attrA != null && o2.attrA == null){
						return -1;
					}
					else{
						if(o1.attrB != null && o2.attrB != null && !o1.attrB.equals(o2.attrB)){
							return o1.attrB.compareTo(o2.attrB);
						}
						else{
							if(o1.attrB == null && o2.attrB != null){
								return 1;
							}
							if(o1.attrB != null && o2.attrB == null){
								return -1;
							}
							else{
								if(o1.attrC != null && o2.attrC != null){
									if(o1.attrC.equals(o2.attrC)){
										return 0;
									}
									return o1.attrC.compareTo(o2.attrC);
								}
								if(o1.attrB == null && o2.attrB != null){
									return 1;
								}
								if(o1.attrB != null && o2.attrB == null){
									return -1;
								}
							}
						}
					}
					
				}
			}
		});
	Integer对象的比较：
		Integer a = 127, b = 127;
		System.out.println(a==b);	//true
		a = new Integer(127);
		b = new Integer(127);
		System.out.println(a==b);	//false
		a = 128;
		b = 128;
		System.out.println(a==b);	//false
		说明：Java在自动装箱创建Integer对象时，如果value小于128或大于-129，实际是引用了Integer的静态内部类IntegerCache的
静态缓存数组cache中的对象，所以a==b。可以使用System.identityHashCode(a)打印对象的内存地址，就可以看到a和b的地址完全相同。
使用new语法创建的对象则没有这个问题。String创建对象时也使用了相同的规则，只是String没有大小限制。Float和Double没有这个问题。
		比较Integer的值时应该使用equals方法
		
											第十五章 对象的序列化和反序列化
	对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，
并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间
进行转换。
	在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。
	java提供了java.io.Serializable 接口用来启用序列化功能，只有实现了这个接口的类的对象才能序列化，这个接口其实没有任何方法
需要实现类去实现，只是作为一个标记。
	对没有实现 Serializable 接口的类的对象序列化，将抛出NotSerializableException。
	如果要序列化的类有父类，并且需要将继承父类定义的变量持久化，那么父类也应该实现java.io.Serializable接口。
	通常使用ObjectOutputStream的writeObject方法把一个对象进行持久化。使用ObjectInputStream的readObject从持久化存储中把对象
读取出来。
		import java.io.Serializable;
		public class User implements Serializable {
			private static User singletonInstance = new User();
			private String name;
			private int age;

			private User(){
			}

			public static User getInstance(){
				return singletonInstance;
			}

			private Object readResolve(){
				return singletonInstance;
			}

			//省略get/set方法
		}

		import java.io.*;
		public class SerializationDemo1 {
			public static void main(String[] args) {
				User user = User.getInstance();
				user.setAge(25);
				user.setName("zhangwei");
				System.out.println("--------");
				System.out.println(user.toString());

				try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempfile"))) {
					oos.writeObject(user);
				} catch (IOException e){
					e.printStackTrace();
				}
				readObjectFromFile("tempfile");
				readObjectFromFile("tempfile");
			}

			private static void readObjectFromFile(String fileName){
				File file = new File(fileName);
				try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {
					User user1 = (User) ois.readObject();
					//如果这里连续两次调用ois.readObject()，会抛出EOFException，表示第二次读取时已经到了文件末尾了。
					System.out.println("--------");
					System.out.println(user1);
				} catch (IOException | ClassNotFoundException e){
					e.printStackTrace();
				}
			}
		}
	每次反序列化得到的都是一个新对象，如果需要在系统中保证多次反序列化得到的是一个单例对象，需要定义readResolve方法，这个方法在反序
列化返回前执行，在这里可以实现返回单例。
	Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 
变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
	java提供了一个继承了Serializable接口的Externalizable接口，这个接口定义了两个抽象方法：writeExternal()与readExternal()。
当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。
	在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值
分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。
	writeExternal(ObjectOutput out)的参数就是实际实例化的对象，这个方法就是用来将想要实例化对象的属性填充到这个参数对象中。
		public void writeExternal(ObjectOutput out) throws IOException {
			out.writeObject(name);
			out.writeInt(age);
		}
	在使用Externalizable进行反序列化的时候，使用readExternal(ObjectInput in)将实际反序列化得到的对象属性填充到返回的对象中。
		public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
			name = (String) in.readObject();
			age = in.readInt();
		}
	虚拟机在反序列化时会检查类路径和序列化ID( private static final long serialVersionUID)，只有两者都能匹配才完成反序列化。

												第十六章 jdbc
	jdbc是java提供的数据库连接技术，其目的是提供统一的API访问不同的数据库，java以接口的形式定义了这些API，数据库厂商根据自己的
产品特性是实现这些接口(jdbc驱动)。
	常用的jdbc接口：DriverManager、Connection、DatabaseMetaData、Statement、PreparedStatement、CallableStatement、
ResultSet、ResultSetMetaData.
	jdbc工作过程：
		1、加载驱动，建立连接；
		2、创建sql语句对象；
		3、执行sql语句；
		4、处理结果集；
		5、关闭连接。
	import java.sql.*;
	public class JdbcDemo1 {
		public static void main(String[] args){
			String url="jdbc:mysql://127.0.0.1:3306/network_info";
			String user="root";
			String password="root";

			String sql = "select * from account";
			try {
				Class.forName("com.mysql.cj.jdbc.Driver");
				Connection conn = DriverManager.getConnection(url,user,password);
				Statement stmt = conn.createStatement();
				ResultSet resultSet = stmt.executeQuery(sql);
				while (resultSet.next()){
					Account account = new Account();
					account.setId(resultSet.getInt("id"));
					account.setName(resultSet.getString("name"));
					account.setNum(resultSet.getString("num"));
					account.setPwd(resultSet.getString("pwd"));
					System.out.println(account);
				}
				resultSet.close();
				stmt.close();
				conn.close();
			} catch (SQLException | ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
	}
	可以将连接数据库的配置信息放到配置文件中，再提供一个通用的工具类获取连接：
database.propperties:
	#mysql
	driver=com.mysql.cj.jdbc.Driver
	url=jdbc:mysql://127.0.0.1:3306/network_info
	#oracle
	#driver=oracle.jdbc.driver.OracleDriver
	#url=jdbc:oracle:thin:@127.0.0.1:1521:mydb_info
	user=root
	password=root
DBUtils.java
	import java.io.IOException;
	import java.io.InputStream;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.SQLException;
	import java.util.Properties;

	public class DBUtils {
		private static String driver = null;
		private static String url = null;
		private static String user = null;
		private static String password = null;
		private static BasicDataSource dataSource = new BasicDataSource();
		
		static {
			InputStream inputStream = DBUtils.class.getClassLoader().getResourceAsStream("database.properties");
			Properties prop = new Properties();
			try {
				prop.load(inputStream);
				driver = prop.getProperty("driver");
				url = prop.getProperty("url");
				user = prop.getProperty("user");
				password = prop.getProperty("password");
				//使用DBCP连接池
				dataSource.setDriverClassName(driver);
				dataSource.setUrl(url);
				dataSource.setUsername(user);
				dataSource.setPassword(password);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		public static Connection getConnection() throws ClassNotFoundException, SQLException {
			//Class.forName("com.mysql.cj.jdbc.Driver");
			//Connection conn = DriverManager.getConnection(url,user,password);
			//return conn;
			return dataSource.getConnection();
		}
		public static void closeResource(Connection conn, Statement stmt, ResultSet rs){
			if(rs != null){
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(stmt != null){
				try {
					stmt.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(conn != null){
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
	使用连接池时，可以设置一下参数：初始连接数、最大连接数、最小连接数、每次增加连接数、最大空闲连接数、最小空闲连接数、超时时间
	连接数据库或操作数据库时都可能发生SQLException，这类异常通常是由于sql错误、数据库表或数据错误等造成，这类异常属于必检异常。
	获取数据库连接也可以使用try(...)语法来自动关闭数据库连接：
	try(
		Connection conn = DBUtils.getConnection();
		Statement stmt = conn.createStatement();
		ResultSet resultSet = stmt.executeQuery(sql);
	) {
		while (resultSet.next()){
			...
		}
	} catch (ClassNotFoundException | SQLException e) {
		e.printStackTrace();
	}





































































