											java记录
										
										第一章 java的历史和演进

	java继承了其它语言的优秀元素，也提出了自己的新特性、新概念。
计算机编程语言的出现和发展主要是由两个因素推动的，第一个是环境的需要和对环境的适应，第二个是编程思想的演进。
java从C和C++继承了大量的特性。
    C使用的结构化编程模式在编写大型应用程序时其复杂性超出了承受范围，个人认为是普通开发者无法驾驭这样的复杂性导致的。
这将导致企业的开发成本过高，在这种背景下，对开发人员要求更低、同时也更符合普通人思考模式的面向对象模式语言出现了。
    java出现的背景其实是为了实现平台独立，C++程序需要使用为不同CPU编写的编译器编译，C++程序本身也可能设计到操作系统
调用，出现了和操作系统的耦合，难以实现平台独立。而java被设计成基于虚拟机的语言，sun官方提供主流操作系统的虚拟机实现和SDK（包含编译器），
而且不用为每一种CPU提供一个编译器。个人理解是java编译器、虚拟机都只需要和操作系统打交道，而不需要关注CPU。
Internet上的服务器的硬件设施和操作系统的多样性要求开发的程序需要是平台独立的，这也是java兴起的一个重要推动力。
	目前主流的java版本仍然是1.8，学习也以1.8为准。


										第二章 java综述

	两种编程模式：第一种是面向过程编程模式，C语言便是代表，围绕“正在发生什么”编程，代码直接作用于数据；第二种是面向
对象编程模式，围绕“将影响谁”编程，定义了对象这种数据结构，对象封装了数据和操作数据的接口，通过调用对象的接口操作数据，通过组合对象解决复杂性问题。
	OOP三原则：
	封装，即定义对象（类）封装数据和对数据的操作；
	继承，对象（类）可以继承其它对象（类）获得属性和方法，可以减少程序复杂性；
	多态，接口方法只定义功能，不提供具体实现，不同实现类可以选择不同的实现方式。
	
	开发环境搭建：安装JDK1.8
	配置环境变量：JAVA_HOME	JDK安装路径
				 path		添加;%JAVA_HOME%\bin
				 CLASSPATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
				 //从jdk1.6开始，不需要再配置 classpath环境变量

	编译程序：javac Example.java
	注：编译程序需要注意，Windows中文下使用javac编译默认会以GBK编码解析源文件，如果源文件使用了其他编码，如UTF-8，就会报错：
		错误:编码GBK的不可映射字符
	可以通过修改文件编码为GBK（ANSI）解决这个问题，也可以通过参数告知编译器源码编码：
		javac -encoding UTF-8 Example.java
	运行程序：java Example
	打印classpath：System.out.println(System.getProperty("java.class.path"));
	关于dt.jar和tools.jar、rt.jar：
		dt.jar是BeanInfo(swing的BeanInfo)文件的DesignTime归档，集成开发环境（IDE）使用这些BeanInfo显示Java组件和设置属性编辑器。
		tools.jar是关于一些工具的类库，主要是jdk工具，包括javac,java,javap，javadoc等(集成开发环境也使用这些工具)。
		rt.jar位于：{Java_Home}/jre/lib/下，是JAVA基础类库，也就是在java doc里面看到的所有的类的class文件，
		rt.jar 默认就在Root Classloader的加载路径里面的，jre/lib目录下的，其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar
		也都在Root Classloader中，所以不需要手动添加到环境变量CLASSPATH中。
	
	新建类：com.zhangwei.javademo1.MainClass
	编译时进入最内层的目录(javademo1): javac MainClass.java
	执行时到最外层目录(com目录同级)：java com.zhangwei.javademo1.MainClass
	打包：在最外层目录(com目录同级)建manifest.txt文件：
		Manifest-Version: 1.0
		Main-Class: com.zhangwei.javademo1.MainClass
	manifest.txt最后一行为空行，并且manifest.txt文件换行符需要使用linux的换行符(windows回车换行符：\r\n无效，linux换行符：\n)
	打包命令：jar -cvfm aa.jar manifest.txt com
	执行jar：java -jar aa.jar
	编译自动生成包目录：
		在任意目录下新建类:com.zhangwei.javademo1.MainClass
		在该目录下编译： javac -d . *.java	//将编译结果输出到其他目录 javac -d /tem_file/demo1 *.java
		在该目录下会生成包目录和class文件：com/zhangwei/javademo1/MainClass
		在该目录下执行：java com.zhangwei.javademo1.MainClass
		执行其他目录下的class文件：java -classpath e:/tem_file/demo1 com.zhangwei.javademo1.MainClass 
		

										第三章 数据类型

	强类型的语言有利于在代码编译时进行检测，因此可以避免很多不必要的问题，增强程序的安全性和健壮性。
	java的八种基本数据类型：
		整数型：byte、short、int、long；
		浮点型：float、double；
		字符：char；
		布尔值：boolean；
	int型最大值：2^31-1 = 2147483647；最小值-2^31 = -2147483648；
	java运行时字符类型使用utf-16编码存储，并且只使用16位即两个字节，所以java的char类型只能取unicode码点小于等于  
65535的字符。而unicode码点大于65535的字符由于需要4个字节才能保存，所以java直接就在编译期报错。
	从JDK7开始，java可以使用0b或0B开头后跟0和1表示二进制数，也可以使用下划线分隔数字，使得数位较多的数字更好读，例如：	
		int x = 0b1011_1110_1001;
	java默认浮点字面值类型为双精度double型：1.1默认为double类型。
	字符型字面量可以使用这些形式：字符a的三种表示：'a'、97（unicode码点）、'\u0061'(16进制表示)、'\141'(8进制表示);
无法输入的字符还可以使用转义表示法：如换行符使用'\n'。8进制表示并不常用。
	java源代码文件可以使用任意编码，在编译时告诉编译器使用的编码即可，在编译生成的class文件中，字符使用一种改进的UTF-8
编码存储，一个字符最多使用2个字节存储，所以不能处理码点大于65535的字符，这也是为虚拟机内部运行时使用改进的UTF-16编码提供
保障。
	汉字：𤭢	unicode码点为：150370 大于65535，因此无法作为java的单个字符输入，可以使用字符串表示：
String cs = "𤭢";但是cs.length()返回2。
	对于码点小于65535的字符，可以通过以下方式获得其码点：
		String s2 = "中";
        long hash2 = s2.hashCode();
		这里获得的hash值就是该字符的Unicode码点。
	byte使用8位，表示范围：-128~127
	一个奇怪的错误与类型提升：
		byte b = 50;
		b = b * 2;
	上面的代码将会报错，这是由于b在参与运算b * 2时，进行了类型提升，实际参与运算的类型变成了int，结果也就成了int值
，而将结果赋值给byte型的b就出错了。
	实际上，在没有long、float、double类型变量参与运算时，byte、short、char都会提升为int型的值，有long参与就提升为
long型，有float参与就提升为float型，有double参与就提升为double型。
	java不允许使用未初始化的值。
	数组的声明：int arr[];初始化：int arr[] = new int[10];这种初始化后的数组中都是0；
	更常用的初始化方式：int arr[] = {1,2,3,4,5};
	多维数组：int arr2[] = new int[4][5];也可以只指定第一维的长度：int arr2[] = new int[4][];第二维的长度可以
不相同。
	声明数组的另一种写法： int[] arr;也可以是: int [] arr;
	同时声明多个实例变量：private String s1="1", s2="2";	//也可以不初始化
	局部变量也可以这样写：String s3="3",s4="4";
	实例变量不初始化可以直接使用，因为在创建实例时会赋予实例变量默认值，但是局部变量使用前必须被显式赋值，否则会编译不通过。


										第四章 运算符与条件语句

	左移运算符：<<	在不越界的情况下相当于乘以二： 2<<2 == 8
	右移运算符：>>	在不越界的情况下相当于除以二： 8>>2 == 2,右移使用了符号扩充，所以-1右移总是得到-1.
	无符号右移：>>>	右移不使用符号扩充：所以-1>>>2 == 2^30-1.
	if(c==1 & e++ < 100) d=100;这种写法表示无论c是否等于1，都会对e执行自增1，c等于1且e小于100则d赋值为100.

	switch语句：
		switch(exp){
			case const1:
				...;
				break;
			case const2:
				...;
				break;
			...
			default:
				...;
		}
	assert: JDK1.4引入，用法：
		1、assert <boolean表达式>
			如果<boolean表达式>为true，则程序继续执行；如果为false，则程序抛出AssertionError，并终止执行。
		2、assert <boolean表达式> : <错误信息表达式>
			如果<boolean表达式>为true，则程序继续执行；如果为false，则程序抛出java.lang.AssertionError，并输入<错误信息表达式>。
		public class AssertDemo1 {
			public static void main(String[] args) {
				assert true;
				System.out.println("go ooooo!");
				assert false : "error eeeeee!";
				System.out.println("end!");
			}
		}
	assert关键字需要在运行时候显式开启才能生效，否则断言就没有任何意义.
		命令行执行：java -ea AssertDemo1
		IDE添加VM参数： -ea
	assert关键字本意上是为测试 调试程序时使用的，不应该用assert来控制程序的业务流程（不能用来替换if。
	JDK7之前exp只能是byte、short、int或枚举类型，现在可以是String类型。case后只能是常量表达式，且不能重复。
	和break、continue连用的标签用来标记代码块，break或continue加标签只能跳到所在的代码块标签处，即break或continue
后的标签必须是当前代码块或当前代码块的上级代码块。
	^ :异或运算符，对两个操作数进行按位异或，即只有一个1取1，否则取0：-1 ^(-1 << 12) --> 4095


										第五章 类和对象

	每个类都定义了一种数据类型（数据结构），声明对象的对象名只是一个变量，通常称为对象引用，大体上可以认为是为对象所分配内存的地址，
但不能像操作指针那样去操作对象引用。new运算符在运行时动态为对象分配内存。
	默认构造函数自动将所有实例变量初始化为其对应类型的默认值：数字为0，布尔为false，对象为null，char为码点为0的字符
	finalize方法的一般形式：
		protected void finalize(){
			...;
		}
	finalize方法通常是jvm在销毁对象前调用以完成一些特殊工作。
	方法调用时的自动类型提升：
	如果只定义了test(double i)；实际上是可以使用test(1)的；
	方法的重载本质上是编程思想的进步，即在方法功能层面上的抽象，例如多个重载的构造方法功能上是一致的，都是为了创建和
初始化对象。
	包表达的是一群在一起的类；
	访问控制和修饰符：public表示可以在任何地方访问修改，private表示只能在类所定义的方法中访问和修改，默认（无访问
修饰符）表示同包下的类可以访问修改，protected表示子类可以继承的属性，跨包的子类中也不能访问父类对象的protected控制
属性，但可以继承。
子类和父类不在同一个包下，子类中也不能访问修改父类对象的默认访问控制属性。
	子类只能继承由 protected 和 public 和无修饰符的的属性，private属性不能被继承。子类跨包则不能继承默认访问控制的属性。
	静态内部类只能访问外部类的静态属性，非静态内部类可以定义在需要的任意代码块中。
	静态内部类并不会在主类被加载和初始化时加载，而是在实际使用(引用)时才被加载。类的加载和初始化总是线程安全的。
	（静态）内部类可以访问外部类的（静态）私有属性和方法。
	通过外部类的实例对象创建内部类对象：
		Demo1 demo1 = new Demo1();
		InnerClass inner = demo1.new InnerClass();
    可变长参数方法：（varargs方法）：
		void test(String msg, int ... v){
			System.out.println(msg+" ; length of v is "+v.length);

		}
    调用： 
		test("hello",1,2);
    	test("hello",1,2,3);
    	test("hello");
    变长参数实际是一个数组。
	
	继承：
	继承的一个好处是可以实现代码复用，创建的子类模型不需要重新声明已经在父类中定义的熟悉和方法，这样写出来的代码就
显得清晰很多。
	可以使用超类的类型变量指向子类的实例对象，这有一些实际的好处，比如说作为多态的一种实现方式，但是需要注意使用
超类的类型变量只能访问在超类中定义的变量和方法，而不能使用实际子类定义的成员。
	子类的构造函数中使用super(args);调用父类的构造函数；并不会创建父类的对象，但是会为父类定义的属性分配内存（堆
空间中）；子类对象调用继承父类的方法时，首先找到与该方法静态绑定的父类字节码对象，再找到和父类字节码对象动态绑定的
父类属性所分配的内存空间。
	如果子类中定义了父类中已有的属性或方法，还是可以使用super访问父类中的对应属性或方法。
	方法的重写和重载是不一样的概念，重写是指子类的方法签名和父类的方法签名完全相同时隐藏父类方法的机制，而重载的方法
的签名是不同的（方法名相同，但是参数类型不同）。
	子类重写父类的方法时，返回值类型不需要和父类保持完全相同，只需要是父类方法返回值类型的子类型就可以（称为 协变返回类型）：
		class MyList<E> extends ArrayList<E>{
			//重写了父类中的Object[] toArray()方法
			public Integer[] toArray(){
				return new Integer[]{1,2};
			}

			public Object getObj(){
				return 1;
			}
		}

		class SubList<E> extends MyList<E>{
			//重写父类中的Object getObj()方法
			public Integer getObj(){
				return 2;
			}
		}
	其实，java的方法签名只包括 方法名和参数，并不包括方法返回值。
	方法的重写是java动态方法调度的基础。所谓动态方法调度其实就是运行时多态，运行时根据对象实例的类型决定使用哪一个
重写方法。
	方法重写提供了“一个接口，多种方法”的特性。
	不能创建抽象类的实例对象，这也说明在构造子类对象实例时不会创建父类的对象。
	通常java在运行时动态分析对方法的调用（方法的源），这称为后期绑定；而final方法不能被重写，所以对final方法的调用
可以在编译期间解析，直接将final方法的源例程字节码和方法的编译代码内联在一起，这称为早期绑定。
	

											第六章 包和接口

	java使用文件系统的目录存储包，目录名和包名必须精确匹配。
	具有确定的包的对象，包名是对象的名称空间的一部分，所以使用java命令运行时不能只写类名。
	一个类implement一个接口时，如果没有全部实现接口中的方法，那么这个类需要被声明为抽象类；接口中未实现的方法将由
继承该类的子类进行实现。
	可以将接口声明为一个类或另一个接口的成员，这称为嵌套接口。引用嵌套接口时必须包含嵌套接口的外层类或接口名进行限定。
	JDK8提供接口的默认方法的动机主要有两点：一个是扩展原有接口的功能而不破坏已有的代码；第二个是为本质上可选的方法提供
默认实现（空实现）以免除实现类自己去提供空实现冗余代码。
	尽管可以提供接口的默认实现，但是仍然不能创建接口的实例对象，接口不能维持状态信息的基本特性没有发生变化。现在的接口
看起来和抽象类已经很相像了。
	default String getName(){
        return "hello";
    }
	接口的实现类可以重写接口中的默认方法实现。
	当一个类实现了多个接口，而每个接口都定义了默认实现的方法，则这个类确实相当于继承了多级父类的行为。
	JDK8新增了接口可以添加静态方法的特性，接口的静态方法像类的静态方法一样，通过接口名直接调用，但是实现类不会继承
接口的静态方法。


											第七章 异常处理

	异常是什么？
	异常是程序运行时发生的错误，在编译期不能确定运行时一定会出现错误，但是可能会在运行时发生错误，比如读取一个输入值
作为除数，如果输入0就会发生除零异常。
	异常分为系统抛出异常和手动抛出异常，系统抛出异常通常是违反了一些基础的环境约束，手动抛出的异常通常用于向方法调用
者反馈错误条件等。
	JDK7新增带资源的try语法：待续....
	异常的类型：公共父类：Throwable,其对应两个子类：Exception和Error，Exception代表用户应该捕获处理的异常，Error通常
是运行时环境本身出现错误，比如堆栈溢出，自己的程序一般不会处理。Exception的子类RuntimeException通常作为自定义的异常
的父类。
	如果自己不捕获处理异常，java运行时系统会使用默认的处理程序捕获处理：输出描述字符串，打印堆栈，结束程序。
	使用try...catch捕获异常可以让程序继续运行下去。
	Throwable重写了Object的toString方法，可以返回异常描述字符串。同时Throwable定义了getMessage方法返回这个字符串。
	必检异常：
	除了Error和RuntimeException及其子类的其他所有异常都必须被try...catch处理或者在方法签名中使用 throws 声明抛出。
	非必检异常：
	通常是RunctimeException的子类，如：ArithmeticExcetion,NullpointerException等。
	finally{...}代码块总是会执行。
	链式异常：
	Throwable(Throwable e) JDK1.4增加的构造链式异常的构造方法，增加方法：initCause(Throwable e)和getCause()设置和
返回内层异常。
	JDK7新增多重捕获语法：catch(AExcetion | BException e){...}
	使用自定义异常通常用于表示操作失败。
	非必检异常的用意：非必检异常表示的是语义上可能会出现的异常，如空指针异常，任何对象属性、方法的访问语义上都可能
抛出，但是设计成熟的程序不会抛出该异常。自定义异常不需要捕获的设计目的在于，这类异常通常只是在程序的最外层处理，中
间层并不需要麻烦地去捕获再抛出。
	java预定义的非必检异常通常不会发生（设计良好，经过充分测试的程序不应该发生这些异常），必检异常则不能得到这种保证，
比如文件异常（如文件错误），一旦发生这些异常就会严重影响程序执行，所以必须捕获处理。
	自定义异常表示的是由于不确定因素（比如网络故障）导致的程序必需元素的缺失或损坏导致程序不能正常执行时进行的情况，
比如网络故障导致的参数错误或丢失，这类问题不是程序设计上的漏洞，而且发生后会导致程序不能继续执行，对于这类异常通常也是
不能直接处理的，只能进行日志记录。
	接口参数校验问题：对外接口的参数校验不通过，不应该抛出异常，这不是程序的错误，而是调用方的问题。但是实际应用中，不管
是参数缺失、参数类型错误，还是参数不满足业务校验，通常都是抛出自定义的异常，然后在应用的最外层捕获处理。对于http请求接口时，
参数缺失、类型错误等，应该在捕获异常后返回400错误码和对应的错误提示信息，但是很多web框架并没有这样做，而是直接返回了500
错误码，个人是不认可这种做法的。http请求中，如果是参数不满足业务校验，捕获异常后最好返回422错误码和相关错误提示信息。
这样基于http协议的前后端通信才符合http语义。


											第八章 并发编程

	多线程需要的开销比多进程要小，进程需要自己的地址空间，进程间通信开销大而且限制多，从一个进程上下文切换到另一个
进程上下文开销很大。多线程共享相同的地址空间，互相通信开销较小，上下文切换开销也很小。
	单线程的问题是遇到一些非CPU处理的耗时任务时，CPU只能空闲等待，如IO操作。多线程就是为了处理这种问题。
	单线程系统使用轮询事件循环机制，当某个处理事件阻塞时，系统将等待阻塞。多线程则允许某个线程阻塞时，其它线程继续
运行。同时，多线程可以更好地利用多核系统的处理能力。
	线程的状态：
	运行、挂起、恢复、阻塞。
	java为每一个线程都指定了优先级，是一些整数，指定的是一个线程相对于另外一个线程的优先程度。优先级决定了线程间的
上下文切换。发生上下文切换的时机：一是运行中的线程主动放弃控制，二是高优先级线程抢占控制权。windows系统下多个同优先
级的线程会循环获得CPU资源，其它操作系统则需要运行中的线程主动放弃。
	java的对象具有隐式监视器，在一个线程调用对象的同步方法时，就会获得监视器，从而其它线程不能调用该对象上的同步方法。
	Thread实例对象是线程的代理，定义了一些用于帮助管理线程的方法：getName()、getPriority()、isAlive()、join()、
run()、sleep()、start()等。
	子线程都是主线程产生的，通常主线程必须是最后结束执行的线程，需要执行各种关闭操作。
	Thread.currentThread()静态方法，获取运行中的线程的引用。Thread.sleep(n)静态方法，运行中的线程休眠n毫秒。
	线程组是将一类线程作为整体来控制状态的数据结构。
	创建线程的两种方式：实现Runnable接口和继承Thread。都需要实现或重写run方法。
	实现Runnable接口比继承Thread的好处是可以继承其它类。
	Thread的实例方法：isAlive()返回线程是否还在运行，join()方法等待线程执行完成后调用线程才继续执行。
	具有相同优先级的线程应该时不时地释放CPU控制权，以避免在某些系统中（非抢占式系统）一些线程不能执行。
	竞态条件：多个线程调用同一个对象的非同步方法。
	同步方法和同步代码块：
	方法使用 synchronized 修饰，当一个线程调用该方法时，则其它线程不能调用该对象上的所有同步方法。
	synchronized(obj){.....} obj是目标对象，即待执行方法所属的对象。同步代码块用于目标对象的方法不能被修改成同步方法，
所以在调用方法时对调用代码进行同步。
	使用wait()、notify()、notifyAll()实现线程间通信：
	wait()方法调用将挂起当前线程，直到有线程调用notify()或notifyAll()唤醒此线程。
	死锁问题：当一个线程调用了对象A的同步方法m，并且将要在m方法中调用对象B的同步方法x，同时另一个线程调用了对象B的某个
同步方法y，并且在方法y中调用对象A的同步方法n，这样线程一持有对象A的锁，需要获得对象B的锁，而线程二持有对象B的锁，需要
获得对象A的锁，形成了死锁，程序将不会结束。
	java 1.0时代使用Thread类定义的suspend()、resume()、stop()方法挂起、恢复、停止一个线程，但是现在不再使用了，它们都有
潜在的危险。现在的操作线程状态的手段主要是在run方法中根据一个对象标志变量决定是否挂起线程，同时在另外的方法中可以修改
该标志变量和唤醒挂起的线程。
	Thread定义了getState()方法返回线程的状态，返回值是Thread.State类型值，包括RUNNABLE、NEW等状态，事实上该返回值不能
反映之后一段时间的线程状态，所以并不能用来作同步使用，而是为了调试程序使用。


										第九章 枚举和注解

	java中的枚举是一种类类型，使用enum关键字定义枚举：
		enum Apple{
			Jonathan, GoldenDel, RedDel, Winesap, Cortland
		}
	每一个枚举常量都隐式的声明为枚举类公有的、静态的、final成员，即public static final XXX xxx。
	枚举常量的使用：Apple app;  app = Apple.Jonathan; if(app == Apple.Jonathan){...}  
		switch(app){
			case Jonathan:
				...
			case Winesap:
				...
		}
	所有枚举类都具有两个静态方法：values()和valueOf();
	Apple [] allApples = Apple.values();
	Apple app = Apple.valueOf("Jonathan");
	枚举类可以定义实例变量和构造方法：
		enum Apple {
			Jonathan(10), GoldenDel(9), RedDel, Winesap(15), Cortland(8);
			private int price;
			Apple(int price){
				this.price = price;
			}
			Apple(){
				this.price = 0;
			}
			int getPrice(){
				return this.price;
			}
		}
	枚举类的两个要点：定义的枚举类不能继承其他类，枚举类不能作为超类。
	所有的枚举类都继承自Enum类，Enum类定义了3个实例方法：
		final int ordinal();	//返回调用枚举常量的序数值（从0开始），如Apple.Jonathan.ordinal(); //0
		final int compareTo(enum-type e); 	//返回与参数枚举常量的序数值的差值正负结果： Apple.Jonathan.compareTo(Apple.GoldenDel);  // -n(负数)
		final boolean equals(enum-type e);  //比较两个枚举常量的相等性
	说明一下：equals比较时只需要两个枚举常量是同一个枚举类中相同的常量即可成立，而==比较的是引用；如果是通过网络传输的一个
枚举常量和本地的一个枚举常量比较，则使用equals比较成立，而二者引用是不同的。
	装箱、拆箱和自动装箱、自动拆箱：
	JDK1.5之前的基本数据类型封装类使用：
		Character(char c);		char charValue();
		Boolean(boolean b);		boolean booleanValue();
		...
	JDK1.5新增自动装箱和自动拆箱：
		Inteter iob = 100;
		++iob;
		Boolean b = true;
		if(b) ...
		Character c = 'x';
	不应该滥用自动装拆箱，否则会影响程序性能。
	JDK5新增了注解语法，用于在源文件中嵌入补充信息，主要是便于其它工具获取这些信息。
	注解定义语法：
		@interface MyAnno {
			String str();
			int val();
		}
	注解定义语法不能使用extends继承其它类，实际上所有注解都扩展了Annotation接口,Annotation接口重写了toString、equals和
hashCode方法。
	注解使用：
		@MyAnno(str = "example", val = 100)
		public static void meMethod();
	保留策略：RetentionPolicy枚举类定义了三种枚举常量保留策略：SOURCE、CLASS、RUNTIME。
	使用内置注解@Retention声明注解的保留策略：(默认是RetentionPolicy.CLASS)
		@Retention(RetentionPolicy.RUNTIME)
		@interface MyAnno {
			String str();
			int val();
		}
	Class、Method、Field、Constructor对象上定义了getAnnotation(Class<A> annoType)和getAnnotations()方法，前者返回指定
的注解，后者返回所有的注解。这两个方法来源于AnnotatedElement接口。Package也实现了该接口。该接口定义的另外的可用的方法还有：
		Annotation [] getDeclaredAnnotations();			//返回所有的非继承的注解
		boolean isAnnotationPresent(Class<A> annoType);	//是否使用了指定注解修饰
		...
	注解属性的使用：
		MyAnno myAnno = ...;
		String str = myAnno.str();
	设置注解属性默认值：
		@Interface MyAnno {
			String str() default "test";
			int val() default 100;
		}
	标记注解：没有属性，使用时不使用括号：@Mark
	单成员注解：
		@interface MyAnno {
			String value();
		}
	或者
		@interface MyAnno {
			String value();
			int val() default 100;
		}
	使用：
		@MyAnno("hello")
		public static void test();
		或者：
		@MyAnno(value="hello",val=55)
		public static void test();
	内置注解：@Retention声明注解的保留策略；@Documented声明注解将被文档化；@Target声明注解能修饰的数据类型：其参数只能
是ElementType枚举类中的常量：FIELD、LOCAL_VARIABLE、METHOD等；@Inherited声明注解可以被修饰类的子类继承；
	类型注解的声明：
		@Target(ElementType.TYPE_USE)
		@interface Unique{}
	类型注解有什么用？首先类型注解用在类型之前，用于修饰类型，比如说使用上面的@Unique修饰一个类的构造方法（或者某种类型
的成员变量），然后第三方工具可以使用该注解来检查该类是否只声明了一个构造方法（某种类型的变量）。
	重复注解：
		@Retention(RetentionPolicy.CLASS)
		@Repeatable(MyAnnoContainer.class)
		@interface MyAnno{
			String str();
			int val();
		}

		@Retention(RetentionPolicy.CLASS)
		@interface MyAnnoContainer{
			MyAnno [] value();
		}
	应用：
		@MyAnno(str="aaa",val=11)
		@MyAnno(str="bbb",val=22)
		public void test(){}
		
		Annotation anno = m.getAnnotation(MyAnnoContainer.class);m是test方法的反射对象


										第十章 IO基础及其他

	java使用“流”进行输入输出抽象，“流”是一种对接对象，输入流和输入源对接，提供一系列方法从数据源获取数据，输出流提供一系列
方法将数据导出到目的地。java提供基于字节操作和字符操作的两类流。
	字节流家族：
		InputStream、BufferedInputStream、ByteArrayInputStream、DataInputStream、FileInputStream等
		OutputStream、BufferedOutputStream、ByteArrayOutputStream、DataOutputStream、FileOutputStream等
	字符流家族：
		Reader、BufferedReader、CharArrayReader、FileReader等
		Writer、BufferedWriter、CharArrayWriter、FileWriter等
	System类有三个静态的预定义流成员变量：out、in、err. in是InputStream的实例对象，out和err是PrintStream的实例对象。
	可以使用BuffredReader读取控制台输入：
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
	BufferedReader的read方法读取单个字符，readLine方法读取一行字符串。System.in采用按行缓冲。
	向控制台输出使用PrintWriter和使用System.out(PrintStream)的区别（好处）在于更好的国际化支持。
	读写文件：使用文件名构造FileInputStream和FileOutputStream 的实例对象都可能抛出文件不存在异常，对于输出流其实是指
不能打开文件或者创建文件，如果有原文件会先销毁原文件。
	JDK1.7之前需要手动关闭流，JDK1.7新增了“自动资源管理”的特性，对于实现了AutoCloseable接口的资源类，可以使用扩展的try
语法实现自动关闭资源，事实上所以流都实现了该接口，所以可以使用该新特性。
		try(FileInputStream fin = new FileInputStream("fileName")){
			...
		}
	try后括号中的资源实际上被隐式声明成final类型，所以不能修改。
	
	io包下的类和接口详细介绍：
	字节输入流：
		InputStream、BufferedInputStream、ByteArrayInputStream、DataInputStream、FileInputStream、FilterInputStream、
		ObjectInputStream、PipedInputStream、PushbackInputStream、SequenceInputStream
	字节输出流：
		OutputStream、BufferedOutputStream、ByteArrayOutputStream、DataOutputStream、FileOutputStream、FilterOutputStream、
		ObjectOutputStream、PipedOutputStream、PrintStream
	字符输入流：
		Reader、BufferedReader、CharArrayReader、FileReader、FilterReader、InputStreamReader、LineNumberReader、PipedReader、
PushbackReader、StringReader
	字符输出流：
		Writer、BufferedWriter、CharArrayWriter、FileWriter、FilterWriter、OutputStreamWriter、PipedWriter、PrintWriter、
StringWriter
	文件相关类：
		File、FileDescriptor、FilePermission、RandomAccessFile
	其他类：
		Console、ObjectInputStream.GetField、ObjectOutputStream.PutField、ObjectStreamClass、ObjectStreamField、SerializablePermission、
StreamTockenizer
	接口：
		Closeable、DataInput、DataOutput、FileFilter、FilenameFilter、ObjectInput、ObjectOutput、ObjectInputValidation、
ObjectStreamConstants、Serializable、Externalizable、Flushable
	
	File类的实例对象用来抽象目录或文件，构造方法：
		File f1 = new File("D:/");
		File f2 = new File("D:/","book");
		File f3 = new File(f1,"book");
		File f4 = new File(f2.toURI());
	在windows下路径分隔符也可以使用\，但是需要转义成：\\	例如：new File("D:\\book");
	File提供一系列实例方法获取/操作对应文件或目录的属性信息：
		File f1 = new File("/tem_file/threadinfo.txt");		//windows下默认盘符为代码运行所在的盘符
        System.out.println("file name: "+f1.getName());
        System.out.println("file path: "+f1.getPath());
        System.out.println("file abs path: "+f1.getAbsolutePath());	//windows下包含盘符
        System.out.println("file parent: "+f1.getParent());
        System.out.println("file exists ? "+f1.exists());
        System.out.println("file can write? "+f1.canWrite());
        System.out.println("file can read? "+f1.canRead());
        System.out.println("file is directory？ "+f1.isDirectory());
        System.out.println("file is file? "+f1.isFile());			//某些文件(设备驱动、管道等)返回false
        System.out.println("file is abs? "+f1.isAbsolute());		//文件是否是以绝对路径创建
        System.out.println("file last modified: "+f1.lastModified());
        System.out.println("file size: "+f1.length()+" bytes");
        System.out.println("---------");
        boolean result = f1.renameTo(new File("D:/tem_file/threadinfo3.txt"));
        System.out.println("file rename to success? "+result);
        System.out.println("file name: "+f1.getName());		//rename后f1还是原来的名字
        System.out.println("file exists ? "+f1.exists());	//rename后磁盘下原文件被删除
        result = f1.delete();								//rename后删除原文件失败
        System.out.println("file delete success? "+result);
		System.out.println("---------");
		System.out.println("disk part free space: "+f1.getFreeSpace());		//文件所在分区剩余空间（字节）
        System.out.println("disk part total space:"+f1.getTotalSpace());
        System.out.println("disk part usable space:"+f1.getUsableSpace());
        System.out.println("file is hidden? "+f1.isHidden());
        System.out.println("file modify lastModifiedTime success? "+f1.setLastModified(new Date().getTime()));
        System.out.println("file set readOnly success? "+f1.setReadOnly());
		//System.out.println(f1.setWritable(false));	和setReadOnly方法作用相同
	获取目录下的文件/目录：
		File f1 = new File("/tem_file");
		String[] fs = f1.list();	//获取所有文件、目录名称
	使用FilenameFilter过滤文件：
		public class MyFilenameFilter implements FilenameFilter {			
			@Override
			public boolean accept(File dir, String name) {	//这里的第一个参数dir是调用list或listFiles方法的目录对象
				return name.endsWith(".jpg");
			}
		}
		MyFilenameFilter filenameFilter = new MyFilenameFilter();
		String[] fs = f1.list(filenameFilter);
	File [] fs = f1.listFiles();
	File [] fs = f1.listFiles(filenameFilter);
	使用FileFilter过滤文件：
		public class MyFileFilter implements FileFilter {
			@Override
			public boolean accept(File pathname) {
				return pathname.getName().endsWith("txt");
			}
		}
		MyFileFilter fileFilter = new MyFileFilter();
		File [] fs = f1.listFiles(fileFilter);
	创建目录：
		File dir1 = new File("/tem_file/dir1");
        boolean result = dir1.mkdir();	//如果tem_file不存在则创建目录会失败
		File dir2 = new File("/tem_file/dir0/dir2");
		result =dir2.mkdirs();	//上层目录不存在就先创建上层目录
	FileDescriptor可以看作是文件（这里的文件是广义的文件）的另一种抽象，实际上从文件或标准输入输出数据是通过FileDescriptor连接文件
或设备实现的，例如System.in、System.out、System.err都是使用FileDescriptor中的预定义实例in、out、err构造的。
	FileDescriptor不能直接操作文件，需要配合相应的流使用：
		FileDescriptor fd = new FileInputStream("/tem_file/file4").getFD();
		FileInputStream input = new FileInputStream(fd);
        char c = (char)input.read();
		//FileOutputStream out = new FileOutputStream(fd);	//这里不能使用FileInputStream对象的FileDescriptor构造FileOutputStream
        //out.write(5);										//否则这里将会报IOException：拒绝访问
	通过FileInputStream或FileOutputStream对象拿到的FileDescriptor只能用来构造同类型的输入流或输出流，这是由java的安全管理器控制的。
	接口Closeable和Flushable在JDK1.5引入，位于io包下；AutoCloseable接口在JDK1.7引入，位于lang包下，并且把Closeable接口修改为
AutoCloseable接口的扩展接口。目前所有打开流的IO类都实现了AutoCloseable接口，实现了Closeable接口的类也默认实现了AutoCloseable接口.
AutoCloseable接口定义了close方法，在try(...)语法中使用实现了AutoCloseable接口的流，会在try语句的末尾自动调用该流对象的close方法。
	Flushable接口定义了方法flush，输出流都实现了这个接口，调用这个方法，通常会将缓存的输出写出到物理设备中。
	InputStream是一个抽象类，定义了java的字节流输入模型，实现了AutoCloseable接口和Closeable接口，这个类定义了大部分通用的功能方法：
		int available();			//返回当前可读取的字节数
		void close();
		void mark(int num);			//在的当前位置放置标记，在继续读取完num个字节之前，这个标记一直有效
		boolean markSupported();	//返回当前流是否支持mark或reset方法
		int read();					//返回一个字节，到达文件末尾时返回-1
		int read(byte[] buffer);	//尝试读取buffer.length个字节到buffer中，返回实际读取的字节数，文件末尾返回-1
		int read(byte[] buffer,int offset, int num);	//尝试读取num个字节到buffer中，从buffer[offset]开始保存，返回实际读取
														  的字节数，文件末尾返回-1
		void reset();				//将读取指针重置到mark标记的位置
		long skip(long num);		//跳过num个字节，返回实际跳过的字节数
	OutputStream是定义java字节流输出模型的抽象类，实现了AutoCloseable、Closeable、Flushable接口，方法：
		void close();
		void flush();				//清空输出缓冲区
		void write(int b);			//写出单个字节（int类型的低8位）
		void write(byte[] buffer);	//写出字节数组
		void write(byte[] buffer,int offset,int num);	//写出字节数组buffer从buffer[offset]开始num个字节
	FileInputStream重写了InputStream的6个方法，可以使用两个构造方法，都会抛出FileNotFoundException：
		FileInputStream fin1 = new FileInputStream("/tem_file/threadinfo1.txt");
        File f2 = new File("/tem_file/threadinfo2.txt");
        FileInputStream fin2 = new FileInputStream(f2);
	FileInputStream对象不能使用reset()方法，调用这个方法将抛出异常，调用markSupported方法返回false。
	FileOutputStream可以使用4个构造方法：
		FileOutputStream fout1 = new FileOutputStream("tem_file/file1");	//如果文件不存在，就会创建该文件，否则会销毁原文件
																			  后再新建该文件
		FileOutputStream fout1 = new FileOutputStream("tem_file/file1",true);	//如果文件存在，将内容追加到原文件中
		File file2 = new File("/tem_file/file2");
		String str = "FileOutputStream is a model for write data to file";
        byte [] buffer = str.getBytes();
        if(!file2.exists()){
            FileOutputStream fout2 = new FileOutputStream(file2);			//文件不存在
			fout2.write(buffer);
            fout2.close();
        }
        else {
            FileOutputStream fout3 = new FileOutputStream(file2,true);		//文件存在时将内容追加到原文件中
			fout3.write((int)'\n');
            fout3.write(buffer,0,buffer.length/2);
			fout3.close();
        }
	ByteArrayInputStream使用字节数组作为输入流的数据源，提供两个构造方法：
		String str = "ByteArrayInputStream is a inputstream which use byte array as datasource";
        byte [] source = str.getBytes();
        ByteArrayInputStream baIn1 = new ByteArrayInputStream(source);
        ByteArrayInputStream baIn2 = new ByteArrayInputStream(source,source.length/2,source.length/2-1);
    这个输入流不需要调用close来关闭。
	ByteArrayInputStream可以使用mark方法和reset方法，使用mark方法标记的位置在reset后是read读取的前一个位置，即从这个位置的下一个
位置处开始读取。
	ByteArrayOutputStream将数据保存到内存中的某个字节数组中，可以使用2个构造方法：
		ByteArrayOutputStream baout = new ByteArrayOutputStream();		//字节数组默认32字节
		ByteArrayOutputStream baout = new ByteArrayOutputStream(100);	//100字节的字节数组
	保存数据的字节数组的大小是可以调整的（即使在构造这个对象时设置了缓冲区大小），ByteArrayOutputStream对象使用内部变量buf代表保存
的字节数组，使用内部变量count表示保存数据的字节数量。
		System.out.println(baout.size());		//返回内部变量count也就是保存数据的字节数量
		byte [] bytes = baout.toByteArray();	//返回内部变量buf也就是保存数据的字节数组
	ByteArrayOutputStream重写了toString方法，将会返回字节数组中的数据；提供一个writeTo(OutputStream out)方法将这个流的缓冲区的
数据输出到其他流;提供一个reset方法将内部变量count置为0（实现重置）。
		baout.writeTo(new FileOutputStream("tem_file/file3"));
		baout.reset();
		for(int i=0;i<3;i++) baout.write('X');
	java提供具有过滤功能的字节流，这些流封装了底层的通用流，对外提供缓冲、字符转换、原始数据转换等功能。过滤流的父类是FilterInputStream
和FilterOutputStream，这两个流的构造方法都是protected修饰，所以不能直接创建它们的实例对象，通常应该使用它们的子类：BufferedInputStream
等。
	缓冲字节输入流：BufferedInputStream，缓冲字节输出流：BufferedOutputStream
	上面两个带缓冲的流提供缓冲区，所以可以使用skip、mark、reset方法。
	BufferedInputStream调用read方法实际是从缓冲区读数据。可以使用两个构造方法：
		BufferedInputStream bfin = new BufferedInputStream(new FileInputStream("/tem_file/file1"));		//使用默认缓冲区大小（8192字节）
		BufferedInputStream bfin = new BufferedInputStream(new FileInputStream("/tem_file/file1"),8192);//指定缓冲区大小（字节）
	BufferedOutputStream通过减少程序写数据的次数提高性能（先把数据写到缓冲区，缓冲区满了后就会自动写出的文件或设备），有时可能需要手
动调用flush方法来将缓冲区的数据立即输出。
		BufferedOutputStream bfout = new BufferedOutputStream(new FileOutputStream("/tem_file/file2"));//使用默认缓冲区大小（8192字节）
		BufferedOutputStream bfout = new BufferedOutputStream(new FileOutputStream("/tem_file/file2"),8192);//指定缓冲区大小（字节）
	PushbackInputStream提供将若干字节推入到该输入流中的方法，构造方法：
		PushbackInputStream pin = new PushbackInputStream(new ByteArrayInputStream("abcdefg".getBytes()));//回推缓冲区默认1个字节
		PushbackInputStream pin = new PushbackInputStream(new ByteArrayInputStream("abcdefg".getBytes()),32);//指定回推缓冲区大小为32字节
	回推方法：
		pin.unread(pin.read());				//将读出的字节回推
		pin.unread("abc".getBytes());		//回推一个字节数组
		pin.unread("abc".getBytes(),1,2);	//回推一个字节数组的一部分
	回推多个字节时，回推的字节数量不能超过设置的回推缓冲区大小，否则将抛出IOException.
	资料上说，PushbackInputStream的unread方法会造成构造PushbackInputStream对象的原流对象的mark、reset方法失效，但是实际验证却没有这种影响，
需要进一步了解。确定的是，在使用mark、reset方法时，最好使用markSupported检查后再调用。
	SequenceInputStream可以将多个输入流(InputStream)连接起来，不要求这些流必须是相同类的对象，提供两种构造方法：
		SequenceInputStream in = new SequenceInputStream(new FileInputStream("/tem_file/file2"),new ByteArrayInputStream("opqrst.".getBytes()));
		public class InputStreamEnumeration implements Enumeration<FileInputStream> {...}
		Vector<String> fileNames = new Vector<>();
        fileNames.addElement("/tem_file/file1.txt");
        fileNames.addElement("/tem_file/file2");
		InputStreamEnumeration streamEnumeration = new InputStreamEnumeration(fileNames);
		SequenceInputStream in = new SequenceInputStream(streamEnumeration);	//Enumeration接口实例作为参数，如果构造文件输入流的文件
不存在，将会抛出FileNotFoundException,这个异常没有处理（如果在Enumeration接口实例的nextElement方法中构造文件输入流，这个方法不支持抛出异常），
在SequenceInputStream读取时将会抛出空指针异常。
	SequenceInputStream读取时会按照参数设置的顺序读取各个流，每个流（文件输入流）读完后就会被自动关闭，调用SequenceInputStream的close方法会
关闭这个流内部管理的所有未关闭流。
	PrintStream实现了Appendable、AutoCloseable、Closeable接口，提供如下的构造方法：
		PrintStream(OutputStream out);
		PrintStream(OutputStream out, boolean autoFlush);
		PrintStream(OutputStream out, boolean autoFlush, String charSet);
		PrintStream(File file);
		PrintStream(File file,String charSet);
		PrintStream(String filename);
		PrintStream(String filename,String charSet);
	使用PrintStream连接一个文件，如果原文件存在就会销毁该文件后重新创建一个新文件，所以它的append方法并不能追加数据到文件中。
PrintStream对象的format方法和printf方法都可以实现格式化后输出。
		try {
            PrintStream pts = new PrintStream("/tem_file/file2","GBK");
            pts.append('\n');
            pts.append("中文\n");
			pts.printf(Locale.CHINA,"my chinese name is %s, I'm %d years old.\n","张伟",25);
            pts.printf(Locale.US,"my english name is %s\n","john");
			pts.format("hello %s","jenny");
        } catch (FileNotFoundException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }
	DataInputStream继承自FilterInputStream，同时实现了DataInput接口，这个接口中声明了一些可以读取char、int、double类型的
方法，但是这些方法不是用来读取文本文件的，应该用来读取使用DataOutputStream相对应的writeChar等方法写出的数据。DataOutputStream
继承自FilterOutputStream，实现了DataOutput接口，提供直接写char、int、double等类型的方法。
		StringBuffer sb = new StringBuffer();
        try {
            DataOutputStream dos = new DataOutputStream(new FileOutputStream("/tem_file/file3"));
            dos.writeInt(5);
            dos.writeBoolean(true);
            dos.writeChar(98);
            dos.writeDouble(12.56);
            dos.writeFloat(3.14f);
            dos.writeUTF("a爱");
            dos.flush();
            dos.close();

            DataInputStream dis = new DataInputStream(new FileInputStream("/tem_file/file3"));
            int a = dis.readInt();
            boolean b = dis.readBoolean();
            char c = dis.readChar();
            double d = dis.readDouble();
            float f = dis.readFloat();
			String s = dis.readUTF();
            sb.append(a).append(b).append(c).append(d).append(f).append(s);
            dis.close();
            System.out.println("read finished : ");
            System.out.println(sb.toString());
        } catch (IOException e) {
            if(e instanceof EOFException){
                System.out.println("read finished : ");
                System.out.println(sb.toString());
            }
            else {
                e.printStackTrace();
            }
        }
	RandomAccessFile类实现了DataInput和DataOutput接口，所以也可以使用readChar、writeUTF等方法操作文件数据，构造方法使用文件名
或File对象作为参数，还需要传入一个字符串设置打开文件的模式（权限）：
		"r"		---		只读
		"rw"	---		读写
		"rwd"	---		读写执行
	另外，RandomAccessFile提供一个seek方法可以直接设置下次读取的位置（距离文件开始位置的字节数），这也是类名中随机的含义；
setLength可以裁剪或扩展文件的大小，扩展的字节其实是未定义的（这部分数据不可靠）。
		try {
            RandomAccessFile rf = new RandomAccessFile("/tem_file/file3","rwd");
            int a = rf.readInt();
            rf.seek(5);
            char c = rf.readChar();
            System.out.println(a+" : "+c);
            rf.setLength(5);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

	操作文本文件通常应该使用字符流，字符流的基类是两个抽象类：Reader和Writer。
	Reader定义了java的字符输入流模型，实现了Readerable、Closeable、AutoCloseable接口，提供方法：
		int read()；//读取一个字符
		int read(char[] buffer);	//读取buffer.length个字符到字节数组中
		int read(CharBuffer buffer);	//读取到CharBuffer的缓冲区中；
		boolean ready();	//是否需要等待
		void mark(int num);	//标记位置，在继续读取完num个字符前有效
		void reset();
		long skip(long num);	//跳过num个字符
	读取字符时需要注意的是，对于使用两个字节保存的字符，比如utf-8编码的中文，如果使用的输入流没有设置正确的编码，将不能正确的
识别字符。
	Writer定义了java的字符输出流模型，实现了Flushable、Appendable、Closeable、AutoCloseable接口，提供方法：
		Writer append(char c);
		Writer append(CharSequence chars);
		Writer append(CharSequence chars,int begin,int end);
		void write(int c);
		void write(char[] chars);
		void write(char[] chars,int offset,int num);
		void write(String chars);
	InputStreamReader是从字节流到字符流的桥接器，它使用指定的字符集读取字节并将它们解码为字符（实际上是StreamDecoder实现的）。
构造方法：
		InputStreamReader(InputStream in);
		InputStreamReader(InputStream in,String charSet);
	InputStreamReader提供以下方法：
		String getEncoding();
		int read();
		int read(char [] buffer,int offset,int length);
		boolean ready();
	FileReader继承自InputStreamReader。常用构造方法如下，需要处理可能的FileNotFoundException.
		FileReader fileReader = new FileReader("/tem_file/file1.txt");
		FileReader fileReader = new FileReader(new File("/tem_file/file1.txt"));
	FileReader的read方法无法设置文件编码，所以只能从UTF-8编码的文件中正确读取中文，如果需要读取其他编码的中文文件，可以直接使用
InputStreamReader。
	FileReader不支持mark、reset方法。
	FileWriter常用构造方法：
		FileWriter fileWriter = new FileWriter("/tem_file/file1.txt");
		FileWriter fileWriter = new FileWriter("/tem_file/file1.txt",true);
		FileWriter fileWriter = new FileWriter(new File("/tem_file/file1.txt"));
		FileWriter fileWriter = new FileWriter(new File("/tem_file/file1.txt"),true);
	CharArrayReader使用字符数组或字符数组的子集作为输入源，常用构造方法：
		char[] chars = new char["abcde".length()];
		"ancde".getChars(0,"abcde".length(),chars,0);
		CharArrayReader reader = new CharArrayReader(chars);
		CharArrayReader reader = new CharArrayReader(chars,1,2);//从下标1开始取两个字符。
	CharArrayWriter用于将数据输出到一个缓冲区，构造方法：
		CharArrayWriter writer = new CharArrayWriter();  //默认缓冲区大小为32个字节
		CharArrayWriter writer = new CharArrayWriter(4); //指定缓冲区大小，这个值如果不能保存数据，将会自动扩充
	BufferedReader使用缓冲区来加快数据输入，构造方法：
		BufferedReader reader = new BufferedReader(new FileReader("/tem_file/file1.txt"));//默认缓冲区大小为8192字节
		BufferedReader reader = new BufferedReader(new FileReader("/tem_file/file1.txt"),9999);
	BufferedWriter使用缓冲区来减少写出到文件或设备的次数，构造方法：
		BufferedWriter writer = new BufferedWriter(new FileWriter("/tem_file/file.txt"));//默认缓冲区大小为8192字节
		BufferedWriter writer = new BufferedWriter(new FileWriter("/tem_file/file.txt"),9999);
	PushbackReader是前面的PushbackInputStream的字符流版本，用法和PushbackInputStream基本相同，只是操作的数据变成了字符。
	PrintWriter是PrintStream的面向字符的版本，提供如下构造函数：
		PrintWriter(OutputStream out);
		PrintWriter(OutputStream out, boolean autoFlush);
		PrintWriter(Writer out);
		PrintWriter(Writer out, boolean autoFlush);
		PrintWriter(File file);
		PrintWriter(File file, String charSet);
		PrintWriter(String filename);
		PrintWriter(String filename, String charSet);
	PrintWriter提供writer、print、append等方法：
		try (PrintWriter writer = new PrintWriter("/tem_file/file2.txt","GBK");){
            writer.write("中国\n");
            writer.append("美国\n");
            writer.print("日本\n");
            writer.printf("this year is %s","2019");
            writer.format("this month is %d",5);
        } catch (IOException e){
            e.printStackTrace();
        }
	JDK1.6开始提供Console类，这个类提供了比System.in和out更方便易用的方法。需要通过System.console获取Console对象：
		Console console = System.console();
        if(console == null){		//在IDEA等IDE工具中不能获取到Console对象
            return;
        }
        String name = console.readLine("please input your %s: ","name");
        char[] password = console.readPassword("please input your %s: ","password");
        if(name.equals("zhangwei") && new String(password).equals("123")){
            console.printf("login success! welcome %s",name);
        }

	Applet简单介绍：所有的Applet需要继承Applet类，需要重写paint方法，大部分Applet没有main方法。
	开发阶段使用appletViewer查看和测试applet。
	transient修饰符：用来修饰不需要被永久性存储的实例变量。
	volatile修饰符：多线程中告诉各个线程使用最新的变量主副本。
	instanceof运算符：检查对象和类型（接口）是否匹配。
	strictfp修饰符：修饰类、接口、方法，指明使用严格浮点运算（java2开始浮点运算变得更宽松），基本用不到。
	本地方法：目的是为了获得更高的效率，声明方式：
	public native return-type method-name();
	通常使用C语言实现本地方法，将C代码集成到java代码中的机制称为JDI（java本地接口）
	定义本地方法的类中使用System.loadLibrary(String fileName) 加载动态链接库
	使用javah -jni className 生成头文件，其中包含本地方法的函数原型。
	编写C源码实现本地方法后编译生成dll动态链接文件。
	然后就可以运行java类调用本地方法了。
	assert用于开发期间快速测试，语法：
		assert condition;或 assert condition: exp;
	condition返回false则断言失败，直接抛出AssertException异常。
	运行时使用-ea选项启用断言，也可以使用使用-da:package-name禁用指定包中的断言。
	静态导入：
		两种语法：import static java.lang.Math.pow; 或 import static java.lang.Math.*;
		导入指定类中的指定静态成员或所有静态成员。
	this调用重载的构造方法辨析：如果初始化代码很多，则使用this重载可以精简代码，但是使用this重载构造方法效率比使用
完整实现的构造方法低。
	java8将API库的子集组织成3个所谓“紧凑配置文件”：compact1、compact2、compact3，后一个完整包含前一个，使用：
	javac -profile compactn Demo.java
	可以只加载需要使用的库，加载会更快。


											第十一章 泛型

	JDK1.5引入了泛型，泛型从两个方面影响或者说改变了java，一是增加了新的语法元素，二是改变了核心API中很多类和方法。
	使用泛型的类、接口或者方法可以以类型安全的方式使用各种类型的数据，这样可以为算法相同而数据类型不同的程序只编写
一个通用的程序单元。集合框架是受泛型影响最大的API了，引入泛型使得集合框架的使用更加安全。
	泛型的意思：参数化类型，或者说成是类型参数化，使用占位符定义，而使用时被实际类型替换。引入泛型之前，是通过使用
Object引用所有类型对象，这样的方式并不安全，比如手动类型转换时进行了非法的转换，则会导致运行时错误，而泛型不需要进行
手动类型转换，可以在编译期就避开这种问题。
	泛型类： 
		class Gen<T>{
			T t;
			public Gen(T t){
				this.t = t;
			}
			T getT(){
				return t;
			}
		}
	两个泛型类型：
		class TwoGen<K,V>{
			K k;
			V v;
			TwoGen(K k, V v){
				this.k = k;
				this.v = v;
			}
		}
	声明泛型类的实例对象时，只能使用引用类型：Gen<int> gen = new Gen<int>(55); // Error
	有界的泛型：
		class Stats<T extends Number>{
			T[] nums;
			Stats(T[] nums){
				this.nums = nums;
			}
			double average(){
				double sum = 0.0;
				for(int i =0; i < nums.length; i++){
					sum += nums[i].doubleValue();
				}
				return sum / nums.length;
			}
		}
	这样nums[i].doubleValue()就可以编译通过，并且不能使用Stats<String>这种非Number的子类泛型参数。
	事实上，还可以声明泛型类型的父接口，或者同时声明父类和父接口：
	class Gen<T extends MyClass & MyInterface>{...}
	通配符问题：当泛型类的某个方法需要接受另一个泛型类对象作为参数，而该参数对象的泛型可能不是当前对象的泛型类型：
		Stats<T extends Number>方法public boolean sameAvg(Stats<T> stats){...}
		Stats<Integer> istats = new Stats<Integer>(inums);
		Stats<Double> dstats = new Stats<>(dnums);
		istats.sameAvg(dstats);//不能通过编译
	问题在于编译时将istats中的泛型类型都替换为Integer了，所以传入泛型为Double的对象不能通过编译。
	解决方案是使用通配符 ? ，
		public boolean sameAvg(Stats<?> stats){...}这样stats就可以是任意泛型类型的Stats对象了。当然这里的泛型类型仍然只能
是Number的子类。
	有界的通配符：泛型类指定的泛型类型只能是某个类的子类，但是有些方法需要的参数泛型类对象的泛型不能是任意的有效泛型
类型：
		class NegNumber extends Number{//负数类}
		class PosNumber extends Number{//正数类}
	Gen类定义方法 public double sum2(Stats<?> stats){//对stats中的数组的元素先开方再求和}
	这里如果使用NegNumber作为泛型类型的对象是可以传入sum2方法的，但是会出现错误。
	使用有界的通配符： public double sum2(Stats<? extends PosNumber> stats){//对stats中的数组的元素先开方再求和}
	也可以定义通配符下界： <? super subClass> //这里不包括subClass
	泛型方法：<type-param-list> ret-type method-name(param-list){...}
	这里泛型参数类型声明需要放在返回值类型前面。泛型方法可以是静态的，也可以是非静态的。
	泛型构造函数：可以在非泛型类中定义泛型构造方法：
		class Gen{
			double num;
			<T extends Number> Gen(T t){
				this.num = t.doubleValue();
			}
		}
	泛型接口：
		public interface MinMax<T> {
			T min();
			T max();
		}
	实现接口：
		class MyClass<T> implements MinMax{...}
	这里需要把接口中的泛型声明写到子类后面
	class MyClass implements MinMax<Integer>{...} 这种写法是允许的
	为了某些需要和原始代码兼容，可以按照原始代码方式使用泛型类：Gen gen = new Gen(...);
	子类继承带泛型的父类时，必须也声明泛型：
	class Gen2<T> extends Gen<T>{...}
	也可以添加自己的泛型类型：
	class Gen2<T,V> extends Gen<T>{...}
	extends Gen<T>可以简写成 extends Gen
	非泛型类可以作为泛型类的超类
	运行时不能使用泛型类型信息：
	gen instanceof Gen<Integer> //编译不能通过
	gen instanceof Gen<?>       //OK
	(Gen<Integer>)gen 			//强制类型转换是允许的，但是并不安全
	JDK1.7新增了泛型类型推断，即所谓“菱形运算符”：Gen<Integer> igen = new Gen<>(55);
	模糊性错误：
		public class MyGenClass<K,V extends Number> {
			K k;
			V v;
			void set(K k){
				this.k = k;
			}
			void set(V v){
				this.v = v;
			}
		}
	这里重载的set方法可以通过编译，但是如果使用MyGenClass<Number,Number>类型对象调用set方法就会导致错误。
	泛型类不能继承Throwable，不能创建包括特定泛型类型的数组：
		Gen<Integer> gens = new Gen<Integer>[10];  //wrong
	可以使用通配符：
		Gen<?> gens = new Gen<?>[10];  //OK
	
	补充：java的SPI
	SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。它是一种动态替换的机制。
	使用方法：在JAR包的"src/META-INF/services/"目录下建立一个文件，文件名是接口的全限定名，文件的内容可以有多行，每行都是该接口对应的具体实现类的全限定名。
		src
			main
				java
					com.zhangwei
						inteface.LogWriter
						impl.ErrorLogWriter
				resources
					META-INF
						services
							com.zhangwei.inteface.LogWriter(文件名就是接口的全限定名，没有扩展名)
	com.zhangwei.inteface.LogWriter文件内容：
		com.zhangwei.impl.ErrorLogWriter
	测试：
		ServiceLoader<LogWriter> logWriterList = ServiceLoader.load(LogWriter.class);
        for(LogWriter logWriter : logWriterList){
            logWriter.log("lllllll");
        }
    实际上，SPI也可以用在类上，即获取一个父类的子类实例对象。


											第十二章 lambda表达式

	lambda表达式提升了java的表达能力。
	lambda表达式包括三个部分，参数列表、->、lambda体 ：(n)->n%2==0
	lambda表达式本质上是一个匿名方法，这个方法并不能独立执行，而是作为一个函数式接口的抽象方法的实现。
	函数式接口是一个仅包含一个抽象方法的接口，用来指定接口的特定用途，比如Runnable接口。
	函数式接口的实例仍然可以调用定义在Object上的一些方法：如equals
		public interface MyFuncInterface {
			int sum(int a, int b);
		}
	lambda表达式的参数列表可以声明参数的类型，也可以不声明参数类型，参数类型通常可以从上下文中推断出来。
	lambda表达式体可以只有一条语句，也可以是一个代码块。一条语句不需要写return，表达式结果将直接返回。
		MyFuncInterface myFunc;
        myFunc = (a,b)->a+b;
        System.out.println("--- "+myFunc.sum(2,3));
	lambda表达式参数和返回值类型都必须匹配函数式接口中的方法（编译器检查）。
	如果参数只有一个，也可以不写括号： n -> n%2;
	函数式接口可以引用任何和它兼容的lambda表达式。
		myFunc = (a,b)->(a+b)*1;
	如果有多个参数，参数类型要么全不写，或者全写上。
		(int n, m)-> m+n;	//Error
	表达式体为代码块的lambda表达式如果需要返回值，必须使用return xxx;返回
		public interface MyFuncInterface {
			int func(int n);
		}
		MyFuncInterface myFunc;
		myFunc = (n) ->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
	泛型函数式接口：
		public interface MyGenFuncInterface<T> {
			T func(T t);
		}
	引用lambda表达式：
		MyGenFuncInterface<String> myGenFuncS;
        myGenFuncS = (s)->{
            StringBuilder buffer = new StringBuilder();
            for(int i=s.length()-1;i>=0;i--){
                buffer.append(s.charAt(i));
            }
            return buffer.toString();
        };
        MyGenFuncInterface<Integer> myGenFuncI;
        myGenFuncI = (n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
	将lambda表达式作为参数传递：
		static String dealStr(MyFuncInterface myFunc, int n){
			return n+" 的处理结果是："+myFunc.func(n);
		}
		String resultS = dealStr((n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        },10);
	这种写法通常用在lambda表达式不会复用的地方，如果觉得这种写法不便阅读，可以使用函数式接口引用：
		MyFuncInterface myFunc = (n)->{
            int result = 1;
            for(int i=1; i<=n; i++){
                result *= i;
            }
            return result;
        };
		String resultS = dealStr(myFunc,10);
	lambda表达式抛出必检异常，匹配的函数式接口也就必须使用throws声明抛出该类异常，否则不能使用该
lambda表达式作为该函数式的实例。
	外部变量捕获：lambda表达式内部可以使用外部局部变量，但是外部局部变量必须是实质上的final变量，即
设置值后不能再修改过，不论是在lambda表达式前还是后修改。lambda表达式内部也不能修改这些外部局部变量。
		int num;
		num = 100;
        //num = 90;	不允许再次修改值
        myFunc = (n)->{
            // num = 90; 不允许再次修改值
            return num+n;
        };
        System.out.println(myFunc.func(10));
        //num = 90; 不允许再次修改值
	lambda表达式内部可以显式或隐式引用调用实例的属性，而且可以在表达式内部修改实例的属性（非final属性）。
		private int num = 10;
		private static int nu = 100;
		public void test1(){
			MyFuncInterface myFunc;
			myFunc = (n)->{
				this.num = 90;
				this.nu = 10;
				return this.num+n;
			};
			System.out.println(myFunc.func(10));
		}
	引用方法作为函数式接口的实例：
	引用静态方法：		
		public interface StringFunc {
			String func(String str);
		}
		
		public class LambdaDemo2 {
			public static void main(String[] args) {
				String inStr = "lambda expression";
				strOps(MyStringOps::stringReverse,inStr);
			}

			static String strOps(StringFunc stringFunc,String str){
				return stringFunc.func(str);
			}
		}

		public class MyStringOps{
			public static String stringReverse(String str){
				StringBuilder buffer = new StringBuilder();
				for(int i=str.length()-1;i>=0;i--){
					buffer.append(str.charAt(i));
				}
				return buffer.toString();
			}
		}
	这里使用strOps(MyStringOps::stringReverse,inStr);将MyStringOps的静态方法：stringReverse作为
函数式接口StringFunc的实现，当然这需要静态方法和函数式接口的抽象方法相匹配。
	引用实例方法：
		MyStringOps:
		String stringToUpperCase(String str){
			return str.toUpperCase();
		}
		LambdaDemo2.main:
		MyStringOps stringOps = new MyStringOps();
        strOps(stringOps::stringToUpperCase,inStr);
	这里的实例方法和函数式接口的抽象方法是匹配的。
	另一种引用实例方法的模式：				
		public interface MyFunc<T> {
			boolean func(T t1,T t2);
		}
				
		public class LambdaDemo3 {
			static <T> int counter(T[] objs,MyFunc<T> myFunc,T obj){
				int count = 0;
				for(int i=0; i<objs.length;i++){
					if(myFunc.func(objs[i],obj)){
						count++;
					}
				}
				return count;
			}

			public static void main(String[] args) {
				HeighTemp[] heighTemps = {new HeighTemp(10),new HeighTemp(20),new HeighTemp(30),new HeighTemp(40),
					new HeighTemp(50),new HeighTemp(60)};
				int result = counter(heighTemps,HeighTemp::lessTemp,new HeighTemp(25));
				System.out.println("result: "+result);	// result: 2
			}
		}

		class HeighTemp{
			private int htemp;

			public int getHtemp(){return htemp;}
			public HeighTemp(int htemp){this.htemp = htemp;}

			public boolean lessTemp(HeighTemp heighTemp){
				if(this.htemp < heighTemp.htemp){
					return true;
				}
				else {
					return false;
				}
			}
		}
	这里是使用类名（HeighTemp::lessTemp）来引用实例方法，但是实例方法和函数式接口的方法是不一样的
	函数式接口的方法 boolean func(T t1,T t2);的第一个参数实际是调用方法的实例对象，这里是myFunc.func(objs[i],obj)
的objs[i]作为调用对象
	泛型函数式接口和泛型静态方法：	
		interface MyFunc2<T>{
			 int func(T t1,T t2);
		}
		class MyComparator{
			public static <T> int compare(T t1, T t2){
				if(t1 == t2) return 0;
				return -1;
			}
		}
		demo：
		static <T> int compareOp(MyFunc2<T> func2,T t1,T t2){
			return func2.func(t1,t2);
		}
		调用：
			compareOp(MyComparator::<Integer>compare,10,12);
		实际上这里的泛型类型可以从上下文推断出来，不需要写出来
	Collections.max(Collections<T> coll,Comparator<T> compartor)需要传入一个比较器实例对象，可以使用静态方法引用
代替比较器实例:
		class MyComparator{			
			static <T> int compare2(T t1, T t2){
				if(t1 == t2) return 0;
				else if(t1 < t2) return -1;
				return 1;
			}
		}
		
		Collections.max(list,MyComparator::compare2);
	函数引用(看起来没什么用)：
		public interface MyBeanFactory<R,T> {
			R newInstance(T t);
		}
		class MyClassA<T>{
			private T val;
			MyClassA(T val){this.val = val;}
			public void setVal(T val){this.val = val;}
			public T getVal(){return val;}
		}


		class MyClassB<T>{
			private T val;
			MyClassB(T val){this.val = val;}
			public void setVal(T val){this.val = val;}
			public T getVal(){return val;}
		}
		public class LambdaDemo4 {
			public static void main(String[] args) {
				MyBeanFactory<MyClassA<String>,String> beanFactory1 = MyClassA<String>::new;
				MyClassA<String> classA = beanFactory1.newInstance("12345");
				MyBeanFactory<MyClassB<Double>,Double> beanFactory2 = MyClassB<Double>::new;
				MyClassB<Double> classB = beanFactory2.newInstance(12.1);
			}
		}
	预定义函数式接口：新的包java.util.function中定义的函数式接口：
		interface Function<T, R>
			方法：R apply(T t);
		interface Consumer<T>
			方法：void accept(T t);
		interface UnaryOperator<T> extends Function<T, T>
			方法：T apply(T t);
		interface BiFunction<T, U, R>
			方法：R apply(T t, U u);
		interface BinaryOperator<T> extends BiFunction<T,T,T> 
			方法：T apply(T t, T u);
		interface Supplier<T> 
			方法：T get();
		interface Predicate<T>
			方法：boolean test(T t);

	补充：
		List<String> list = Arrays.asList("aaa","bbb");
		Iterator<String> iterator = list.iterator();
		while (iterator.hasNext()){
			String name = iterator.next();
			if(name.equals("aaa")){
				iterator.remove();
			}
		}
	执行报错：
		java.lang.UnsupportedOperationException: null		
		at java.util.AbstractList.remove(AbstractList.java:161)
	说明：在使用Arrays.asList()后调用add，remove这些method时出现java.lang.UnsupportedOperationException异常，
是由于Arrays.asList()返回java.util.Arrays$ArrayList，而不是ArrayList。
	Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等method在AbstractList中是默认throw 
UnsupportedOperationException而且不作任何操作。ArrayList override这些method来对list进行操作，但是Arrays$ArrayList
没有override remove()，add()等，所以throw UnsupportedOperationException。
	可以这样处理：
		List<String> list = new ArrayList<>(Arrays.asList("aaa","bbb"));


											第十三章 JavaBean

	Java Bean 是能够在各种不同的环境中重用的软件组件。
	内省：分析Bean的过程用以确定Bean的功能的技术。
	暴露Bean的属性、事件和方法的两种方式：一是使用约定的规则命名，二是提供一个实现了BeanInfo接口的附加类，由这个类
提供Bean的信息。
	属性命名规则：Bean的属性决定Bean的外观和行为，通过约定的getter和setter方法获取和设置属性的值，两种属性类型：
简单属性和索引属性，索引属性是指一个属性有多个值，比如属性是一个数组，可以使用带有索引参数的getter和setter方法
获取和设置指定索引的值。
	事件命名规则：Bean可以产生和监听事件，添加监听器方法：addTListener(TListener eventListener),T是事件的类型
	内省机制可以发现Bean的公开方法，受保护方法和私有方法不能被内省获得。
	BeanInfo接口定义了三个方法：
		PropertyDiscriptor[] getPropertyDiscriptors();
		EventSetDiscriptor[] getEventSetDiscriptors();
		MethodDiscriptor[] getMethodDiscriptor();
	返回的对象数组描述Bean的属性、事件和方法信息。
	BeanInfo实例命名：BeanNameBeanInfo，也可以选择继承SimpleBeanInfo这个类，重写其中的方法来暴露指定的信息，未被重写
的方法代表的信息将使用约定的命名规则来发现。
	Introspector类：这个类提供方法：
		static BeanInfo getBeanInfo(Class<?> bean) throw IntrospectionException;
这个方法可以使用内省机制返回bean的信息提供者BeanInfo实例（如果在bean的包下自己提供了BeanInfo实现，获取的BeanInfo实例
就是自己提供的那个类的实例）。


											第十四章 Servlet

	早期获取动态资源使用CGI程序（公共网关接口），HTTP请求先被CGI程序获取，CGI为每个请求创建一个进程，这个进程再和数据
库通信，这中方式的问题是性能不高，每个请求就产生一个进程，占用内存和CPU资源太多，而且每个进程都和数据库通信引起的频繁
的数据库连接和关闭连接也是很昂贵的代价。并且CGI可以使用各种语言开发，通常存在平台移植问题。
	servlet在web服务器的内存空间中运行，不创建单独的进程，同时servlet基于java，没有移植问题，而且java的安全管理机制很
完善，可以有效保护服务器上的资源。
	servlet的三个生命周期方法，在特定的时间由服务器调用它们：init()、service()、destroy()
	服务器接收到HTTP请求后根据请求中的资源路径映射到指定的servlet，如果servlet没有被加载，就找到这个servlet并加载到
服务器的内存空间中，然后调用servlet的init方法对servlet进行初始化处理（传递初始化参数配置servlet），然后调用servlet的
service方法处理HTTP请求。处理请求结束后servlet可以驻留在服务器的内存空间中，当服务器决定卸载servlet时才会调用servlet的
destroy方法回收资源。
	servlet-api.jar包含了开发servlet需要的api接口和类，它是由服务器开发者实现的，javaSE没有提供这些接口和类（servlet
接口都是在服务器提供的jar包中），javaEE提供了这些接口和类(应该是由javaEE定义的规范)。	
	编译servlet： javac MyServlet.java -classpath="...\tomcat...\lib\servlet-api.jar"
	编译得到的class文件应该放到tomcat的webapp目录下的工程的WEB-INF\classes\下。
	配置servlet：在工程的WEB-INF目录下的web.xml中配置：
		<servlet>
			<servlet-name>MyServlet</servlet-name>
			<servlet-class>aMyServlet</servlet-class>
		</servlet>
		<servlet-mapping>
			<servlet-name>MyServlet</servlet-name>
			<url-pattern>/servlet/myservlet</url-pattern>
		</servlet-mapping>
	启动tomcat后访问：http://localhost:8080/webappname/servlet/myservlet
	servlet相关类和接口主要位于两个包：javax.servlet和javax.servlet.http。
	javax.servlet包提供接口：
		Servlet：声明servlet的生命周期方法以及getServletConfig()
		ServletConfig：方法：getServletContext()、getInitParameter(String paramName)、Enumeration<String> getInitParameterNames()
		ServletContext: 方法：Object getAttribute(String name)[返回服务器空间中的属性]、getRealPath(String rPath)
		ServletRequest: 方法：Object getAttribute(String name)[返回请求中的属性]、getContentType()、getParameter(...)、
getInputStream()、getReader()、getRemoteHost()等
		ServletResponse: 方法：setContentType(...)、getOutputStream()
	javax.servlet包提供类：
		GenericServlet:实现了Servlet和ServletConfig接口
		ServletInputStream: 扩展了InputStream，由servlet容器实现，方法：int readLine(byte[] buffer, int offset, int size),
从输入流读取size个字节放入buffer从offset开始的位置
		ServletOuputStream: 扩展了OutputStream，由servlet容器实现，方法：print()、println()
		ServletException，继承ServletException 的UnAvailableException
	读取servlet请求参数：
		（ServletRequest request）
		Enumeration e = request.getParameterNames();
		while(e.hasMoreElements()){
			String pName = (String)e.nextElement();
			String param = request.getParameter(pname);
		}
	处理HTTP请求时通常使用http包下的类和接口：
	接口：
		HttpServletRequest:方法：getCookies()、getHeaders()、getMethod()、getSession()等
		HttpServletResponse：方法：addCookie(Cookie cookie)、sendError(...)、setDataHeader(...)、setStatus(int code)
		HttpSession:方法：Object getAttribute(...)、setAttribute(...)、removeAttribute(...)
	核心类：
		Cookie:包括这些信息：名称、值、截止日期、域和路径(需要携带cookie的请求域和路径)。方法：getName、getValue、
	getMaxAge、getDomain、getPath以及对应的set方法。cookie不设置到期时间，默认就是当前回话结束到期
		HttpServlet：方法：doDelete(...)、doGet(...)、doPost(...)、doPut(...)、doTrace(...)、service(...)等
		使用HttpServletRequest的getSession()获取session，如果不存在就创建session
		
	补充：java列表元素的多级比较排序：
		public class DemoEntity{
			public String attrA;
			public String attrB;
			public String attrC;
		}
		List<DemoEntity> list = ...;
		//排序
		Collections.sort(list, new Comparator<DemoEntity>(){
			@Override
            public int compare(DemoEntity o1, DemoEntity o2){
				if(o1.attrA != null && o2.attrA != null && !o1.attrA.equals(o2.attrA)){
					return o1.attrA.compareTo(o2.attrA);
				}
				else{
					if(o1.attrA == null && o2.attrA != null){
						return 1;
					}
					if(o1.attrA != null && o2.attrA == null){
						return -1;
					}
					else{
						if(o1.attrB != null && o2.attrB != null && !o1.attrB.equals(o2.attrB)){
							return o1.attrB.compareTo(o2.attrB);
						}
						else{
							if(o1.attrB == null && o2.attrB != null){
								return 1;
							}
							if(o1.attrB != null && o2.attrB == null){
								return -1;
							}
							else{
								if(o1.attrC != null && o2.attrC != null){
									if(o1.attrC.equals(o2.attrC)){
										return 0;
									}
									return o1.attrC.compareTo(o2.attrC);
								}
								if(o1.attrB == null && o2.attrB != null){
									return 1;
								}
								if(o1.attrB != null && o2.attrB == null){
									return -1;
								}
							}
						}
					}
					
				}
			}
		});
	Integer对象的比较：
		Integer a = 127, b = 127;
		System.out.println(a==b);	//true
		a = new Integer(127);
		b = new Integer(127);
		System.out.println(a==b);	//false
		a = 128;
		b = 128;
		System.out.println(a==b);	//false
		说明：Java在自动装箱创建Integer对象时，如果value小于128或大于-129，实际是引用了Integer的静态内部类IntegerCache的
静态缓存数组cache中的对象，所以a==b。可以使用System.identityHashCode(a)打印对象的内存地址，就可以看到a和b的地址完全相同。
使用new语法创建的对象则没有这个问题。String创建对象时也使用了相同的规则，只是String没有大小限制。Float和Double没有这个问题。
		比较Integer的值时应该使用equals方法


											第十五章 对象的序列化和反序列化

	对象序列化机制（object serialization）是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，
并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组（流）之间
进行转换。
	在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。
	java提供了java.io.Serializable 接口用来启用序列化功能，只有实现了这个接口的类的对象才能序列化，这个接口其实没有任何方法
需要实现类去实现，只是作为一个标记。
	对没有实现 Serializable 接口的类的对象序列化，将抛出NotSerializableException。
	如果要序列化的类有父类，并且需要将继承父类定义的变量持久化，那么父类也应该实现java.io.Serializable接口。
	通常使用ObjectOutputStream的writeObject方法把一个对象进行持久化。使用ObjectInputStream的readObject从持久化存储中把对象
读取出来。
	ObjectOutputStream继承自OutputStream，实现了ObjectOutput接口，这个接口扩展自DataOutput接口，新增了writeObject方法。
		import java.io.Serializable;
		public class User implements Serializable {
			private static User singletonInstance = new User();
			private String name;
			private int age;

			private User(){
			}

			public static User getInstance(){
				return singletonInstance;
			}

			private Object readResolve(){
				return singletonInstance;
			}

			//省略get/set方法
		}

		import java.io.*;
		public class SerializationDemo1 {
			public static void main(String[] args) {
				User user = User.getInstance();
				user.setAge(25);
				user.setName("zhangwei");
				System.out.println("--------");
				System.out.println(user.toString());

				try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempfile"))) {
					oos.writeObject(user);
				} catch (IOException e){
					e.printStackTrace();
				}
				readObjectFromFile("tempfile");
				readObjectFromFile("tempfile");
			}

			private static void readObjectFromFile(String fileName){
				File file = new File(fileName);
				try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {
					User user1 = (User) ois.readObject();
					//如果这里连续两次调用ois.readObject()，会抛出EOFException，表示第二次读取时已经到了文件末尾了。
					System.out.println("--------");
					System.out.println(user1);
				} catch (IOException | ClassNotFoundException e){
					e.printStackTrace();
				}
			}
		}
	ObjectInputStream继承自InputStream，实现了接口ObjectInput接口，该接口扩展自DataInput接口，新增了方法readObject。
	每次反序列化得到的都是一个新对象，如果需要在系统中保证多次反序列化得到的是一个单例对象，需要定义readResolve方法，这个方法在反序
列化返回前执行，在这里可以实现返回单例。
	Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 
变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
	java提供了一个继承了Serializable接口的Externalizable接口，这个接口定义了两个抽象方法：writeExternal()与readExternal()。
当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。
	在使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值
分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参的构造器。
	Externalizable的设计目的是让开发者可以对序列化的对象进行额外的操作，包括压缩、加密等。
	writeExternal(ObjectOutput out)的参数就是实际实例化的对象，这个方法就是用来将想要实例化对象的属性填充到这个参数对象中。
		public void writeExternal(ObjectOutput out) throws IOException {
			out.writeObject(name);
			out.writeInt(age);
		}
	在使用Externalizable进行反序列化的时候，使用readExternal(ObjectInput in)将实际反序列化得到的对象属性填充到返回的对象中。
		public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
			name = (String) in.readObject();
			age = in.readInt();
		}
	虚拟机在反序列化时会检查类路径和序列化ID( private static final long serialVersionUID)，只有两者都能匹配才完成反序列化(在进行
反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，
否则就会出现序列化版本不一致的异常，即是InvalidClassException)。

												第十六章 jdbc

	jdbc是java提供的数据库连接技术，其目的是提供统一的API访问不同的数据库，java以接口的形式定义了这些API，数据库厂商根据自己的
产品特性实现这些接口(jdbc驱动)。
	常用的jdbc接口：DriverManager、Connection、DatabaseMetaData、Statement、PreparedStatement、CallableStatement、
ResultSet、ResultSetMetaData.
	jdbc工作过程：
		1、加载驱动，建立连接；
		2、创建sql语句对象；
		3、执行sql语句；
		4、处理结果集；
		5、关闭连接。
	实例：
		import java.sql.*;
		public class JdbcDemo1 {
			public static void main(String[] args){
				String url="jdbc:mysql://127.0.0.1:3306/network_info";
				String user="root";
				String password="root";

				String sql = "select * from account";
				try {
					Class.forName("com.mysql.cj.jdbc.Driver");
					Connection conn = DriverManager.getConnection(url,user,password);
					Statement stmt = conn.createStatement();
					ResultSet resultSet = stmt.executeQuery(sql);
					while (resultSet.next()){
						Account account = new Account();
						account.setId(resultSet.getInt("id"));
						account.setName(resultSet.getString("name"));
						account.setNum(resultSet.getString("num"));
						account.setPwd(resultSet.getString("pwd"));
						System.out.println(account);
					}
					ResultSetMetaData rsmd = resultSet.getMetaData();
					for(int i=1; i<=rsmd.getColumnCount(); i++ ){
						System.out.println(rsmd.getColumnName(i));;
					}
					resultSet.close();
					stmt.close();
					conn.close();
				} catch (SQLException | ClassNotFoundException e) {
					e.printStackTrace();
				}
			}
		}
	可以将连接数据库的配置信息放到配置文件中，再提供一个通用的工具类获取连接：
		#database.propperties:
		#mysql
		driver=com.mysql.cj.jdbc.Driver
		url=jdbc:mysql://127.0.0.1:3306/network_info
		#oracle
		#driver=oracle.jdbc.driver.OracleDriver
		#url=jdbc:oracle:thin:@127.0.0.1:1521:mydb_info
		user=root
		password=root

		/** DBUtils.java */
		import java.io.IOException;
		import java.io.InputStream;
		import java.sql.Connection;
		import java.sql.DriverManager;
		import java.sql.SQLException;
		import java.util.Properties;

		public class DBUtils {
			private static String driver = null;
			private static String url = null;
			private static String user = null;
			private static String password = null;
			private static BasicDataSource dataSource = new BasicDataSource();
			
			static {
				InputStream inputStream = DBUtils.class.getClassLoader().getResourceAsStream("database.properties");
				Properties prop = new Properties();
				try {
					prop.load(inputStream);
					driver = prop.getProperty("driver");
					url = prop.getProperty("url");
					user = prop.getProperty("user");
					password = prop.getProperty("password");
					//使用DBCP连接池
					dataSource.setDriverClassName(driver);
					dataSource.setUrl(url);
					dataSource.setUsername(user);
					dataSource.setPassword(password);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			public static Connection getConnection() throws ClassNotFoundException, SQLException {
				//Class.forName("com.mysql.cj.jdbc.Driver");
				//Connection conn = DriverManager.getConnection(url,user,password);
				//return conn;
				return dataSource.getConnection();
			}
			public static void closeResource(Connection conn, Statement stmt, ResultSet rs){
				if(rs != null){
					try {
						rs.close();
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
				if(stmt != null){
					try {
						stmt.close();
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
				if(conn != null){
					try {
						conn.close();
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
			}
		}
	使用连接池时，可以设置一下参数：初始连接数、最大连接数、最小连接数、每次增加连接数、最大空闲连接数、最小空闲连接数、超时时间
	连接数据库或操作数据库时都可能发生SQLException，这类异常通常是由于sql错误、数据库表或数据错误等造成，这类异常属于必检异常。
	获取数据库连接也可以使用try(...)语法来自动关闭数据库连接：
		try(
			Connection conn = DBUtils.getConnection();
			Statement stmt = conn.createStatement();
			ResultSet resultSet = stmt.executeQuery(sql);
		) {
			while (resultSet.next()){
				...
			}
		} catch (ClassNotFoundException | SQLException e) {
			e.printStackTrace();
		}
	使用PreparedStatement：
	Statement及PreparedStatement执行时，一个sql语句执行过程分为以下几个步骤：
		1、传输SQL给数据库
		2、数据库验证并解析SQL
		3、计算Access Plan。数据库会通过检测index，statistics来给出最优的访问计划。
		4、根据访问计划进行检索，返回数据。
	第3步非常耗时，为了提高性能，数据库会缓存sql语句以及其Access Plan。这被称为statement cache。在statement cache中，
sql语句本身为key，access plan为value。当相同的sql语句被发送过来时，数据库会使用缓存中的access plan以节省cpu时间。
		Statement statement = connection.createStatement();
		String sql1="Select * from test where id=1";
		statement.execute(sql1);
		statement.execute(sql1);
		statement.execute(sql1);
	sql1在第一次执行时需要计算执行计划，第二次和第三次将使用缓存的第一次计算得到的执行计划。
		String sql2="Select * from test where id=";
		statement.execute(sql2+"2");
		statement.execute(sql2+"3");
	sql2每次都不同，所以不能使用缓存执行计划，使用PreparedStatement可以解决这个问题：
		String sql2="Select * from test where id=?";
		PreparedStatement pstmt = connection.prepareStatement(sql2);
		pstmt.setInt(1,2);
		pstmt.executQuery();
		pstmt.setInt(1,3);
		pstmt.executQuery();
	PreparedStatement在创建后就会将参数化的语句发送给数据库，进行语法检测和执行计划计算。Cache中的key将是参数化的语句。当后面
preparedstatement在执行的时候，每次均会命中cache，使用已存在的access plan进行检索。
	PreparedStatement和Statement的生命周期都是在一个数据库连接connection范围内，所以说如果一次连接中对于同一个PreparedStatement
处理多次（参数不同），那么用PreparedStatement是可以提高效率。
	很多J2EE服务器的连接池管理器实现了PreparedStatement的缓存，连接池中每一个连接准备过的PreparedStatement将被缓存。当在一个连接
上调用preparedStatement时，应用服务器会检查这个statement是否曾经准备过。如果是，这个PreparedStatement会被返回给应用程序。如果否，
调用会被转给JDBC驱动程序，然后将新生成的statement对象存入连接缓存。这样就实现了在不同的connection中使用一个PreparedStatement。
	PreparedStatement创建后参数化的sql语句被发送给数据库服务器，数据库系统会预编译这条sql，后面发送的匹配这条参数化sql的语句就不
需要再编译了，只需要把对应位置的参数填充到已编译的sql中去，这也是PreparedStatement可以避免SQL注入的原因(条件不会被编译成sql语句)。
	获取可前后滚动的结果集需要使用下面的语法创建statement：
		Statement stmt = conn.createStatement(type,concurrency);
	type取值：TYPE_FORWARD_ONLY (只能向前移动，默认就是这个值)
			  TYPE_SCROLL_INSENSITIVE 可滚动，不感知结果集中数据变化
			  TYPE_SCROLL_SENSITIVE 可滚动，感知结果集中数据变化
	concurrency取值： CONCUR_READ_ONLY 只读
					  CONCUR_UPDATABLE 可修改
	数据库事务的特性：
		原子性：事务中的修改数据的一组sql语句必须全部成功或者全部失败。
		一致性：事务提交或回滚后数据保持一致状态，比如转账操作需要保持两个账户的总金额保持不变。
		隔离性：并发操作时隔离并发事务的修改（隔离同时修改同一条数据）
		持久性：事务提交后数据被写入数据库中
	事务的实现是数据库系统提供的。JDBC默认自动提交事务。
	jdbc手动提交事务：
		try {
			Connection conn = DBUtils.getConnection();
			boolean autoCommit = conn.getAutoCommit();
			conn.setAutoCommit(false);
			PreparedStatement ps = conn.prepareStatement("update emp set deptno=30 where empno=?");
			ps.setInt(1,7902);
			ps.executeUpdate();
			ps.setInt(1,7903);
			ps.executeUpdate();
			conn.commit();
			conn.setAutoCommit(autoCommit); 
		} catch (ClassNotFoundException | SQLException e){
			e.printStackTrace();
		}
	批量更新：
		PreparedStatement ps = conn.prepareStatement("update emp set deptno=40 where empno=?");
		for(int i=0;i<3;i++){
			ps.setInt(1,7902+i);
			ps.addBatch();
		}
		ps.executeBatch();
	批量操作时如果一次保存的sql语句过多，可能会导致OOM，所以最好是限定多少条sql就executeBatch，然后clearBatch后再继续addBatch
	
	补充：ThreadLocal
		public class ConnectionFactory{
			private final ThreadLocal<Connection> connections = new ThreadLocal<>();
			public getConnection(){
				Connection conn = connections.get();
				if(conn==null){
					conn = DBUtils.getConnection;
					connections.set(conn);
				}
				return conn;
			}
		}
	假设系统中只有一个单例的ConnectionFactory实例对象，那么所有线程通过getConnection方法将拿到绑定自己线程的数据库连接。
	ThreadLocal原理分析：
	每个线程都有一个ThreadLocalMap实例对象，可以通过 thread.threadLocals获取，这个对象类似于Map，其key为各个ThreadLocal对象的
弱引用，value为各ThreadLocal对应得值。
						 ______________________________
		 			    |_threadLocal1___|___val1______|
			thread1---->|_threadLocal2___|___val2______|
						|_threadLocal3___|___val3______|
							threadLocals
	ThreadLocal的set方法：
		public void set(T value) {
			Thread t = Thread.currentThread();
			ThreadLocalMap map = getMap(t);
			if (map != null)
				map.set(this, value);
			else
				createMap(t, value);
		}
	get方法：
		public T get() {
			Thread t = Thread.currentThread();
			ThreadLocalMap map = getMap(t);
			if (map != null) {
				ThreadLocalMap.Entry e = map.getEntry(this);
				if (e != null) {
					@SuppressWarnings("unchecked")
					T result = (T)e.value;
					return result;
				}
			}
			return setInitialValue();
		}
	其实可以看出，线程绑定数据其实是保存在线程持有的ThreadLocalMap对象中，只不过不能直接访问线程的这个对象，而是需要借助ThreadLocal来
访问线程绑定数据。
	为什么线程的threadlocals中key保存的是threadlocal的弱引用？
	弱引用的特点是，不会干扰GC，也就是说如果某个threadlocal对象没有强引用（持有threadlocal的对象已经回收），这里尽管线程的threadlocals
持有该threadlocal的弱引用，这个threadlocals还是会被GC。
	引用的4个分级：
		强引用：普通引用；
		软引用：只有软引用的对象在内存不足时将被JVM回收；
		弱引用：每次GC触发时JVM都会回收只有弱引用的对象；
		幻影引用：幻影引用和没有引用一样，任何时候都可能被回收
	
	补充：打印classpath：
		public class TestDemo1 {
			public static void main(String[] args) {
				System.out.println(Thread.currentThread().getClass().getResource("/").getPath());
				System.out.println();
				String classpath = System.getProperty("java.class.path");
				String [] arr = classpath.split(";");
				for(String path : arr){
					System.out.println(path);
				}
			}
		}

	补充：将科学计数法表示的数字转为普通格式数字：
		BigDecimal d = new BigDecimal(12E7);
		System.out.println(d.toPlainString());						// 120000000（字符串）
		System.out.println(Integer.parseInt(d.toPlainString()));	// 120000000
		System.out.println(d.intValue());							// 120000000
		System.out.println(d.doubleValue());						// 1.2E8

		BigDecimal d = new BigDecimal(12E-5);
		System.out.println(d.toPlainString());						//0.000120000000000000003040102891649354432956897653639316558837890625
		System.out.println(d.doubleValue());						//1.2E-4
        System.out.println(0.00012145);								//1.2145E-4
	对于小数，看起来只能转成字符串形式


												第十七章 NIO

	在JDK1.4的时候，java开始支持一套新的IO系统，被称为NIO，NIO是一套基于缓冲区和通道的系统，在JDK1.7发布时，又对NIO进行了扩展和增强。
NIO的设计目的并不是替代早期的基于流模型的IO系统。
	NIO的相关类和接口都定义在nio包及其子包下。
	缓冲区在nio包下定义，缓冲区的基本属性和功能都在基类Buffer中定义，其他的缓冲区都继承自这个类。Buffer定义的三个缓冲区的核心概念是：
当前位置、界限和容量。当前位置是下一次读取或写入的位置，界限是最后一个有效位置的下一个索引，容量是缓冲区可以保存的数据的字节数，界限
的值应该总是小于等于容量。Buffer提供标记和重置功能。
	Buffer提供的缓冲区通用方法：
		abstract Object array();	//如果缓冲区使用数组作为存储实现，将返回所使用数组的引用，否则抛出异常，数组只读也会抛出异常
		abstract int arrayOffset();	//返回基于数组的缓冲区的第一个元素在数组中的索引。抛出异常和array方法相同。
		final int capacity();		//返回缓冲区容量
		final Buffer clear();		//清空缓冲区中数据
		final Buffer flip();		//先将缓冲区的界限设置到当前位置，再修改当前位置为0
		abstract boolean hasArray();	//返回缓冲区是否使用数组保存数据
		final boolean hasRemaining();	//返回缓冲区是否还有剩余数据
		abstract boolean isDirect();	//返回缓冲区是否可以直接进行IO操作
		abstract boolean isReadOnly();	//返回缓冲区是否只读
		final int limit();				//返回界限
		final Buffer limit(int n);		//设置界限
		final Buffer mark();			//打标记
		final int position();			//返回当前位置
		final Buffer position(int n);	//设置当前位置
		int remaining();				//返回剩余数据量，即界限-当前位置
		final Buffer reset();			//设置当前位置为标记位置
		final Buffer rewind();			//设置当前位置为0
	扩展自Buffer的其他Buffer：
		ByteBuffer、MappedByteBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、CharBuffer
	这些扩展的缓冲区类都提供多个重载的get和put方法，用于从缓冲区中读取数据或向缓冲区写入数据，比如ByteBuffer提供以下方法：
		abstract byte get();
		ByteBuffer get(byte[] bytes);
		abstract ByteBuffer put(byte b);
		ByteBuffer put(byte[] bytes);
		...
	通道在nio包下的channels子包中定义：表示到IO源或目标的连接。通道的基本功能定义在Channel接口中，这个接口扩展了Closeable接口和
AutoCloseable接口。
	获取通道的一种方式是从支持通道的对象中获取：通过getChannel方法：FileInputStream、FileOutputStream、RandomAccessFile、Socket、
ServerSocket、DatagramSocket都支持通道。
	上面这些类的getChannel方法返回的通道类型不全一样，文件IO流及RandomAccessFile返回FileChannel，Socket相关类返回SocketChannel
	获取通道的另一种方式是使用Files类的静态方法，如newByteChannel方法可以返回SeekableByteChannel接口的实例（FileChannel就是这个
接口的一类实现）。
	FileChannel和SocketChannel都提供一些重载的read和write方法，用于将数据读取到缓冲区中或从缓冲区中写数据到通道中。
	FileChannel定义的方法：
		abstract int read(ByteBuffer b);
		abstract int write(ByteBuffer b);
		...
	FileChannel提供一个静态方法open，可以打开文件并返回连接该文件的通道，还提供一个map方法，可以把文件数据映射到缓冲区。
	JDK1.7新增了一个Path接口，用来抽象文件路径，这个接口继承了Watchable、Iterable和Comparable接口。
	Path接口中定义的方法：
		boolean endsWith(Path/String path);
		Path getFileName();
		Path getName(int idx);	//返回Path对象路径下索引为idx的元素
		int getNameCount();
		Path getParent();
		Path getRoot();
		boolean isAbsolute();
		Path resolve(Path/String path);	//如果参数为绝对路径就返回参数对应的Path对象，如果是相对路径就将Path对象的路径加到参数路径前
		boolean startsWith(Path/String path);
		Path toAbsolutePath();
		static Path get(String path,String ... parts);
		static Path get(URI path);
		File toFile();	//返回对应的File对象
	File对象也支持一个toPath()方法，可以得到对应的Path对象。
	Files类提供一些静态方法，以Path对象为参数，可以进行文件操作，比如打开、创建文件、读取文件属性、复制、移动文件等：
		static Path copy(Path src,Path des,CopyOption ...how);
		static Path move(Path src,Path des,CopyOption ...how);
		static Path createDirectory(Path path,FileAttribute<?> ...attrs);
		static Path createFile(Path path,FileAttribute<?> ...attrs);
		static void delete(Path path);
		static boolean isHidden(Path path);
		static SeekableByteChannel newByteChannel(Path path, OpenOption ...how);
		static InputStream newInputStream(Path path, OpenOption ...how);
		static OutputStream newOutStream(Path path, OpenOption ...how);
		static <A extends BasicFileAttributes> A readAttributes(Path path,Class<A> clazz, LinkOption ...opts);
	StandardOpenOption是OpenOption的一个实现，这个类定义了一些枚举量：
		APPEND、CREATE、CREATE_NEW、READ...
	文件属性抽象是通过nio包下的子包file.attribute包下的类实现的，基本功能定义在BasicFileAttributes接口中：
		FileTime creationTime();
		boolean isDirectory();
		FileTime lastModifiedTime();
		...
	两个派生自BasicFileAttributes的接口：DosFileAttributes(用于FAT文件系统)和PosixFileAttributes(posix标准文件系统)。
	
	使用Cnannel和Buffer读取文件：
		private static void readFile1(){
			int count;
			Path filepath;
			filepath = Paths.get("/tem_file/file1.txt");
			try (SeekableByteChannel channel = Files.newByteChannel(filepath)) {
				ByteBuffer buffer = ByteBuffer.allocate(1024);
				count = channel.read(buffer);
				for(;count != -1;){
					buffer.rewind();	//这里需要将缓冲区的当前位置重置到头部
					for(int i=0;i<count;i++){
						System.out.println((char)buffer.get());
					}
					count = channel.read(buffer);
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	使用FileChannel的map方法直接将数据源映射到缓冲区，这样就不需要手工从通道读取数据到缓冲区：
		private static void readFile2(){
			Path filepath;
			filepath = Paths.get("/tem_file/file1.txt");
			try (FileChannel channel = (FileChannel) Files.newByteChannel(filepath);){
				MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY,0,channel.size());
				for(int i=0;i<buffer.limit();i++){
					System.out.println((char)buffer.get());
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	手动从缓冲区写文件到通道：
		private static void writeFile1(){
			try (FileChannel channel = (FileChannel)Files.newByteChannel(Paths.get("/tem_file/file1.txt"),
					StandardOpenOption.WRITE,StandardOpenOption.CREATE);){
				ByteBuffer buffer = ByteBuffer.allocate(26);
				for(int i=0;i<26;i++){
					buffer.put((byte) ('A'+i));
				}
				buffer.rewind();
				channel.write(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
    	}
	映射文件到缓冲区后，只需要将数据写到缓冲区就可以实现写入数据到文件：
		private static void writeFile2(){
			try (FileChannel channel = (FileChannel)Files.newByteChannel(Paths.get("/tem_file/file1.txt"),
					StandardOpenOption.WRITE,StandardOpenOption.CREATE,StandardOpenOption.READ,
					StandardOpenOption.TRUNCATE_EXISTING)){
				ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE,0,26);
				for(int i=0;i<26;i++){
					buffer.put((byte) ('a'+i));
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
    	}
	打开通道时，设置了打开模式为：StandardOpenOption.TRUNCATE_EXISTING，这样如果原文件存在就会先清空原文件，
设置StandardOpenOption.READ是因为映射缓冲区需要通道是可读的，或可读可写的。
	复制文件：
		private static void copyFile(){
			Path src = Paths.get("/tem_file/file1.txt");
			Path des1 = Paths.get("/tem_file/file2.txt");
			Path des2 = Paths.get("/tem_file/file3.txt");
			try {
				Files.copy(src,des1, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);
				Files.copy(src,des2,StandardCopyOption.COPY_ATTRIBUTES);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	获取文件和路径的属性，可以使用三种方式：
		Path接口中定义的方法：
		Path file = Paths.get("/tem_file/file1.txt");
        Path path = Paths.get("/tem_file/");
        System.out.println(file.getFileName());
        System.out.println(file.getParent());
        System.out.println(file.isAbsolute());
        System.out.println(file.toAbsolutePath());
        System.out.println(file.getRoot());
        System.out.println(file.getFileSystem());
        System.out.println(path.getNameCount());
        System.out.println(path.getName(0));
		Files类定义的静态方法：
		System.out.println(Files.isDirectory(path));
        System.out.println(Files.isHidden(file));
        System.out.println(Files.isReadable(file));
        System.out.println(Files.isRegularFile(file));
        System.out.println(Files.isWritable(file));
        System.out.println(Files.isExecutable(file));
		Files.readAttributes获取的BasicFileAttributes对象的方法：
		BasicFileAttributes attributes = Files.readAttributes(file,BasicFileAttributes.class);
        System.out.println(attributes.isDirectory());
        System.out.println(attributes.lastModifiedTime());
        System.out.println(attributes.creationTime());
        System.out.println(attributes.fileKey());
	使用DirectoryStream遍历目录下的元素：
		private static void listDir(){
			Path dir = Paths.get("/tem_file/");
			try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(dir)) {
				for(Path item : directoryStream){
					System.out.println(Files.isDirectory(item)?"DIR> "+item.getFileName():item.getFileName());
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	Files.newDirectoryStream有3个重载版本，包括一个带文件名过滤规则的字符串参数版本：["*.{txt,jpg}"]，另一个重载版本参数是
一个DirectoryStream.Filter的实例对象。
	使用Files.walkFileTree递归遍历目录：
		class MyFileVisitor extends SimpleFileVisitor<Path>{
			private Path root;
			
			public MyFileVisitor(Path root){
				this.root = root;
			}

			@Override
			public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
					throws IOException
			{
				System.out.println(dir.getParent()==root);
				//过滤根目录和非一级子目录
				if(attrs.isDirectory() && dir!=root && !dir.getParent().getFileName().equals(root.getFileName())){
					System.out.println("skip directory: "+dir.getFileName());
					return FileVisitResult.SKIP_SUBTREE;
				}
				return FileVisitResult.CONTINUE;
			}

			@Override
			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
					throws IOException
			{
				System.out.println("file name: "+file.getFileName());
				return FileVisitResult.CONTINUE;
			}
		}

		 private static void walkFileTree(){
			Path root = Paths.get("/tem_file");
			try {
				Files.walkFileTree(root,new MyFileVisitor(root));
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	JDK1.7之前，不能使用Path接口来获取通道，那时建立到文件的通道是使用文件输入输出流的方法来打开通道的：
		FileInputStream fin = new FileInputStream("/tem_file/file1.txt");
		FileChannel channel = fin.getChannel();
		FileOutputStream fout = new FileOutputStream("/tem_file/file2.txt");
		FileChannel channel2 = fout.getChannel();
	JDK1.7之前还需要手动关闭流（不能使用try(...)语法）。


												第十八章 网络

	IP协议定义了IP数据包的格式和如何将IP数据包传输给指定主机的机制（由网络中的路由器提供支持），IP协议本身并不能提供可靠性保证，所以
传输的IP数据包可以丢失。根据分层设计的思想，数据传输的可靠性保证将由IP协议层的上层协议来提供，TCP协议就是设计用来提供这种保证的，TCP
协议使用了面向连接、排序传输、检测重传等机制来实现数据的可靠传输。TCP协议保证了可靠传输，但是也不可避免地引入了传输效率降低的问题。
另一种协议UDP协议被设计出来提供无连接的、不可靠的，但是快速的数据传输。
	TCP、UDP协议提供的都是端到端的数据通信，即主机到主机，主机应用间的通信则需要使用更高层的协议（应用层协议），这些协议使用指定的端口
来确定远程主机上的特定应用，从而实现应用间的通信。
	Socket（套接字）是TCP、UDP协议层和应用层协议层之间的抽象层，可以看成一种特殊的文件，操作系统提供操作Socket文件的接口给应用，应用可
以从Socket文件读取数据，也可以写数据到Socket文件中；同时操作系统实现网络和Socket文件的交互，即从网络中填充数据到Socket文件中或从Socket
文件中发送数据到网络。
	java提供自己的套接字抽象，Java的套接字对操作系统的套接字进行了封装，提供了跨平台的一致的socket模型，这也是Java被广泛应用于网络编程的
原因。Java的网络连接相关类位于java.net包下。
	InetAddress对象是网络中的某台主机的抽象，包括主机的IP和域名。通常使用InetAddress提供的静态工厂方法来获取InetAddress实例对象：
		private static void testInetAddress(){
			try {
				InetAddress localAddress = InetAddress.getLocalHost();
				System.out.println(localAddress);
				InetAddress address1 = InetAddress.getByName("www.baidu.com");
				System.out.println(address1);
				InetAddress[] addresses = InetAddress.getAllByName("www.baidu.com");
				int i = 0;
				for(InetAddress address : addresses){
					if(address.equals(address1)){
						continue;
					}
					System.out.println("address"+ i++ + ": " +address);
				}

				byte[] address1s = address1.getAddress();
				StringBuilder adBuilder = new StringBuilder();
				for(byte ab : address1s){
					int a = ab;
					if(a<0){
						a = 255+a;
					}
					adBuilder.append(a).append(".");
				}
				System.out.println(adBuilder.substring(0,adBuilder.length()-1));
				System.out.println(address1.getHostName());
				System.out.println(address1.getHostAddress());
				System.out.println(address1.isMulticastAddress());
				System.out.println(address1.getCanonicalHostName());
			} catch (UnknownHostException e) {
				e.printStackTrace();
			}
		}
	InetAddress有两个子类，Inet4Address表示IPv4地址，Inet6Address表示IPv6地址，大多数情况下直接使用InetAddress就足够了。
	java的TCP/IP套接字可以在Internet主机之间实现可靠的、双向的、持续的、点对点的、基于流的连接，通过套接字打开IO流实现跨网络
的程序之间通信。
	java提供一个ServerSocket类作为监听者，用于服务器，等待客户端发起连接。还提供一个Socket类作为客户端，用于发起到服务器的连接。
	ServerSocket对象创建时需要设置监听的本地端口号，还可以选择设置等待连接的队列的长度（默认为50）。
		public ServerSocket(int port);
		public ServerSocket(int port, int maxQueue);
		public ServerSocket(int port, int maxQueue, InetAddress localAddress);	//多个网卡的主机绑定给定的IP
	Socket对象提供两个构造函数，在创建了Socket对象后就默认发起连接，不需要手动进行连接：
		public Socket(String hostName, int port);
		public Socket(Inetaddress address, int port);
	Socket对象提供以下实例方法用于获取连接的信息：
		InetAddress getInetAddress();	//返回服务器的地址，如果没有连接，将返回null
		int getPort();			//返回连接的服务器的端口，如果没有连接返回0
		int getLocalPort();		//返回本地端口，没有连接将返回-1
		InputStream getInputStream();
		OutputStream getOutputStream();
		SocketChannel getChannel();
		connect(SocketAddress address);		//建立新的连接
	RFC 3912定义了一个非常简单的Internet信息查询协议——WHOIS协议。其基本内容是，先向服务器的TCP端口43建立一个连接，发送查询关键字
并加上回车换行，然后接收服务器的查询结果。
	whois.internic.net的43端口提供上面的WHOIS协议支持。
		private static void testSocketConnect(){
			int c;
			try(Socket socket = new Socket("whois.internic.net",43);) {
				System.out.println("local port: "+socket.getLocalPort());
				InputStream in = socket.getInputStream();
				OutputStream out = socket.getOutputStream();
				String baidu = "baidu.com\n";
				out.write(baidu.getBytes());
				while ((c=in.read()) != -1){
					System.out.print((char)c);
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	使用客户端Socket和服务器端ServerSocket通信：
		public class ServerSocketDemo {
			public static void main(String[] args) {
				dealRequest();
			}
			private static void dealRequest(){
				try {
					ServerSocket serverSocket = new ServerSocket(9999);
					int count = 0;
					while (count++<5){
						System.out.println("no request,waiting...");
						Socket socket = serverSocket.accept();
						InputStream in = socket.getInputStream();
						OutputStream out = socket.getOutputStream();
						while (true){
							int len;
							byte[] buffer = new byte[1024];
							StringBuffer str = new StringBuffer();
							len=in.read(buffer);
							str.append(new String(buffer,0,len, StandardCharsets.UTF_8.toString()));
							if(str.toString().equals("-1\n")){
								break;
							}
							System.out.println("get request message from "+socket.getInetAddress()+" : "+str.toString());
							System.out.println("please input message to response:");
							len = System.in.read(buffer);
							out.write(new String(buffer,0,len, StandardCharsets.UTF_8.toString()).getBytes(StandardCharsets.UTF_8.toString()));
						}
						in.close();
						out.close();
						socket.close();
					}
					serverSocket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	
		public class ClientSocketDemo {
			public static void main(String[] args) {
				contactServer();
			}
			private static void contactServer(){
				try {
					Socket socket = new Socket("127.0.0.1",9999);
					OutputStream out = socket.getOutputStream();
					InputStream in = socket.getInputStream();

					byte [] buffer = new byte[1024];
					int len;
					StringBuffer str;
					System.out.println("please input message to send: ");
					while ((len = System.in.read(buffer)) != -1){
						str = new StringBuffer();
						str.append(new String(buffer,0,len, StandardCharsets.UTF_8.toString()));
						out.write(str.toString().getBytes(StandardCharsets.UTF_8.toString()));
						if(str.toString().equals("-1\n")){
							break;
						}
						len = in.read(buffer);
						str = new StringBuffer();
						str.append(new String(buffer,0,len, StandardCharsets.UTF_8.toString()));
						System.out.println("message from server: "+str.toString());
						System.out.println("please input message to send: ");
					}
					out.close();
					in.close();
					socket.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	URL(统一资源定位符)用于可靠地标识/定位Internet上的资源/信息。基本结构分为4个部分：
		http://www.cnblogs.com:80/rexcheny/p/10925464.html
		协议	主机(域名或IP)	端口	资源路径
	80端口是http协议的默认端口,如果服务器监听端口是80，在浏览器中可以不写这个部分。实际上访问站点主页可以直接使用cnblogs.com
这种域名就可以实现。
	java的URL类构造函数：
		public URL(String url);
		public URL(String protocal,String hostName,int port,String path);
		public URL(String protocal,String hostName,String path);	//这里没有端口号，那么默认为-1
		public URL(Ulr url,String str);
	URL对象提供一个openConnection方法，可以返回一个URLConnection对象。
	URLConnection用于访问远程资源属性，也就是说建立连接后实际传输远程资源对象前，可以使用这个对象获取远程资源对象的属性。（这些
属性只有HTTP协议支持）。
		private static void testURLConnection(){
			try {
				URL url = new URL("http://www.internic.net");
				URLConnection urlConnection = url.openConnection();
				System.out.println(new Date(urlConnection.getDate()));
				System.out.println(urlConnection.getContentType());
				System.out.println(urlConnection.getLastModified());
				long len = urlConnection.getContentLengthLong();
				int c;
				if(len>0){
					InputStream in = urlConnection.getInputStream();	//获得资源的输入流
					while ((c=in.read()) != -1){
						System.out.print((char)c);
					}
					in.close();
				}
			} catch (IOException e){
				e.printStackTrace();
			}
		}
	HttpURLConnection是URLConnection的子类，如果是使用http协议的URL，可以将openConnection()打开的URLConnection强转为
HttpURLConnection对象。它提供一些获取http协议相关的信息：getRequestMethod()、setRequestMethod()、getResponseCode()、
getResponseMessage()、getHeaderFields()等。
	URI(统一资源标识符)是URL的超集，代表资源定位的标准方式，URL除了描述资源定位，还描述了访问方式。
	net还提供Cookie类及相关的接口、类，用来创建有状态的会话。
	java提供DatagramPacket类代表UDP数据包，DatagramSocket代表发射器，使用UDP协议实现无连接的数据传输：
	创建DatagramSocket对象时可以指定本地端口，也可以不指定本地端口（使用随机的可用端口），还可以直接绑定一个本地IP和
端口（SocketAddress）。
	使用DatagramSocket和DatagramPacket实现通信：
		public class DatagramSocketDemo1 {
			public static void main(String[] args) {
				contact();
			}
			private static void contact(){
				try (DatagramSocket socket = new DatagramSocket(9998)){
					System.out.println(socket.getLocalAddress());
					System.out.println(socket.getLocalPort());
					System.out.println(socket.getInetAddress());
					System.out.println(socket.getPort());
					while (true){
						byte[] buffer = new byte[1024];
						int len = System.in.read(buffer);
						DatagramPacket packet = new DatagramPacket(buffer,len, InetAddress.getLocalHost(),9997);
						socket.send(packet);
						if(new String(buffer,0,len, StandardCharsets.UTF_8.toString()).equals("-1\n")){
							break;
						}
						buffer = new byte[1024];
						DatagramPacket receivePack = new DatagramPacket(buffer,buffer.length);
						socket.receive(receivePack);
						String message = new String(receivePack.getData(),0,receivePack.getLength(), StandardCharsets.UTF_8.toString());
						if(message.equals("-1\n")){
							break;
						}
						System.out.println(message);
					}

				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		public class DatagramSocketDemo2 {
			public static void main(String[] args) {
				contact();
			}
			private static void contact() {
				byte[] buffer = new byte[1024];
				DatagramPacket packet = new DatagramPacket(buffer,buffer.length);
				try (DatagramSocket socket = new DatagramSocket(9997);){
					while (true){
						socket.receive(packet);
						String message = new String(packet.getData(),0,packet.getLength(), StandardCharsets.UTF_8.toString());
						if(message.equals("-1\n")){
							break;
						}
						System.out.println(message);
						buffer = new byte[1024];
						int len = System.in.read(buffer);
						DatagramPacket sendPack = new DatagramPacket(buffer,len, packet.getAddress(),packet.getPort());
						socket.send(sendPack);
						if(new String(buffer,0,len, StandardCharsets.UTF_8.toString()).equals("-1\n")){
							break;
						}
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
    网络IO的一些概念：
        同步：用户线程启动某个任务后需要等待该任务完成后才能继续执行后续操作。
        异步：用户线程启动某个任务后就继续执行后续操作，当启动的任务执行结束后会通知用户线程，或者调用用户线程注册的回调函数。
        同步与异步是针对线程的任务而言的，一般表述为某个任务对其后续任务来说，是同步的还是异步的。
        阻塞网络IO：网络请求发出后，如果该请求返回需要的条件不满足，请求操作就一直阻塞，直到条件满足。
        非阻塞网络IO：网络请求发出后，直接返回，然后用户线程可以通过循环检查请求结果。
    Unix下共有五种IO模型：阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO。
    java支持Unix中IO模型中除信号驱动IO外的其他四种。
    


	补充：java8新增的Optional<T>类：
	这个类是一个包装类，用来包装一个对象，包装的对象可以是null，包装后的Optional对象提供一些操作/访问包装对象的方法，正确使用这些方法可以优雅地
避开NullPointerException。
		String msg = "hello";
		//Optional<String> msgOp = Optional.empty();
		//Optional<String> msgOp = Optional.of(null);
		Optional<String> msgOp = Optional.ofNullable(msg);
		msgOp.ifPresent(System.out::println);
		Optional<Integer> msgLenOp = msgOp.map(String::length);
		msgLenOp.ifPresent(System.out::println);
		String val = msgOp.orElse("world");
		System.out.println(val);
		val = msgOp.orElseGet(()->"world");
		System.out.println(val);
		val = msgOp.orElseThrow(()->new RuntimeException("content is null"));
		msgOp = msgOp.filter(msg1->msg1.equals("hello"));
		msgOp.ifPresent(System.out::println);

		User user = new User(22,"zhangsan");
		Optional<User> userOp = Optional.ofNullable(user);
		String userName = userOp.map(User::getName).map(String::toUpperCase).orElse(null);
		System.out.println(userName);
	静态方法：
		empty()方法使用null作为包装对象创建Optional对象；
		of(obj)接受一个对象作为参数创建Optional对象，参数对象不能为null，否则创建对象时就会直接抛出异常；
		ofNullable(msg)方法和of(msg)方法作用相同，但是允许参数为null，通常应该使用这个方法来创建Optional对象。
	实例方法：
		ifPresent方法接受一个Consumer函数式接口实例作为参数，Consumer函数式接口提供一个void accept(T val)方法，ifPresent方法没有返回值；
		isPresent另一个重载版本，没有参数，返回boolean值，如果包装对象为null返回false，否则返回true；
		map方法接受一个Function函数式接口实例作为参数，Function函数式接口提供一个R apply(T t)方法，map方法使用apply方法返回的对象创建一个新的
Optional对象返回，所以map方法实际上是做了一个映射；
		orElse接受一个与包装对象相同类型的对象作为参数，如果包装对象为null则返回这个参数对象；
		orElseGet方法接受一个Supplier函数式接口实例作为参数，Supplier接口提供一个 T get()方法；orElseGet使用get方法返回的对象作为返回对象；
		orElseThrow方法也接受一个Supplier函数式接口实例作为参数，但是参数对象里直接new Exception，这里可以抛出需要的任何异常。
		filter方法接受一个Predicate函数式接口实例作为参数，Predicate接口提供一个boolean test(T t)方法，包装对象为null，直接返回原Optional对象，
test方法返回true时，filter方法也返回原Optional对象，test方法返回false，filter方法返回一个包装null的Optional对象。


												第十九章 Stream
							（参考：https://lw900925.github.io/java/java8-stream-api.html）

	Stream是Java8开始提供的一套处理集合的API接口，处理模型称为“流式处理”。Stream使用声明式的操作，类似于数据库的查询操作。Stream可以看作是对集合的
包装，对外提供更方便的操作集合的接口。遍历集合时需要自己的程序获取集合中的元素，这称为外部迭代，Stream遍历集合不需要自己的程序再去手动获取元素，称为
内部迭代。Stream除了提供一批更方便的API外，还可以选择使用并行处理，这可以极大地提高程序运行效率。Stream的一个特点是只能遍历一次，遍历结束后不能再次
遍历，否则将抛出异常：IllegalStateException。
	Stream的API可以分为三类：创建流的API、操作流的API和收集流中元素的API。
	创建流：
		静态方法Stream.of()创建流，该方法接收一个变长参数：
			Stream<Stream> stream = Stream.of("A", "B", "C", "D");
		静态方法Stream.empty()创建一个空的流：
			Stream<Stream> stream = Stream.empty();
		静态方法Arrays.stream()从数组创建一个流：
			String[] strs = {"A", "B", "C", "D"};
			Stream<Stream> stream = Arrays.stream(strs);
		Collection接口中有一个方法stream()可以从具体的集合对象创建流，parallelStream()可以创建一个并行流：
			Stream<Integer> stream = Arrays.asList(1,2).stream();
		java.nio.file.Files类中的一些静态方法可以获取流，如Files.lines()方法，该方法接收一个java.nio.file.Path对象，返回一个由文件行构成的字符串流：
			Stream<String> stream = Files.lines(Paths.get("text.txt"), Charset.defaultCharset());
		静态方法Stream.generate()和Stream.iterate()可以从函数生成流：
			Stream.iterate(0, n -> n + 2).limit(51).forEach(System.out::println); //打印0到100的偶数（包括0和100）
			Stream.generate(() -> "Hello Man!").limit(10).forEach(System.out::println);	//打印10个 Hello Man!
			这两个方法生成的流都是无限流，即会不断地添加元素到Stream中，所以需要使用limit限定迭代添加次数。
	操作流：
		forEach()：对流中的每个元素执行某个操作：
			Stream.of("abc","ef","ghijk").forEach(System.out::println);
		filter()：对流的元素过滤：
			Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8).filter(n->n>2).forEach(System.out::println);
		map()：将流的元素映射成另一个元素：	
			Stream.of("abc","ef","ghijk").map(s->s.length()).forEach(System.out::println);
		distinct()：去除流中重复的元素:
			Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8).distinct().forEach(System.out::println);
		sorted()：对流的元素排序：（这个方法有一个重载版本，可以接受一个比较器作为参数）
			Stream.of(1, 8, 5, 2, 1, 0, 9, 2, 0, 4, 8).sorted().forEach(System.out::println);
		peek()：对流中的每个元素执行某个操作：
			empStream.peek((emp)-> emp.setAge(30)).forEach(System.out::println);
		limit()：截取流中前面几个元素:
			Stream.of(1, 8, 5, 2).limit(2).forEach(System.out::println);
		skip()：跳过流中前面几个元素:
			Stream.of(1, 8, 5, 2).skip(2).forEach(System.out::println);
		toArray()：将流转换为数组：（这个方法有一个重载版本）
			Object [] arr = Stream.of(1, 8, 5, 2).toArray();
			Integer [] arr = Stream.of(1, 8, 5, 2).toArray((n)->new Integer[4]);
	收集元素：
	reduce()：对流中的元素归并计算:
		Optional<Integer> result = Stream.of(1, 8, 5, 2).reduce((a, b)->a+b);
		Integer result = Stream.of(1, 8, 5, 2).reduce(0,Integer::sum);
	collect()：收集流中的元素：
		long size = Stream.of(1, 8, 5, 2).collect(Collectors.counting());
		List<Integer> list = Stream.of(1, 8, 5, 2).collect(Collectors.toList());
		Optional<Integer> max = Stream.of(1, 8, 5, 2).collect(Collectors.maxBy(Comparator.comparing(Integer::valueOf)));
		Optional<Integer> min = Stream.of(1, 8, 5, 2).collect(Collectors.minBy(Comparator.comparing(Integer::valueOf)));
	综合统计：
		public class Employee {
			private long empId;
			private long depId;
			private String name;
			private double sal;
			private int level;
			...
		}
		Employee emp1 = new Employee(1L,101L,"jack",8888D,6);
		Employee emp2 = new Employee(2L,101L,"mike",9999D,7);
		Employee emp3 = new Employee(3L,102L,"zake",8555D,6);
		Employee emp4 = new Employee(4L,102L,"cake",9566D,7);

		Stream<Employee> empStream = Stream.of(emp1,emp2,emp3,emp4);
		DoubleSummaryStatistics salStatis = empStream.collect(Collectors.summarizingDouble(Employee::getSal));
		System.out.println("count: "+salStatis.getCount());
		System.out.println("sum: "+salStatis.getSum());
		System.out.println("average: "+salStatis.getAverage());
		System.out.println("max: "+salStatis.getMax());
		System.out.println("min: "+salStatis.getMin());
	连接字符串：String str = Stream.of("A", "B", "C", "D").collect(Collectors.joining(","));
	分组：
		Map<Long,List<Employee>> empMap = empStream.collect(Collectors.groupingBy(Employee::getDepId));
		Map<String,List<Employee>> newMap = empStream.collect(Collectors.groupingBy(emp->{
			if(emp.getSal()>9000){
				return "A";
			}
			else if(emp.getSal()>8000){
				return "B";
			}
			else {
				return "C";
			}
		}));
	多级分组：
		Map<Long,Map<String,List<Employee>>> mapMap = empStream.collect(Collectors.groupingBy(Employee::getDepId,Collectors.groupingBy(emp->{
			if(emp.getSal()>9000){
				return "A";
			}
			else if(emp.getSal()>8000){
				return "B";
			}
			else {
				return "C";
			}
		})));
	分组后统计各个分组的数据量：
		Map<Long,Long> sizeMap = empStream.collect(Collectors.groupingBy(Employee::getDepId,Collectors.counting()));
		//统计各个dep的sal最大的Employee
		Map<Long,Employee> maxMap = empStream.collect(
			Collectors.groupingBy(
				Employee::getDepId,
				Collectors.collectingAndThen(
					Collectors.maxBy(Comparator.comparingDouble(Employee::getSal)),
					Optional::get
				)
			)
		);
	需要注意，不能重复的收集流中的元素。
	可以看出来，上面的写法太冗长了，不易理解，可以使用静态导入减少类名的引用。
		import static java.util.stream.Collectors.*;
		import static java.util.Comparator.*;
		Map<Long,Employee> maxMap = empStream.collect(
			groupingBy(
				Employee::getDepId,
				collectingAndThen(
					maxBy(comparingDouble(Employee::getSal)),
					Optional::get
				)
			)
		);
	并行处理：
	并行流使用集合的parallelStream()方法可以获取一个并行流。Java内部会将流的内容分割成若干个子部分，然后将它们交给多个线程并行处理，
	这样就将工作的负担交给多核CPU的其他内核处理。
	并行处理测试：（计算从1到n的累加值）（本地机器：i5-7500 3.40GHz, DDR4 2400MHz 16.00GB）
	定义n：
		long number = 20000000L;
	测试方法：
	重复测试10次，返回执行时间最短的一次的数据：
		public static long sumTest(Function<Long,Long> func,long number){
			long maxValue = Long.MAX_VALUE;
			for(int i=0;i<10;i++){
				long start = System.nanoTime();
				long sum = func.apply(number);
				long end = System.nanoTime();
				System.out.println("result: "+sum);
				long time = (end-start)/1000000;
				if(time<maxValue){
					maxValue = time;
				}
			}
			return maxValue;
		}
	单线程for循环：
		public static long sumFor(long n){
			long result = 0;
			for(long i=1L;i<=n;i++){
				result += i;
			}
			return result;
		}
	测试：
		System.out.println("total time of sumFor with number:"+number+" is: "+sumTest(StreamDemo2::sumFor,number)+" 毫秒");
		// total time of sumFor with number:20000000 is: 7 毫秒
	单线程stream(使用iterate迭代)：
		public static long sumStream(long n){
			return Stream.iterate(1L,i->i+1).limit(n).reduce(0L,Long::sum);
		}
	测试：
		System.out.println("total time of sumStream with number:"+number+" is: "+sumTest(StreamDemo2::sumStream,number)+" 毫秒");
		// total time of sumStream with number:20000000 is: 147 毫秒
	并行stream(使用iterate迭代):
		public static long sumParallelStream(long n){
			return Stream.iterate(1L,i->i+1).limit(n).parallel().reduce(0L,Long::sum);
		}
	测试：
		System.out.println("total time of sumParallelStream with number:"+number+" is: "+sumTest(StreamDemo2::sumParallelStream,number)+" 毫秒");
		// total time of sumParallelStream with number:20000000 is: 432 毫秒
	单线程stream（不使用iterate迭代）：
		public static long sumLongStream(long n){
			return LongStream.rangeClosed(1L,n).reduce(0L,Long::sum);
		}
	测试：
		System.out.println("total time of sumLongStream with number:"+number+" is: "+sumTest(StreamDemo2::sumLongStream,number)+" 毫秒");
		// total time of sumLongStream with number:20000000 is: 7 毫秒
	并行stream（不使用iterate迭代）：
		public static long sumParallelLongStream(long n){
			return LongStream.rangeClosed(1L,n).parallel().reduce(0L,Long::sum);
		}
	测试：
		System.out.println("total time of sumParallelLongStream with number:"+number+" is: "+sumTest(StreamDemo2::sumParallelLongStream,number)+" 毫秒");
		// total time of sumParallelLongStream with number:20000000 is: 2 毫秒
	根据测试结果可以知道，iterate迭代会造成stream处理变慢，这是因为iterate迭代的后一个迭代依赖前一个迭代的结果，在使用iterate迭代时再启用多线程并行处理，需要线程间
	传递迭代变量，所以变得更慢。使用LongStream.rangeClosed(1L,n)则可以实现分段处理，然后再启用并行处理，就可以实现更快的处理。
		
	补充：使用Class实例和ClassLoader实例加载资源文件：
	Class.getResource(String path)方法可加载执行此方法的代码的classpath下的资源，参数path不以’/'开头时，默认是从此类所在的包下取资源；如果参数 path 以’/'开头，
则是从ClassPath根下获取：
		URL url = IODemo7.class.getResource("/database.properties");	//从classpath根路径下获取资源文件
		URL url = IODemo7.class.getResource("database.properties");		//从classpath下的IODemo7所在包下获取资源文件
	ClassLoader.getResource(String path)参数path不能以'/'开始，默认就是在classpath根路径下加载资源：
		URL url2 = IODemo7.class.getClassLoader().getResource("database.properties");
	即 IODemo7.class.getClassLoader().getResource("database.properties") === IODemo7.class.getResource("/database.properties")
	Class和ClassLoader的实例方法：getResourceAsStream加载资源模式和getResource方法相同，只是返回对象是一个InputStream对象。

	补充：获取系统属性和手动设置系统属性：
		//获取临时目录
		System.out.println(System.getProperty("java.io.tmpdir"));
		//获取处理器数量
        System.out.println(Runtime.getRuntime().availableProcessors());
		//手动设置一个系统属性
        System.setProperty("x.dt.conn.timeout", String.valueOf(2000));
        System.out.println(System.getProperty("x.dt.conn.timeout"));
		
	补充：浮点数保留小数位数：
		double d1 = 55.8;
        double d2 = 196.8;
        System.out.println("55.8 + 196.8 = "+(d1+d2));

        DecimalFormat dft = new DecimalFormat("0.0");
        System.out.println("55.8 + 196.8 = "+dft.format(d1+d2));

    补充：桥接方法(bridge method)
    jdk1.5引入了泛型，而在之前的jdk版本中没有泛型，所以为了保持兼容性，java在编译时时采用了类型擦除，即把泛型类型替换为了Object。
子类在继承泛型父类或实现泛型接口时，如果指定了泛型的实际类型，则编译的方法的泛型类型就是实际类型，这样就和父类或接口的方法签名不一致
了，为了保持语义的一致性，java在编译这种子类时就会生成额外的桥接方法，桥接方法的签名和父类或接口的方法签名保持一致。
    泛型接口：
        public interface Parent<T>{
            T convert(T param);
        }
    编译后：
        public abstract T convert(T);
        descriptor: (Ljava/lang/Object;)Ljava/lang/Object;
        flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT
    实现类：
        public class Child implements Parent<String>{
            public String convert(String param){
                return param.toUpperCase();
            }
        }
    编译后：
        public java.lang.String convert(java.lang.String);
        descriptor: (Ljava/lang/String;)Ljava/lang/String;
        flags: (0x0001) ACC_PUBLIC
        //编译时生成的桥接方法
        public java.lang.Object convert(java.lang.Object);
        descriptor: (Ljava/lang/Object;)Ljava/lang/Object;
        flags: (0x1041) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
    
    headless模式： 
    java.awt.headless是java的一种工作模式，用于在缺失显示屏、鼠标或者键盘时的系统配置。某些服务器不需要显示器、
鼠标甚至键盘，但是运行在其上的某些java服务端程序又需要实现一些字体、图形渲染等依赖这些设备的功能，这时就可以设置
java.awt.headless为true以提供这类功能。
    命令行设置：
        java -Djava.awt.headless=true xxx
    代码中设置：
        System.setProperty("java.awt.headless",Boolean.toString(true));
    这个系统属性默认为null。












































