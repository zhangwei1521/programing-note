												rabbitmq记录
	第一部分：安装
	先安装erlang环境，首先安装erlang依赖：
		sudo yum install -y gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-1.8.0-openjdk-devel git unixODBC
	下载erlang：
		wget https://github.com/erlang/otp/archive/OTP-19.3.6.12.tar.gz
	编译安装erlang，执行：
		./otp_build autoconf
		./configure --prefix=/usr/local/erlang
		make
		make install
	配置环境变量，编辑 /etc/bashrc，添加：
		ERLANG_HOME=/usr/local/erlang
		#注释原PATH
		PATH=$PATH:$ERLANG_HOME/bin
	下载rabbitmq：
		wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.12/rabbitmq-server-generic-unix-3.6.12.tar.xz
	解压缩后配置环境变量，编辑 /etc/bashrc，添加：
		RABBITMQ_HOME=/usr/local/rabbitmq
		PATH=$PATH:$RABBITMQ_HOME/sbin
		export PATH
	刷新配置文件：
		source /etc/bashrc
	检查erlang：
		erl
	启动rabbitmq：
		rabbitmq-server -detached
	关闭rabbitmq：
		rabbitmqctl stop
		# 若单机有多个实例，则在rabbitmqctlh后加–n 指定名称
		# 使用kill命令关闭 kill -9 5479
	查看rabbitmq状态：
		rabbitmqctl status
	查看插件：
		rabbitmq-plugins list
	启用web gui插件：
		rabbitmq-plugins enable rabbitmq_management
	添加用户：
        标准格式：
            rabbitmqctl add_user Username Password
        添加用户 admin
		    rabbitmqctl add_user admin admin
    删除用户：
        标准格式：
            rabbitmqctl delete_user Username
        删除用户 admin
            rabbitmqctl delete_user admin
    查看当前用户列表:
        rabbitmqctl list_users
    rabbitmq用户角色可分为五类，超级管理员, 监控者, 策略制定者, 普通管理者以及其他：
        administrator：
            可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。
        monitoring：
            可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息（进程数，内存使用等）。
        policymaker：
            可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息。
        management：
            仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。
        other：
            无法登陆管理控制台，通常就是普通的生产者和消费者。
	设置角色：
        标准格式：
            rabbitmqctl set_user_tags User Tag
        设置用户 admin 为 administrator：
		    rabbitmqctl set_user_tags admin administrator
        可以给同一用户设置多个角色
            rabbitmqctl set_user_tags admin monitoring policymaker
    rabbitmq中，用户权限指的是用户对exchange，queue的操作权限，包括配置权限，读权限、写权限。
        配置权限控制exchange，queue的声明和删除。
        写权限控制向exchange发送消息以及queue和exchange的绑定(bind)操作。
        读权限控制到从queue里取消息。
    设置用户权限：
        标准格式：
            rabbitmqctl set_permissions -p VHostPath User ConfP WriteP ReadP
        为用户 admin 添加所有权限：
            rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
    查看(指定hostpath)所有用户的权限信息：
        rabbitmqctl list_permissions [-p VHostPath]
    查看指定用户的权限信息：
        rabbitmqctl list_user_permissions User
    清除用户的权限信息
        rabbitmqctl clear_permissions [-p VHostPath] User
	访问web控制界面：
		192.168.56.2:15672
    
    第一个java连接rabbitmq实例：
    rabbitmq客户端maven依赖：
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>4.2.1</version>
        </dependency>
    消息生产者：
        import java.io.IOException;
        import java.util.concurrent.TimeoutException;

        import com.rabbitmq.client.Channel;
        import com.rabbitmq.client.Connection;
        import com.rabbitmq.client.ConnectionFactory;
        import com.rabbitmq.client.MessageProperties;

        public class SimpleMessageProducer {

            private static final String EXCHANGE_NAME = "exchange_demo";
            private static final String QUEUE_NAME = "queue_demo";
            private static final String ROUTING_KEY = "routingkey_demo";
            private static final String IP_ADDRESS = "192.168.137.2";
            private static final int PORT = 5672;
            
            public static void main(String[] args) throws IOException, TimeoutException {
                ConnectionFactory factory = new ConnectionFactory();
                factory.setHost(IP_ADDRESS);
                factory.setPort(PORT);
                factory.setUsername("admin");
                factory.setPassword("admin");
                Connection connection = factory.newConnection();
                Channel channel = connection.createChannel();
                channel.exchangeDeclare(EXCHANGE_NAME, "direct",true,false,null);
                channel.queueDeclare(QUEUE_NAME, true, false, false, null);
                channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);
                String message = "hello rabbitmq";
                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, 
                        MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
                channel.close();
                connection.close();		
            }
        }
    消息消费者：
        import java.io.IOException;
        import java.util.concurrent.TimeoutException;

        import com.rabbitmq.client.AMQP;
        import com.rabbitmq.client.Address;
        import com.rabbitmq.client.Channel;
        import com.rabbitmq.client.Connection;
        import com.rabbitmq.client.ConnectionFactory;
        import com.rabbitmq.client.Consumer;
        import com.rabbitmq.client.DefaultConsumer;
        import com.rabbitmq.client.Envelope;

        public class SimpleMessageConsumer {

            private static final String QUEUE_NAME = "queue_demo";
            private static final String IP_ADDRESS = "192.168.137.2";
            private static final int PORT = 5672;
            
            public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
                Address[] addresses = new Address[] {new Address(IP_ADDRESS,PORT)};
                ConnectionFactory factory = new ConnectionFactory();
                factory.setUsername("admin");
                factory.setPassword("admin");
                Connection connection = factory.newConnection(addresses);
                Channel channel = connection.createChannel();
                channel.basicQos(64);
                Consumer consumer = new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag,Envelope envelope,
                            AMQP.BasicProperties properties,byte[] body) throws IOException {
                        System.out.println("receive message : "+new String(body));
                        channel.basicAck(envelope.getDeliveryTag(), false);
                    }
                };
                channel.basicConsume(QUEUE_NAME, consumer);
                Thread.sleep(10000);
                channel.close();
                connection.close();
            }
        }
    
    
    第二部分 核心概念
    rabbitmq的工作：接收消息、存储消息、转发消息。
    生产者（Producer）投递的消息一般包含2个部分：标签和消息体，可以类比为http请求的请求头和请求数据。标签用于描述消息，如消息要投递的交换器和
消息的路由键等。
    消费者（Consumer）订阅rabbitmq的消息队列，消费队列中的消息时，消息的标签不会被传输给消费者，传输的只有消息体，所以消费者不知道消息的投递者
是谁，从设计上来看，消费者也不需要知道生产者。
    rabbitmq服务节点称为Broker。
    队列（Queue）是Broker内存储消息的结构，多个消费者可以订阅同一个队列，但是一个队列中的一个消息不会被分发给多个消费者，这些消费者是轮流消费
队列中的消息的。
    交换器（Exchange）是Broker内部接收生产者投递消息的对象，交换器收到消息后再将消息路由到一个或多个队列中，如果路由不到接收队列，就会将消息返
回生产者或丢弃该消息。
    路由器（RoutingKey）是生产者投递消息时设置的消息标签的一部分（某些消息可以不设置）。交换器根据消息的路由键和自身和队列的绑定键决定路由路径。
    绑定（Binding）是交换器和队列的关系描述，通常通过绑定键（BindingKey）来表达。队列A和队列B可以使用同一个绑定键绑定同一个交换机。
    rabbitmq常用的交换器类型有4种：fanout、direct、topic、headers。AMQP协议中提供了另外2种交换器：System和自定义。
    fanout交换器无视消息的路由键，将收到的所有消息路由到所有绑定的队列。
    direct交换器将消息路由到绑定键和消息路由键完全匹配的队列。
    topic交换器匹配消息的路由键和自身的绑定键时，采用模糊匹配规则：
        约定BingdingKey使用.分割的字符串可以使用*和#，*表示一个字符串，#表示0或多个字符串
        例子：
            绑定键：*.key1.* 匹配 a.key1.b
            绑定键：#.key2.* 匹配 a.b.key2.c
    headers交换器不使用路由键匹配路由，而是使用消息的headers属性（一个键值对）来路由，headers交换器的绑定键也使用键值对。headers交换器基本不会使用。
    生产者连接rabbitmq Broker投递消息流程：
    与Broker建立Connection，然后打开Channel，然后声明一个Exchange，然后声明一个Queue，然后绑定Exchange和Queue，然后发送消息（消息携带要投递的交换
器和路由键），投递成功后关闭Channel，然后关闭Connection。
    消费者消费消息流程：
    与Broker建立Connection，然后打开Channel，然后发送消费请求（同时指定回调函数），Broker发送消息给消费者，消费者收到消息后发送确认信息给Broker，然
后Broker从队列中删除已确认收到的消息，然后关闭Channel，然后关闭Connection。
    Connection是一个实际的TCP连接，而Channel是建立在Connection上的虚拟连接，发送给Broker的AMQP指令都是通过Channel完成的。
    使用Channel传递消息比起直接使用Connection，可以减小频繁建立和释放TCP连接的性能开销。当每个Channel内的流量较大时，这样做也会导致新的问题，这时需
要增加Connection数量。
    AMQP协议：
    AMQP协议是Rabbitmq实现的主要协议，也是消息队列系统的规范协议。rabbitmq的核心概念其实都来自AMQP协议。
    AMQP协议分为三层：
        Module Layer主要是定义客户端可以调用的命令，即服务端提供给客户端的功能接口，例如Queue.Declare命令用于声明一个队列；
        Session Layer主要是描述客户端和服务端连接的通信模型，例如通信同步机制和错误处理；
        Transport Layer主要是描述底层二进制数据流的处理，比如信道复用等。
    当客户端执行 factory.newConnection() 时，客户端将发送一个AMQP request给Broker，该请求包括一个Protocal Header 0-9-1请求头，标识建立的连接使用
AMQP 0-9-1协议，Broker将返回一个包含Connection.Start响应头的response。


	

	