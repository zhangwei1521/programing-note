										第一章 java的历史和演进
	java继承了其它语言的优秀元素，也提出了自己的新特性、新概念。
计算机编程语言的出现和发展主要是由两个因素推动的，第一个是环境的需要和对环境的适应，第二个是编程思想的演进。
java从C和C++继承了大量的特性。

    C使用的结构化编程模式在编写大型应用程序时其复杂性超出了承受范围，个人认为是普通开发者无法驾驭这样的复杂性导致的。
这将导致企业的开发成本过高，在这种背景下，对开发人员要求更低、同时也更符合普通人思考模式的面向对象模式语言出现了。

    java出现的背景其实是为了实现平台独立，C++程序需要使用为不同CPU编写的编译器编译，C++程序本身也可能设计到操作系统
调用，出现了和操作系统的耦合，难以实现平台独立。而java被设计成基于虚拟机的语言，sun官方提供主流操作系统的虚拟机实现和SDK（包含编译器），
而且不用为每一种CPU提供一个编译器。个人理解是java编译器、虚拟机都只需要和操作系统打交道，而不需要关注CPU。
Internet上的服务器的硬件设施和操作系统的多样性要求开发的程序需要是平台独立的，这也使java兴起的一个重要推动力。
	目前主流的java版本仍然是1.8，学习也以1.8为准。

										第二章 java综述
	两种编程模式：第一种是面向过程编程模式，C语言便是代表，围绕“正在发生什么”编程，代码直接作用于数据；第二种是面向
对象编程模式，围绕“将影响谁”编程，定义了对象这种数据结构，对象封装了数据和操作数据的接口，通过调用对象的接口操作数据，通过组合对象解决复杂性问题。
	OOP三原则：
	封装，即定义对象（类）封装数据和对数据的操作；
	继承，对象（类）可以继承其它对象（类）获得属性和方法，可以减少程序复杂性；
	多态，接口方法只定义功能，不提供具体实现，不同实现类可以选择不同的实现方式。

	开发环境搭建：安装JDK1.8
	配置环境变量：JAVA_HOME	JDK安装路径
				 path		添加;%JAVA_HOME%\bin
				 CLASSPATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
				 //从jdk1.6开始，不需要再配置 classpath环境变量

	编译程序：javac Example.java
	运行程序：java Example

										第三章 数据类型
	强类型的语言有利于在代码编译时进行检测，因此可以避免很多不必要的问题，增强程序的安全性和健壮性。
	java的八种基本数据类型：
		整数型：byte、short、int、long；
		浮点型：float、double；
		字符：char；
		布尔值：boolean；
	int型最大值：2^31-1 = 2147483647；最小值-2^31 = -2147483648；
	java运行时字符类型使用utf-16编码存储，并且只使用16位即两个字节，所以java的char类型只能取unicode码点小于等于  
65535的字符。而unicode码点大于65535的字符由于需要4个字节才能保存，所以java直接就在编译期报错。
	从JDK7开始，java可以使用0b或0B开头后跟0和1表示二进制数，也可以使用下划线分隔数字，使得数位较多的数字更好读，例
如：	int x = 0b1011_1110_1001;
	java默认浮点字面值类型为双精度double型：1.1默认为double类型。
	字符型字面量可以使用这些形式：字符a的三种表示：'a'、97（unicode码点）、'\u0061'(16进制表示)、'\141'(8进制表示);
无法输入的字符还可以使用转义表示法：如换行符使用'\n'。8进制表示并不常用。
	汉字：𤭢	unicode码点为：150370 大于65535，因此无法作为java的单个字符输入，可以使用字符串表示：
String cs = "𤭢";但是cs.length()返回2。
	一个奇怪的错误与类型提升：
	byte b = 50;
	b = b * 2;
	上面的代码将会报错，这是由于b在参与运算b * 2时，进行了类型提升，实际参与运算的类型变成了int，结果也就成了int值
，而将结果赋值给byte型的b就出错了。
	实际上，在没有long、float、double类型变量参与运算时，byte、short、char都会提升为int型的值，有long参与就提升为
long型，有float参与就提升为float型，有double参与就提升为double型。
	java不允许使用未初始化的值。
	数组的声明：int arr[];初始化：int arr[] = new int[10];这种初始化后的数组中都是0；
	更常用的初始化方式：int arr[] = {1,2,3,4,5};
	多维数组：int arr2[] = new int[4][5];也可以只指定第一维的长度：int arr2[] = new int[4][];第二维的长度可以
不相同。
	声明数组的另一种写法： int[] arr;也可以是: int [] arr;
	
										第四章 运算符与条件语句
	左移运算符：<<	在不越界的情况下相当于乘以二： 2<<2 == 8
	右移运算符：>>	在不越界的情况下相当于除以二： 8>>2 == 2,右移使用了符号扩充，所以-1右移总是得到-1.
	无符号右移：>>>	右移不使用符号扩充：所以-1>>>2 == 2^30-1.
	if(c==1 & e++ < 100) d=100;这种写法表示无论c是否等于1，都会对e执行自增1，c等于1且e小于100则d赋值为100.

	switch语句：
	switch(exp){
		case const1:
			...;
			break;
		case const2:
			...;
			break;
		...
		default:
			...;
	}
	JDK7之前exp只能是byte、short、int或枚举类型，现在可以是String类型。case后只能是常量表达式，且不能重复。
	和break、continue连用的标签用来标记代码块，break或continue加标签只能跳到所在的代码块标签处，即break或continue
后的标签必须是当前代码块或当前代码块的上级代码块。
	
										第五章 类和对象
	每个类都定义了一种数据类型（数据结构），声明对象的对象名只是一个变量，通常称为对象引用，大体上可以认为是为对象所分配内存的地址，
但不能像操作指针那样去操作对象引用。new运算符在运行时动态为对象分配内存。
	默认构造函数自动将所有实例变量初始化为其对应类型的默认值：数字为0，布尔为false，对象为null，char为码点为0的字符
	finalize方法的一般形式：
	protected void finalize(){
		...;
	}
	finalize方法通常是jvm在销毁对象前调用以完成一些特殊工作。
	方法调用时的自动类型提升：
	如果只定义了test(double i)；实际上是可以使用test(1)的；
	方法的重载本质上是编程思想的进步，即在方法功能层面上的抽象，例如多个重载的构造方法功能上是一致的，都是为了创建和
初始化对象。
	包表达的是一群在一起的类；
	访问控制和修饰符：public表示可以在任何地方访问修改，private表示只能在类所定义的方法中访问和修改，默认（无访问
修饰符）表示同包下的类可以访问修改，protected表示子类可以继承的属性，跨包的子类中也不能访问父类对象的protected控制
属性，但可以继承。
子类和父类不在同一个包下，子类中也不能访问修改父类对象的默认访问控制属性。
	子类只能继承由 protected 和 public 和无修饰符的的属性，private属性不能被继承。子类跨包则不能继承默认访问控制的属性。
	静态内部类只能访问外部类的静态属性，非静态内部类可以定义在需要的任意代码块中。
	通过外部类的实例对象创建内部类对象：
	Demo1 demo1 = new Demo1();
    InnerClass inner = demo1.new InnerClass();
    可变长参数方法：（varargs方法）：
    void test(String msg, int ... v){
    	System.out.println(msg+" ; length of v is "+v.length);

    }
    调用： test("hello",1,2);
    	   test("hello",1,2,3);
    	   test("hello");
    变长参数实际是一个数组。
	
继承：
	继承的一个好处是可以实现代码复用，创建的子类模型不需要重新声明已经在父类中定义的熟悉和方法，这样写出来的代码就
显得清晰很多。
	可以使用超类的类型变量指向子类的实例对象，这有一些实际的好处，比如说作为多态的一种实现方式，但是需要注意使用
超类的类型变量只能访问在超类中定义的变量和方法，而不能使用实际子类定义的成员。
	子类的构造函数中使用super(args);调用父类的构造函数；并不会创建父类的对象，但是会为父类定义的属性分配内存（堆
空间中）；子类对象调用继承父类的方法时，首先找到与该方法静态绑定的父类字节码对象，在找到和父类字节码对象动态绑定的
父类属性所分配的内存空间。
	如果子类中定义了父类中已有的属性或方法，还是可以使用super访问父类中的对应属性或方法。
	方法的重写和重载是不一样的概念，重写是指子类的方法签名和父类的方法签名完全相同时隐藏父类方法的机制，而重载的方法
的签名是不同的。
	方法的重写是java动态方法调度的基础。所谓动态方法调度其实就是运行时多态，运行时根据对象实例的类型决定使用哪一个
重写方法。
	方法重写提供了“一个接口，多种方法”的特性。
	不能创建抽象类的实例对象，这也说明在构造子类对象实例时不会创建父类的对象。
	通常java在运行时动态分析对方法的调用（方法的源），这称为后期绑定；而final方法不能被重写，所以对final方法的调用
可以在编译期间解析，直接将final方法的源例程字节码和方法的编译代码内联在一起，这称为早期绑定。
	
											第六章 包和接口
	java使用文件系统的目录存储包，目录名和包名必须精确匹配。
	具有确定的包的对象，包名是对象的名称空间的一部分，所以使用java命令运行时不能只写类名。
	一个类implement一个接口时，如果没有全部实现接口中的方法，那么这个类需要被声明为抽象类；接口中未实现的方法将由
继承该类的子类进行实现。
	可以将接口声明为一个类或另一个接口的成员，这称为嵌套接口。引用嵌套接口时必须包含嵌套接口的外层类或接口名进行限定。
	JDK8提供接口的默认方法的动机主要有两点：一个是扩展原有接口的功能而不破坏已有的代码；第二个是为本质上可选的方法提供
默认实现（空实现）以免除实现类自己去提供空实现冗余代码。
	尽管可以提供接口的默认实现，但是仍然不能创建接口的实例对象，接口不能维持状态信息的基本特性没有发生变化。现在的接口
看起来抽象类已经很相像了。
	default String getName(){
        return "hello";
    }
	接口的实现类可以重写接口中的默认方法实现。
	当一个类实现了多个接口，而每个接口都定义了默认实现的方法，则这个类确实相当于继承了多级父类的行为。
	JDK8新增了接口可以添加静态方法的特性，接口的静态方法像类的静态方法一样，通过接口名直接调用，但是实现类不会继承
接口的静态方法。
	