					++++++++++++++++++++++	JAVASCRIPT参考	++++++++++++++++++++++++++

------基本语法-------

语句（statement）：是为了完成某种任务而进行的操作。
表达式（expression）：指一个为了得到返回值的计算式。
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

变量：是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。
var：是变量声明命令。它表示通知解释引擎，要创建一个变量。var a = 1;
注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。
不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量。
如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。
可以在同一条var命令中声明多个变量。var a, b;
变量的类型没有限制，变量可以随时更改类型。
如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。
JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。
这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。
console.log(a);
var a = 1;
输出：undefined

标识符（identifier）：指的是用来识别各种值的合法名称。
JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。
标识符规则：
第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。
第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。
中文是合法的标识符，可以用作变量名。
JavaScript有一些保留字，不能用作标识符：arguments、break、case等。

单行注释，用//起头；多行注释，放在/*和*/之间。<!--和-->也被视为合法的单行注释。但是-->只有在行首，才会被当成单行注释，否则会当作正常的运算。
对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。与不使用区块的情况没有任何区别。
if (2 = x) { ...}：将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。
优先采用“严格相等运算符”（===）。
else代码块总是与离自己最近的那个if语句配对。
switch语句部分和case语句部分，都可以使用表达式。
需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），
而不是相等运算符（==），这意味着比较时不会发生类型转换。

利用三元运算符，在字符串之中插入不同的值：
var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。
不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。
如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。
标签（label），相当于定位符，用于跳转到程序的任意位置。
标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。
标签通常与break语句和continue语句配合使用，跳出特定的循环。
top:
	for (var i = 0; i < 3; i++){
		for (var j = 0; j < 3; j++){
		  if (i === 1 && j === 1) break top;
		  console.log('i=' + i + ', j=' + j);
		}
	}
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) continue top;
      console.log('i=' + i + ', j=' + j);
    }
  }


------数据类型------

JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂时不涉及。）
数值（number）：整数和小数；
字符串（string）：文本；
布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；
undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；
null：表示空值，即此处的值为空；
对象（object）：各种值组成的集合。
数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）
对象的类型：
狭义的对象（object）
数组（array）
函数（function）
确定一个值到底是什么类型：
①typeof运算符：返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean。
	函数返回function。undefined返回undefined。对象返回object。null返回object。
②instanceof运算符：预留...
③Object.prototype.toString方法：预留...

在if语句中，null与undefined都会被自动转为false，相等运算符（==）直接报告两者相等。
根据 C 语言的传统，null可以自动转为0。	5 + null // 5
undefined是一个表示"此处无定义"的原始值，转为数值时为NaN。Number(undefined) // NaN		5 + undefined // NaN
undefined的应用场景：
// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。
将转为false的六个值（表达式计算结果）：undefined、null、false、0、NaN、""或''（空字符串）
注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 	1 === 1.0 // true
某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算 		预留...
使用浮点数表示小数是不精确的：
0.1 + 0.2 === 0.3				// false  
0.3 / 0.1						// 2.9999999999999996
(0.3 - 0.2) === (0.2 - 0.1)		// false

IEEE 754标准
64位浮点数格式：
第1位：符号位，0表示正数，1表示负数；
第2位到第12位（共11位）：指数部分；
第13位到第64位（共52位）：小数部分（即有效数字）

在IEEE-754 标准下，浮点数一共分为：

无穷数：指数位全部为1 同时尾数位全为0。
规格化数：指数位不全为1 同时不全为0。此时浮点数的隐含位有效，其值为1。
0 ：指数位与尾数位都全为0，根据符号位决定正负。
NaN：即Not a Number。非数的指数位全部为1 同时尾数位不全为0。在此前提下，根据尾数位首位是否为1，NaN 还可以分为SNaN 和QNaN 两类。
	前者参与运算时将会发生异常。
非规格化数：指数位全为0 且尾数位不全为0。此时隐含位有效，值为0。另外需要注意，以单精度时为例，真实(32位单精度)指数E 并非0-127=-127，
	而是-126，这样一来就与规格化下最小真实指数E=1-127=-126 达成统一，形成过度。

64位双精度浮点数，精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，都可以精确表示。
如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，
即 JavaScript 无法表示这么小的数，这时会直接返回0。

NaN不等于任何值，包括它本身。
NaN与任何数（包括它自己）的运算，得到的都是NaN。

十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。
0888 // 888
0777 // 511
前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。
唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。
除以正零得到+Infinity，除以负零得到-Infinity
需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。
typeof NaN // 'number'

由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。但是0除以0会得到NaN。
0 / 0 // NaN
0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。
Infinity加上或乘以Infinity，返回的还是Infinity。、
nfinity减去或除以Infinity，得到NaN。
Infinity与undefined计算，返回的都是NaN。
Infinity与null计算时，null会转成0，等同于与0的计算。

=====================================================
parseInt
	parseInt('123') // 123
	parseInt('   81') // 81
	parseInt(1.23) // 1
	// 等同于
	parseInt('1.23') // 1
	parseInt('8a') // 8
	parseInt('12**') // 12
	parseInt('abc') // NaN
	parseInt('.3') // NaN
	parseInt('+1') // 1
	parseInt('0x10') // 16
	parseInt('011') // 11
对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。
	parseInt(1000000000000000000000.5) // 1
	// 等同于
	parseInt('1e+21') // 1
	parseInt(0.0000008) // 8
	// 等同于
	parseInt('8e-7') // 8
parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制：
	parseInt('1000', 2) // 8
	parseInt('1000', 8) // 512
	parseInt('10', 37) // NaN
	parseInt('10', 1) // NaN
	parseInt('10', 0) // 10
	parseInt('10', null) // 10
	parseInt('10', undefined) // 10
	parseInt('1546', 2) // 1
	parseInt('546', 2) // NaN
==========================================================
parseFloat
	parseFloat('3.14') // 3.14
	parseFloat('314e-2') // 3.14
	parseFloat('0.0314E+2') // 3.14
	parseFloat('3.14more non-digit characters') // 3.14
	parseFloat('\t\v\r12.34\n ') // 12.34
	parseFloat([]) // NaN
	parseFloat('FF2') // NaN
	parseFloat('') // NaN
parseFloat和Number比较：
	parseFloat(true)  // NaN
	Number(true) // 1

	parseFloat(null) // NaN
	Number(null) // 0

	parseFloat('') // NaN
	Number('') // 0

	parseFloat('123.45#') // 123.45
	Number('123.45#') // NaN
===========================================================
isNaN
	isNaN(NaN) // true
	isNaN(123) // false
	isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true。
	也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。
	isNaN('Hello') // true
	isNaN({}) // true
	isNaN(['xzy']) // true
	对于空数组和只有一个数值成员的数组，isNaN返回false。原因是这些数组能被Number函数转成数值
	isNaN([]) // false
	isNaN([123]) // false
	isNaN(['123']) // false
判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。
function myIsNaN(value) {
  return value !== value;
}
============================================================
isFinite方法返回一个布尔值，表示某个值是否为正常的数值
	isFinite(Infinity) // false
	isFinite(-Infinity) // false
	isFinite(NaN) // false
	isFinite(undefined) // false
	isFinite(null) // true
	isFinite(-1) // true

//////////////////////////////////////////////////////////////////
字符串
字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。
字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。
连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。
反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。
三种码点表示法：
（1）\HHH
反斜杠后面紧跟三个八进制数（000到377），代表一个字符。只能输出256种字符。
（2）\xHH
\x后面紧跟两个十六进制数（00到FF），代表一个字符。只能输出256种字符。
（3）\uXXXX
\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。
如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。'\a'	// "a"
var s = 'hello';
s[0] // "h"
s[1] // "e"
s[4] // "o"
// 直接对字符串使用方括号运算符
'hello'[1] // "e"
如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。
无法改变字符串之中的单个字符。
	var s = 'hello';
	delete s[0];
	s // "hello"
	s[1] = 'a';
	s // "hello"
length属性返回字符串的长度，该属性也是无法改变的。

JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。

JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。
每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。
但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，
长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。
举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。
JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。
对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。也就是说，JavaScript 返回的字符串长度可能是不正确的。

Base64 编码可以将无法打印出来的字符（如ASCII 码0到31）转成可以打印的字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。
JavaScript 原生提供两个 Base64 相关的方法：
btoa()：任意值转为 Base64 编码
atob()：Base64 编码转为原来的值
这两个方法不适合非 ASCII 码的字符，会报错。
要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
对象
对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。
对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。
如果键名是数值，会被自动转为字符串。
如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
	// 报错
	var obj = {
	  1p: 'Hello World'
	};
属性可以动态创建，不必在对象声明时就指定。
{ foo: 123 }，行首是一个大括号，它到底是表达式还是语句？
	V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。
eval('{foo: 123}') // 123 //如果没有圆括号，eval将其理解为一个代码块
eval('({foo: 123})') // {foo: 123}
读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。
方括号运算符内部还可以使用表达式。方括号运算符内部使用数字键可以不加引号，因为会自动转成字符串。
查看一个对象本身的所有属性，可以使用Object.keys方法。
	var obj = {
	  key1: 1,
	  key2: 2
	};

	Object.keys(obj);
	// ['key1', 'key2']
delete命令用于删除对象的属性，删除成功后返回true。
	var obj = { p: 1 };
	Object.keys(obj) // ["p"]

	delete obj.p // true
	obj.p // undefined
	Object.keys(obj) // []
删除一个不存在的属性，delete不报错，而且返回true。
只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。delete命令只能删除对象本身的属性，无法删除继承的属性
	var obj = Object.defineProperty({}, 'p', {
	  value: 123,
	  configurable: false
	});

	obj.p // 123
	delete obj.p // false
in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。
它的左边是一个字符串，表示属性名，右边是一个对象。
使用对象的hasOwnProperty方法判断，属性是否为对象自身的属性。
	var obj = {};
	if ('toString' in obj) {
	  console.log(obj.hasOwnProperty('toString')) // false
	}
for...in循环用来遍历一个对象的全部属性。它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
toString属性默认是“不可遍历”的。

with语句的作用是操作同一个对象的多个属性时，提供一些书写的方便。
如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。
这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。
因此，建议不要使用with语句，可以考虑用一个临时变量代替with。
	var obj = {};
	with (obj) {
	  p1 = 4;
	  p2 = 5;
	}

	obj.p1 // undefined
	p1 // 4

//////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
函数
三种声明函数的方法：
function 命令
	function print(s) {
	  console.log(s);
	}
函数表达式
	var print = function(s) {
	  console.log(s);
	};
采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
	var print = function x(){
	  console.log(typeof x);
	};

	x
	// ReferenceError: x is not defined

	print()
	// function
这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
Function 构造函数
	var add = new Function(
	  'x',
	  'y',
	  'return x + y'
	);

	// 等同于
	function add(x, y) {
	  return x + y;
	}

Function构造函数可以不使用new命令，返回结果完全一样。总的来说，这种声明函数的方式非常不直观，几乎无人使用。
如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。
JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。
	f();
	function f() {}
但是，如果采用赋值语句定义函数，JavaScript 就会报错。
	f();
	var f = function (){};
	// TypeError: undefined is not a function
对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。
与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。
传递参数时如果有同名的参数，则取最后出现的那个值。
arguments对象包含了函数运行时的所有参数
正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。
通过arguments对象的length属性，可以判断函数调用时到底带几个参数。

闭包：
函数外部无法读取函数内部声明的变量。如果出于种种原因，需要得到函数内的局部变量。
正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数，并返回该函数，通过该内部函数访问原函数的内部变量。
闭包就是上面定义的内部函数。
闭包最大的特点，就是它可以“记住”诞生的环境。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。
	function createIncrementor(start) {
	  return function () {
		return start++;
	  };
	}

	var inc = createIncrementor(5);

	inc() // 5
	inc() // 6
	inc() // 7
闭包可以看作是函数内部作用域的一个接口。
闭包始终在内存中，而闭包的存在依赖于其外部函数，因此其外部函数也始终在内存中，不会在调用结束后，被垃圾回收机制回收。
闭包的另一个用处，是封装对象的私有属性和私有方法。
	function Person(name) {
	  var _age;
	  function setAge(n) {
		_age = n;
	  }
	  function getAge() {
		return _age;
	  }

	  return {
		name: name,
		getAge: getAge,
		setAge: setAge
	  };
	}

	var p1 = Person('张三');
	p1.setAge(25);
	p1.getAge() // 25
注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。
	function(){ /* code */ }();
	// SyntaxError: Unexpected token (
function这个关键字即可以当作语句，也可以当作表达式。
为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。
因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。
解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。
	(function(){ /* code */ }());
	// 或者
	(function(){ /* code */ })();
这就叫做“立即调用的函数表达式”（ IIFE）
通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：
一是不必为函数命名，避免了污染全局变量；
二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。

eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。
为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。
	(function f() {
	  'use strict';
	  eval('var foo = 123');
	  console.log(foo);  // ReferenceError: foo is not defined
	})()
即使在严格模式下，eval依然可以读写当前作用域的变量。
	(function f() {
	  'use strict';
	  var foo = 1;
	  eval('foo = 2');
	  console.log(foo);  // 2
	})()	
为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
数组
任何类型的数据，都可以放入数组。
本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 
数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。
	var arr = ['a', 'b', 'c'];
	Object.keys(arr)
	// ["0", "1", "2"]
JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。
数组的健名是数字，所以不能使用点结构访问。数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。
JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个
只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。
	var arr = ['a', 'b'];
	arr.length // 2
	arr[1000] = 'e';
	arr.length // 1001
数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。
length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。
	var arr = [ 'a', 'b', 'c' ];
	arr.length = 0;
	arr // []
如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。
可以为数组添加属性，但是这不影响length属性的值。
	var a = [];
	a['p'] = 'abc';
	a.length // 0
	a[2.1] = 'abc';
	a.length // 0
如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。arr[-1] = 'a';

in运算符检查某个健名是否存在于对象中，所以也适用于数组。如果数组的某个位置是空位，in运算符返回false。
for...in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for...in遍历数组。
forEach方法：
	var colors = ['red', 'green', 'blue'];
	colors.forEach(function (color) {
	  console.log(color);
	});
当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。var a = [1, , 1]; a.length // 3
数组的空位是可以读取的，返回undefined。使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。
数组的某个位置是空位，与某个位置是undefined，是不一样的。
如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。
如果某个位置是undefined，遍历的时候就不会被跳过。

如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。
典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。
数组的slice方法可以将“类似数组的对象”变成真正的数组。
var arr = Array.prototype.slice.call('arrayLike');
通过call()也可以把数组的方法放到“类似数组的对象”上面。
	function logArgs() {
	  Array.prototype.forEach.call(arguments, function (elem, i) {
		console.log(i + '. ' + elem);
	  });
	}
但是这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。
	var arr = Array.prototype.slice.call('abc');
	arr.forEach(function (chr) {
	  console.log(chr);
	});

===========================================================================================
运算符
加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。
由于加法运算符存在重载，可能执行两种运算
如果运算子是对象，必须先转成原始类型的值，然后再相加。
对象转成原始类型的值，规则如下：
首先，自动调用对象的valueOf方法。
	var obj = { p: 1 };
	obj.valueOf() // { p: 1 }
一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。
对象的toString方法默认返回[object Object]。可以自己定义valueOf方法或toString方法，得到想要的结果。
这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。
+数值运算符
作用在于可以将任何值转为数值（与Number函数的作用相同）。
指数运算符（**）
完成指数运算，前一个运算子是底数，后一个运算子是指数。

相等比较和非相等比较。两者的规则是不一样的。
对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；
否则，将两个运算子都转成数值，再比较数值的大小。
任何值（包括NaN本身）与NaN比较，返回的都是false。
如果运算子是对象，会转为原始类型的值，再进行比较。
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
undefined和null与自身严格相等。
建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。
0 == ''             // true
0 == '0'            // true
2 == true           // false
2 == false          // false

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。
!undefined // true
!null // true
!0 // true
!false //true
!NaN // true
!"" // true

!!x
// 等同于
Boolean(x)
且运算符（&&）往往用于多个表达式的求值:
如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
	't' && 'f' // "f"
	'' && 'f' // ""
短路机制：	
	if (i) {
	  doSomething();
	}
	// 等价于
	i && doSomething();
&&运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。
	true && 'foo' && '' && 4 && 'foo' && true
	// ''
或运算符（||）
如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。
	't' || 'f' // "t"
	'' || 'f' // "f"
||或运算符常用于为一个变量设置默认值。
saveText(this.text || '')
三元运算符：
	't' ? 'hello' : 'world' // "hello"
	0 ? 'hello' : 'world' // "world"
void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。
逗号运算符用于对两个表达式求值，并返回后一个表达式的值。
===============================================================================================================
数据类型的转换
JS中虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。
强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。
Number()转换原始类型：
Number(324) // 324
Number('324') // 324
Number('324abc') // NaN
Number('') // 0
Number(true) // 1
Number(false) // 0
Number(undefined) // NaN
Number(null) // 0
Number函数和parseInt一样也会自动过滤一个字符串前导和后缀的空格。Number('\t\v\r12.34\n') // 12.34
Number()转换对象：
Number方法的参数是对象时，将返回NaN，除非是包含单个值的数组。Number([]) // 0
转换规则：
第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。
第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。
	如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。
第三步，如果toString方法返回的是对象，就报错。
默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，
而toString方法返回对象的类型字符串（比如[object Object]）。所以，Number({}) // NaN
如果toString方法返回的不是原始类型的值，结果就会报错。

String() 可以将任意类型的值转化成字符串：
转换原始类型：
String(123) // "123"
String('abc') // "abc"
String(true) // "true"
String(undefined) // "undefined"
String(null) // "null"
转换对象：
如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。
	String({a: 1}) // "[object Object]"
	String([1, 2, 3]) // "1,2,3"
	String([]) // ""
String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。
先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果valueOf方法返回的是对象，就报错。
String({a: 1})
// "[object Object]"
// 等同于
String({a: 1}.toString())
// "[object Object]"

Boolean函数可以将任意类型的值转为布尔值。
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true，// new Boolean(new Boolean(false))//true

自动转换数据类型的三种场景：
第一种情况，不同类型的数据互相运算。123 + 'abc' // "123abc"
第二种情况，对非布尔值类型的数据求布尔值。
	if ('abc') {
	  console.log('hello')
	}  // "hello"
第三种情况，对非数值类型的值使用一元运算符（即+和-）。
	+ {foo: 'bar'} // NaN
	- [1, 2, 3] // NaN
自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。
比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。
通常不建议使用自动转换。

-----------------------------------------------------------------------------------------------------------
错误处理
JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。
	var err = new Error('出错了');
	err.message // "出错了"
JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。
大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
存在Error的6个派生对象：
1、SyntaxError 对象；
	// 变量名错误
	var 1a;
	// Uncaught SyntaxError: Invalid or unexpected token
2、ReferenceError 对象 
	ReferenceError对象是引用一个不存在的变量时发生的错误。另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。
	// 使用一个不存在的变量
	unknownVariable
	// Uncaught ReferenceError: unknownVariable is not defined
3、RangeError 对象 
	RangeError对象是一个值超出有效范围时发生的错误。
4、TypeError 对象
	TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令
5、URIError 对象
	URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()等
6、EvalError 对象
	eval函数没有被正确执行时，会抛出EvalError错误
自定义错误
	function UserError(message) {
	  this.message = message || '默认信息';
	  this.name = 'UserError';
	}

	UserError.prototype = new Error();
	UserError.prototype.constructor = UserError;
throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。
JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。
try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。
	function cleansUp() {
	  try {
		throw new Error('出错了……');
		console.log('此行不会执行');
	  } finally {
		console.log('完成清理工作');
	  }
	}
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
Object 对象
JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。
Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。
所谓”本身的方法“就是直接定义在Object对象的方法。
所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。
Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。
如果参数为空（或者为undefined和null），Object()返回一个空对象。
var obj = Object(undefined);
var obj = Object(null);
obj instanceof Object // true
如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例
如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。
Object作为构造函数
用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，
如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象
Object本身的方法：
	Object.keys()，Object.getOwnPropertyNames()遍历对象的属性。
	Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。
	Object.getPrototypeOf()：获取对象的Prototype对象。
Object实例对象的方法：
	Object.prototype.valueOf()：返回当前对象对应的值。
	Object.prototype.toString()：返回当前对象对应的字符串形式。
	Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
	Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
	Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
	Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
Object.prototype.toString可以看出一个值到底是什么类型：
	Object.prototype.toString.call(2) // "[object Number]"
	Object.prototype.toString.call('') // "[object String]"
	Object.prototype.toString.call(true) // "[object Boolean]"
	Object.prototype.toString.call(undefined) // "[object Undefined]"
	Object.prototype.toString.call(null) // "[object Null]"
	Object.prototype.toString.call(Math) // "[object Math]"
	Object.prototype.toString.call({}) // "[object Object]"
	Object.prototype.toString.call([]) // "[object Array]"
===========================================================================================================
属性描述对象
作为JavaScript提供的一种内部数据结构，属性描述对象用来描述对象的属性，控制对象属性的行为，比如该属性是否可写、可遍历等等。
每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。
属性描述对象提供6个元属性：
{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它接受两个参数，第一个参数是一个对象，第二个参数是对象的某个属性名。
	var obj = { p: 'a' };
	Object.getOwnPropertyDescriptor(obj, 'p')
	// Object { value: "a",
	//   writable: true,
	//   enumerable: true,
	//   configurable: true
	// }
Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。
	Object.getOwnPropertyDescriptor(obj, 'toString')
	// undefined
Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。
	var obj = Object.defineProperties({}, {
	  p1: { value: 1, enumerable: true },
	  p2: { value: 2, enumerable: false }
	});
	Object.getOwnPropertyNames(obj);
	// ["p1","p2"]
Object.keys只返回对象自身的可遍历属性的全部属性名。

Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它接受三个参数，
	第一个是对象，第二个是要定义或修改的属性名，第三个是属性描述对象。
	var obj = Object.defineProperty({}, 'p', {
	  value: 123,
	  writable: false,
	  enumerable: true,
	  configurable: false
	});
var obj = {};这种普通方式创建的对象的属性的属性描述对象的默认值如下：value、get和set都是undefined，writable、enumerable和configurable都是true;
Object.defineProperty方法的第三个参数即属性描述对象writable、enumerable、configurable默认值都是false。
可以使用Object.defineProperties方法一次性定义或修改多个属性。
	var obj = Object.defineProperties({}, {
	  p1: { value: 123, enumerable: true },
	  p2: { value: 'abc', enumerable: true },
	  p3: { get: function () { return this.p1 + this.p2 },
		enumerable:true,
		configurable:true
	  }
	});
一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。

Object.prototype.propertyIsEnumerable() 
实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。
	var obj = {};
	obj.p = 123;

	obj.propertyIsEnumerable('p') // true
	obj.propertyIsEnumerable('toString') // false
属性描述对象的属性称为元属性：
value、writable、enumerable、configurable、set、get

正常模式下，对writable为false的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对a属性重新赋予一个同样的值。
如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。
	var proto = Object.defineProperty({}, 'foo', {
	  value: 'a',
	  writable: false
	});

	var obj = Object.create(proto);

	obj.foo = 'b';
	obj.foo // 'a'
in运算符不管某个属性是对象自身的还是继承的，都会返回true。
如果一个属性的enumerable为false，下面三个操作不会取到该属性：
for..in循环
Object.keys方法
JSON.stringify方法

configurable和writable都为false，则value不允许修改；
configurable为false，writable不允许从false改为true，enumerable和configurable都不能再被修改。
configurable决定了目标属性是否可以被删除（delete）。

set和get是函数：
	var obj = Object.defineProperty({}, 'p', {
	  get: function () {
		return 'getter';
	  },
	  set: function (value) {
		console.log('setter: ' + value);
	  }
	});
另一种写法：
	var obj = {
	  get p() {
		return 'getter';
	  },
	  set p(value) {
		console.log('setter: ' + value);
	  }
	};
	obj.p();	//"getter"
get和set使得属性可以作为函数调用，被称为存取器，往往用于属性的值依赖对象内部数据的场合。

Object.preventExtensions方法可以使得一个对象无法再添加新的属性。
	var obj = new Object();
	Object.preventExtensions(obj);

	Object.defineProperty(obj, 'p', {
	  value: 'hello'
	});
	// TypeError: Cannot define property:p, object is not extensible.

	obj.p = 1;
	obj.p // undefined
Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。
Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。
Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。
Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。
Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。
上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。
另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性所在的对象，而不能冻结属性指向的对象。
===================================================================================================
Array
	var arr = new Array(2);
	arr.length // 2
	arr // [ empty x 2 ]
	arr[0] // undefined
	0 in arr //false
Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。
如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。
静态方法Array.isArray方法可以识别数组。
数组的valueOf方法返回数组本身。	var arr = [1, 2, 3];  arr.valueOf() // [1, 2, 3]
数组的toString方法返回数组的字符串形式。var arr = [1, 2, 3];	arr.toString() // "1,2,3"
push和pop方法使得数组可以作为栈使用，对空数组使用pop方法，不会报错，而是返回undefined。
shift方法用于删除数组的第一个元素，并返回该元素。shift：移位；
push和shift结合使用，就构成了“先进先出”的队列结构（queue）。
unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。
	var arr = [ 'c', 'd' ];
	arr.unshift('a', 'b') // 4
	arr // [ 'a', 'b', 'c', 'd' ]
join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。如果数组成员是undefined或null或空位，会被转成空字符串。
var a = [1, 2, 3, 4];	a.join(' | ') // "1 | 2 | 3 | 4"
通过call方法，这个方法也可以用于字符串或类似数组的对象。
	var obj = { 0: 'a', 1: 'b', length: 2 };
	Array.prototype.join.call(obj, '-')
	// 'a-b'
concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。
	['hello'].concat(['world'], ['!'])
	// ["hello", "world", "!"]
	[1, 2, 3].concat(4, 5, 6)
	// [1, 2, 3, 4, 5, 6]
如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。
reverse方法用于颠倒排列数组元素，返回改变后的数组。
slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。slice:切片
slice方法的一个重要应用，是将类似数组的对象转为真正的数组。
	Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
	// ['a', 'b']
splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。splice:铰接
sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。
	['d', 'c', 'b', 'a'].sort()
	// ['a', 'b', 'c', 'd']
传入函数自定义排序规则：
	[10111, 1101, 111].sort(function (a, b) {
	  return a - b;
	})
	// [111, 1101, 10111]
map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。
	[1, 2, 3].map(function(elem, index, arr) {
	  return elem * index;
	});
	// [0, 2, 6]
map方法还可以接受第二个参数，用来绑定回调函数内部的this变量
	var arr = ['a', 'b', 'c'];

	[1, 2].map(function (e) {
	  return this[e];
	}, arr)
	// ['b', 'c']
如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。
forEach方法不返回值，只用来操作数据。
	function log(element, index, array) {
	  console.log('[' + index + '] = ' + element);
	}

	[2, 5, 9].forEach(log);
filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。
	[1, 2, 3, 4, 5].filter(function (elem) {
	  return (elem > 3);
	})
	// [4, 5]
some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。
	var arr = [1, 2, 3, 4, 5];
	arr.some(function (elem, index, arr) {
	  return elem >= 3;
	});
	// true
	arr.every(function (elem, index, arr) {
	  return elem >= 3;
	});
	// false
注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。

reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。
	[1, 2, 3, 4, 5].reduce(function (a, b) {
	  console.log(a, b);
	  return a + b;
	})
	// 1 2
	// 3 3
	// 6 4
	// 10 5
	//最后结果：15

	[1, 2, 3, 4, 5].reduce(function (a, b) {
	  return a + b;
	}, 10);
	// 25

	function substract(prev, cur) {
	  return prev - cur;
	}
	[3, 2, 1].reduce(substract) // 0
	[3, 2, 1].reduceRight(substract) // -4
indexOf和lastIndexOf:	
var a = ['a', 'b', 'c'];
a.indexOf('b') // 1
['a', 'b', 'c'].indexOf('a', 1) // -1
 [2, 5, 9, 2].lastIndexOf(2) // 3
链式使用：
	var users = [
	  {name: 'tom', email: 'tom@example.com'},
	  {name: 'peter', email: 'peter@example.com'}
	];

	users
	.map(function (user) {
	  return user.email;
	})
	.filter(function (email) {
	  return /^t/.test(email);
	})
	.forEach(console.log);
	// "tom@example.com"
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
包装对象
Number、String、Boolean
这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；
作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。
原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。
'abc'.length // 3
自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。
var s = 'Hello World';
s.x = 123;
s.x // undefined
给包装对象添加方法和属性：
	String.prototype.double = function () {
	  return this.valueOf() + this.valueOf();
	};

	'abc'.double()
	// abcabc

	Number.prototype.double = function () {
	  return this.valueOf() + this.valueOf();
	};

	(123).double()  //括号不能少
	// 246
false对应的包装对象实例，布尔运算结果也是true。因为所有对象对应的布尔值都是true
	//作为工具方法使用：
	if (Boolean(false)) {
	  console.log('true');
	} // 无输出

	//作为构造函数使用
	if (new Boolean(false)) {
	  console.log('true');
	} // true
Number静态属性：
	POSITIVE_INFINITY	正无穷
	NEGATIVE_INFINITY	负无穷
	NaN					非数
	MAX_VALUE
	MIN_VALUE
	MAX_SAFE_INTEGER
	MIN_SAFE_INTEGER
实例方法：
	(10).toString() // "10"
	(10).toString(2) // "1010" 或
	10..toString(2)  // "1010" 或
	10 .toString(2)  // "1010" 或
	10.0.toString(2) // "1010" 或
	10['toString'](2) // "1010"
	toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。
	10.005.toFixed(2) // "10.01"
	toExponential方法用于将一个数转为科学计数法形式。参数范围为0到20，超出这个范围，会抛出一个 RangeError 错误。
	(1234).toExponential()  // "1.234e+3"
	toPrecision方法用于将一个数转为指定位数的有效数字。用于四舍五入时不太可靠，跟浮点数不是精确储存有关。
	(12.34).toPrecision(3) // "12.3"
自定义方法：
	Number.prototype.add = function (x) {
	  return this + x;
	};

	8['add'](2) // 10

字符串对象：
字符串对象是一个类似数组的对象（很像数组，但不是数组）。
	new String('abc');			// String {0: "a", 1: "b", 2: "c", length: 3}
	(new String('abc'))[1] 		// "b"
作为工具函数使用：String(true)  // "true"
静态方法：
	String.fromCharCode() 	//该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）;对于大于65535的字符需要使用四个字节的UTF-16编码
		String.fromCharCode(97) // "a"
		String.fromCharCode(104, 101, 108, 108, 111)	// "hello"
		String.fromCharCode(0xD842, 0xDFB7)				// "𠮷"
实例属性：
	String.prototype.length
实例方法：
	String.prototype.charAt() 		'abcd'.charAt(1)或'abcd'[1]		//b返回的是字符串
	charCodeAt						'abc'.charCodeAt(1)     // 98	'abc'.charCodeAt(-1) // NaN
	concat							'abc'.concat('def')		//'abcdef'
	slice							'JavaScript'.slice(0, -6) // "Java"
	substring						'JavaScript'.substring(10, 4) // "Script"	// 等同于 'JavaScript'.substring(4, 10) // "Script"		'JavaScript'.substring(4, -3) // "Java" 
	substr							'JavaScript'.substr(4, 6) // "Script"
	indexOf和lastIndexOf
	trim
	toLowerCase和toUpperCase		它们都返回一个新字符串，不改变原字符串。
	match							'cat, bat, sat, fat'.match('at') // ["at"]		返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。
	search							返回匹配的第一个位置
	replace							'aaa'.replace('a', 'b') // "baa"
	split(分裂)							'a|b|c'.split('|') // ["a", "b", "c"]			'a|b|c'.split() // ["a|b|c"]
									如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符	'a|b|c'.split('') // ["a", "|", "b", "|", "c"]
	localeCompare					按自然语言的顺序比较，返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
									'B'.localeCompare('a') // 1
Math对象
	静态属性：						Math.E	Math.PI等
	静态方法：						abs();sqrt();ceil();random()
	Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
		function getRandomArbitrary(min, max) {
			return Math.random() * (max - min) + min;
		}

		getRandomArbitrary(1.5, 6.5)
		// 2.4942810038223864

Date对象
Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。
Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。即使带有参数，Date作为普通函数使用时，返回的还是当前时间。
	Date(2000, 1, 1)返回当前时间
作为构造函数使用：
	var today = new Date();
	返回的是本地时间
	对Date对象求值时总是调用toString方法。
	参数可以是毫秒数（可为负值）、字符串、多个整数
		new Date(-1378218728000)	// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)
		new Date('January 6, 2013');
		new Date(2013, 0, 1, 0, 0, 0, 0)
	只要是能被Date.parse()方法解析的字符串，都可以当作参数。参数会被解释为当前时区的时间
	使用多个整数作参数时，至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。月份从0开始计算
Date.parse
	日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析
Date.UTC 接受年、月、日等变量作为参数，返回毫秒值
	Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。
	Date实例对象的valueOf方法和getTime方法返回的都是本地时间对应的UTC时间和时间零点的毫秒差值：
	Date o = new Date(1970,0,1,0,0,0);
	o.valueOf();	//-28800000
	get*方法返回的都是当前时区的时间，getUTC*方法返回UTC时间
	o.getDate();	//1						o.getUTCDate();	//31
	o.getFullYear()	//1970						o.getUTCFullYear()	//1969
	toString返回本地时间，toUTCString和toISOString都返回UTC时间， toISOString返回ISO8601 写法：// "2012-12-31T16:00:00.000Z"
	toJSON和toISOString返回完全相同
显示本地时间格式：
Date.prototype.toLocaleString()：完整的本地时间。
Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。
Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。
可选项使用：dateObj.toLocaleString([locales[, options]])
d.toLocaleString('en-US') 
























