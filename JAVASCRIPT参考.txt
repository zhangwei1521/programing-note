					++++++++++++++++++++++	JAVASCRIPT参考	++++++++++++++++++++++++++

------基本语法-------

语句（statement）：是为了完成某种任务而进行的操作。
表达式（expression）：指一个为了得到返回值的计算式。
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

变量：是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。
var：是变量声明命令。它表示通知解释引擎，要创建一个变量。var a = 1;
注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。
不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量。
如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。
可以在同一条var命令中声明多个变量。var a, b;
变量的类型没有限制，变量可以随时更改类型。
如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。
JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。
这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。
console.log(a);
var a = 1;
输出：undefined

标识符（identifier）：指的是用来识别各种值的合法名称。
JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。
标识符规则：
第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。
第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。
中文是合法的标识符，可以用作变量名。
JavaScript有一些保留字，不能用作标识符：arguments、break、case等。

单行注释，用//起头；多行注释，放在/*和*/之间。<!--和-->也被视为合法的单行注释。但是-->只有在行首，才会被当成单行注释，否则会当作正常的运算。
对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。与不使用区块的情况没有任何区别。
if (2 = x) { ...}：将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。
优先采用“严格相等运算符”（===）。
else代码块总是与离自己最近的那个if语句配对。
switch语句部分和case语句部分，都可以使用表达式。
需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），
而不是相等运算符（==），这意味着比较时不会发生类型转换。

利用三元运算符，在字符串之中插入不同的值：
var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。
不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。
如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。
标签（label），相当于定位符，用于跳转到程序的任意位置。
标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。
标签通常与break语句和continue语句配合使用，跳出特定的循环。
top:
	for (var i = 0; i < 3; i++){
		for (var j = 0; j < 3; j++){
		  if (i === 1 && j === 1) break top;
		  console.log('i=' + i + ', j=' + j);
		}
	}
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) continue top;
      console.log('i=' + i + ', j=' + j);
    }
  }


------数据类型------

JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂时不涉及。）
数值（number）：整数和小数；
字符串（string）：文本；
布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；
undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；
null：表示空值，即此处的值为空；
对象（object）：各种值组成的集合。
数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）
对象的类型：
狭义的对象（object）
数组（array）
函数（function）
确定一个值到底是什么类型：
①typeof运算符：返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean。
	函数返回function。undefined返回undefined。对象返回object。null返回object。
②instanceof运算符：预留...
③Object.prototype.toString方法：预留...

在if语句中，null与undefined都会被自动转为false，相等运算符（==）直接报告两者相等。
根据 C 语言的传统，null可以自动转为0。	5 + null // 5
undefined是一个表示"此处无定义"的原始值，转为数值时为NaN。Number(undefined) // NaN		5 + undefined // NaN
undefined的应用场景：
// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。
将转为false的六个值（表达式计算结果）：undefined、null、false、0、NaN、""或''（空字符串）
注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 	1 === 1.0 // true
某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算 		预留...
使用浮点数表示小数是不精确的：
0.1 + 0.2 === 0.3				// false  
0.3 / 0.1						// 2.9999999999999996
(0.3 - 0.2) === (0.2 - 0.1)		// false

IEEE 754标准
64位浮点数格式：
第1位：符号位，0表示正数，1表示负数；
第2位到第12位（共11位）：指数部分；
第13位到第64位（共52位）：小数部分（即有效数字）

在IEEE-754 标准下，浮点数一共分为：

无穷数：指数位全部为1 同时尾数位全为0。
规格化数：指数位不全为1 同时不全为0。此时浮点数的隐含位有效，其值为1。
0 ：指数位与尾数位都全为0，根据符号位决定正负。
NaN：即Not a Number。非数的指数位全部为1 同时尾数位不全为0。在此前提下，根据尾数位首位是否为1，NaN 还可以分为SNaN 和QNaN 两类。
	前者参与运算时将会发生异常。
非规格化数：指数位全为0 且尾数位不全为0。此时隐含位有效，值为0。另外需要注意，以单精度时为例，真实(32位单精度)指数E 并非0-127=-127，
	而是-126，这样一来就与规格化下最小真实指数E=1-127=-126 达成统一，形成过度。

64位双精度浮点数，精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，都可以精确表示。
如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，
即 JavaScript 无法表示这么小的数，这时会直接返回0。

NaN不等于任何值，包括它本身。
NaN与任何数（包括它自己）的运算，得到的都是NaN。

十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。
0888 // 888
0777 // 511
前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。
唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。
除以正零得到+Infinity，除以负零得到-Infinity
需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。
typeof NaN // 'number'

由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。但是0除以0会得到NaN。
0 / 0 // NaN
0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。
Infinity加上或乘以Infinity，返回的还是Infinity。、
nfinity减去或除以Infinity，得到NaN。
Infinity与undefined计算，返回的都是NaN。
Infinity与null计算时，null会转成0，等同于与0的计算。

=====================================================
parseInt
	parseInt('123') // 123
	parseInt('   81') // 81
	parseInt(1.23) // 1
	// 等同于
	parseInt('1.23') // 1
	parseInt('8a') // 8
	parseInt('12**') // 12
	parseInt('abc') // NaN
	parseInt('.3') // NaN
	parseInt('+1') // 1
	parseInt('0x10') // 16
	parseInt('011') // 11
对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。
	parseInt(1000000000000000000000.5) // 1
	// 等同于
	parseInt('1e+21') // 1
	parseInt(0.0000008) // 8
	// 等同于
	parseInt('8e-7') // 8
parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制：
	parseInt('1000', 2) // 8
	parseInt('1000', 8) // 512
	parseInt('10', 37) // NaN
	parseInt('10', 1) // NaN
	parseInt('10', 0) // 10
	parseInt('10', null) // 10
	parseInt('10', undefined) // 10
	parseInt('1546', 2) // 1
	parseInt('546', 2) // NaN
==========================================================
parseFloat
	parseFloat('3.14') // 3.14
	parseFloat('314e-2') // 3.14
	parseFloat('0.0314E+2') // 3.14
	parseFloat('3.14more non-digit characters') // 3.14
	parseFloat('\t\v\r12.34\n ') // 12.34
	parseFloat([]) // NaN
	parseFloat('FF2') // NaN
	parseFloat('') // NaN
parseFloat和Number比较：
	parseFloat(true)  // NaN
	Number(true) // 1

	parseFloat(null) // NaN
	Number(null) // 0

	parseFloat('') // NaN
	Number('') // 0

	parseFloat('123.45#') // 123.45
	Number('123.45#') // NaN
===========================================================
isNaN
	isNaN(NaN) // true
	isNaN(123) // false
	isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true。
	也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。
	isNaN('Hello') // true
	isNaN({}) // true
	isNaN(['xzy']) // true
	对于空数组和只有一个数值成员的数组，isNaN返回false。原因是这些数组能被Number函数转成数值
	isNaN([]) // false
	isNaN([123]) // false
	isNaN(['123']) // false
判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。
function myIsNaN(value) {
  return value !== value;
}
============================================================
isFinite方法返回一个布尔值，表示某个值是否为正常的数值
	isFinite(Infinity) // false
	isFinite(-Infinity) // false
	isFinite(NaN) // false
	isFinite(undefined) // false
	isFinite(null) // true
	isFinite(-1) // true

//////////////////////////////////////////////////////////////////
字符串
字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。
字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。
连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。
反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。
三种码点表示法：
（1）\HHH
反斜杠后面紧跟三个八进制数（000到377），代表一个字符。只能输出256种字符。
（2）\xHH
\x后面紧跟两个十六进制数（00到FF），代表一个字符。只能输出256种字符。
（3）\uXXXX
\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。
如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。'\a'	// "a"
var s = 'hello';
s[0] // "h"
s[1] // "e"
s[4] // "o"
// 直接对字符串使用方括号运算符
'hello'[1] // "e"
如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。
无法改变字符串之中的单个字符。
	var s = 'hello';
	delete s[0];
	s // "hello"
	s[1] = 'a';
	s // "hello"
length属性返回字符串的长度，该属性也是无法改变的。

JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。

JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。
每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。
但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，
长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。
举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。
JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。
对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。也就是说，JavaScript 返回的字符串长度可能是不正确的。

Base64 编码可以将无法打印出来的字符（如ASCII 码0到31）转成可以打印的字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。
JavaScript 原生提供两个 Base64 相关的方法：
btoa()：任意值转为 Base64 编码
atob()：Base64 编码转为原来的值
这两个方法不适合非 ASCII 码的字符，会报错。
要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
对象
对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。
对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。
如果键名是数值，会被自动转为字符串。
如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
	// 报错
	var obj = {
	  1p: 'Hello World'
	};
属性可以动态创建，不必在对象声明时就指定。
{ foo: 123 }，行首是一个大括号，它到底是表达式还是语句？
	V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。
eval('{foo: 123}') // 123 //如果没有圆括号，eval将其理解为一个代码块
eval('({foo: 123})') // {foo: 123}
读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。
方括号运算符内部还可以使用表达式。方括号运算符内部使用数字键可以不加引号，因为会自动转成字符串。
查看一个对象本身的所有属性，可以使用Object.keys方法。
	var obj = {
	  key1: 1,
	  key2: 2
	};

	Object.keys(obj);
	// ['key1', 'key2']
delete命令用于删除对象的属性，删除成功后返回true。
	var obj = { p: 1 };
	Object.keys(obj) // ["p"]

	delete obj.p // true
	obj.p // undefined
	Object.keys(obj) // []
删除一个不存在的属性，delete不报错，而且返回true。
只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。delete命令只能删除对象本身的属性，无法删除继承的属性
	var obj = Object.defineProperty({}, 'p', {
	  value: 123,
	  configurable: false
	});

	obj.p // 123
	delete obj.p // false
in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。
它的左边是一个字符串，表示属性名，右边是一个对象。
使用对象的hasOwnProperty方法判断，属性是否为对象自身的属性。
	var obj = {};
	if ('toString' in obj) {
	  console.log(obj.hasOwnProperty('toString')) // false
	}
for...in循环用来遍历一个对象的全部属性。它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
toString属性默认是“不可遍历”的。

with语句的作用是操作同一个对象的多个属性时，提供一些书写的方便。
如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。
这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。
因此，建议不要使用with语句，可以考虑用一个临时变量代替with。
	var obj = {};
	with (obj) {
	  p1 = 4;
	  p2 = 5;
	}

	obj.p1 // undefined
	p1 // 4

//////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
函数
三种声明函数的方法：
function 命令
	function print(s) {
	  console.log(s);
	}
函数表达式
	var print = function(s) {
	  console.log(s);
	};
采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
	var print = function x(){
	  console.log(typeof x);
	};

	x
	// ReferenceError: x is not defined

	print()
	// function
这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
Function 构造函数
	var add = new Function(
	  'x',
	  'y',
	  'return x + y'
	);

	// 等同于
	function add(x, y) {
	  return x + y;
	}

Function构造函数可以不使用new命令，返回结果完全一样。总的来说，这种声明函数的方式非常不直观，几乎无人使用。
如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。
JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。
	f();
	function f() {}
但是，如果采用赋值语句定义函数，JavaScript 就会报错。
	f();
	var f = function (){};
	// TypeError: undefined is not a function
对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。
与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。
传递参数时如果有同名的参数，则取最后出现的那个值。
arguments对象包含了函数运行时的所有参数
正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。
通过arguments对象的length属性，可以判断函数调用时到底带几个参数。

闭包：
函数外部无法读取函数内部声明的变量。如果出于种种原因，需要得到函数内的局部变量。
正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数，并返回该函数，通过该内部函数访问原函数的内部变量。
闭包就是上面定义的内部函数。
闭包最大的特点，就是它可以“记住”诞生的环境。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。
	function createIncrementor(start) {
	  return function () {
		return start++;
	  };
	}

	var inc = createIncrementor(5);

	inc() // 5
	inc() // 6
	inc() // 7
闭包可以看作是函数内部作用域的一个接口。
闭包始终在内存中，而闭包的存在依赖于其外部函数，因此其外部函数也始终在内存中，不会在调用结束后，被垃圾回收机制回收。
闭包的另一个用处，是封装对象的私有属性和私有方法。
	function Person(name) {
	  var _age;
	  function setAge(n) {
		_age = n;
	  }
	  function getAge() {
		return _age;
	  }

	  return {
		name: name,
		getAge: getAge,
		setAge: setAge
	  };
	}

	var p1 = Person('张三');
	p1.setAge(25);
	p1.getAge() // 25
注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。
	function(){ /* code */ }();
	// SyntaxError: Unexpected token (
function这个关键字即可以当作语句，也可以当作表达式。
为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。
因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。
解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。
	(function(){ /* code */ }());
	// 或者
	(function(){ /* code */ })();
这就叫做“立即调用的函数表达式”（ IIFE）
通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：
一是不必为函数命名，避免了污染全局变量；
二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。

eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。
为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。
	(function f() {
	  'use strict';
	  eval('var foo = 123');
	  console.log(foo);  // ReferenceError: foo is not defined
	})()
即使在严格模式下，eval依然可以读写当前作用域的变量。
	(function f() {
	  'use strict';
	  var foo = 1;
	  eval('foo = 2');
	  console.log(foo);  // 2
	})()	
为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
数组
任何类型的数据，都可以放入数组。
本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 
数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。
	var arr = ['a', 'b', 'c'];
	Object.keys(arr)
	// ["0", "1", "2"]
JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。
数组的健名是数字，所以不能使用点结构访问。数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。
JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个
只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。
	var arr = ['a', 'b'];
	arr.length // 2
	arr[1000] = 'e';
	arr.length // 1001
数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。
length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。
	var arr = [ 'a', 'b', 'c' ];
	arr.length = 0;
	arr // []
如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。
可以为数组添加属性，但是这不影响length属性的值。
	var a = [];
	a['p'] = 'abc';
	a.length // 0
	a[2.1] = 'abc';
	a.length // 0
如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。arr[-1] = 'a';

in运算符检查某个健名是否存在于对象中，所以也适用于数组。如果数组的某个位置是空位，in运算符返回false。
for...in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for...in遍历数组。
forEach方法：
	var colors = ['red', 'green', 'blue'];
	colors.forEach(function (color) {
	  console.log(color);
	});
当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。var a = [1, , 1]; a.length // 3
数组的空位是可以读取的，返回undefined。使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。
数组的某个位置是空位，与某个位置是undefined，是不一样的。
如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。
如果某个位置是undefined，遍历的时候就不会被跳过。

如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。
典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。
数组的slice方法可以将“类似数组的对象”变成真正的数组。
var arr = Array.prototype.slice.call('arrayLike');
通过call()也可以把数组的方法放到“类似数组的对象”上面。
	function logArgs() {
	  Array.prototype.forEach.call(arguments, function (elem, i) {
		console.log(i + '. ' + elem);
	  });
	}
但是这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。
	var arr = Array.prototype.slice.call('abc');
	arr.forEach(function (chr) {
	  console.log(chr);
	});

===========================================================================================
+运算符
加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。
由于加法运算符存在重载，可能执行两种运算
如果运算子是对象，必须先转成原始类型的值，然后再相加。
对象转成原始类型的值，规则如下：
首先，自动调用对象的valueOf方法。
	var obj = { p: 1 };
	obj.valueOf() // { p: 1 }
一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。
对象的toString方法默认返回[object Object]。可以自己定义valueOf方法或toString方法，得到想要的结果。
这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。
+数值运算符
作用在于可以将任何值转为数值（与Number函数的作用相同）。
指数运算符（**）
完成指数运算，前一个运算子是底数，后一个运算子是指数。

相等比较和非相等比较。两者的规则是不一样的。
对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；
否则，将两个运算子都转成数值，再比较数值的大小。
任何值（包括NaN本身）与NaN比较，返回的都是false。
如果运算子是对象，会转为原始类型的值，再进行比较。
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
undefined和null与自身严格相等。
建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。
0 == ''             // true
0 == '0'            // true
2 == true           // false
2 == false          // false

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。
!undefined // true
!null // true
!0 // true
!false //true
!NaN // true
!"" // true

!!x
// 等同于
Boolean(x)
且运算符（&&）往往用于多个表达式的求值:
如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
	't' && 'f' // "f"
	'' && 'f' // ""
短路机制：	
	if (i) {
	  doSomething();
	}
	// 等价于
	i && doSomething();
&&运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。
	true && 'foo' && '' && 4 && 'foo' && true
	// ''
或运算符（||）
如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。
	't' || 'f' // "t"
	'' || 'f' // "f"
||或运算符常用于为一个变量设置默认值。
saveText(this.text || '')
三元运算符：
	't' ? 'hello' : 'world' // "hello"
	0 ? 'hello' : 'world' // "world"
void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。
逗号运算符用于对两个表达式求值，并返回后一个表达式的值。
===============================================================================================================
数据类型的转换
JS中虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。
强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。
Number()转换原始类型：
Number(324) // 324
Number('324') // 324
Number('324abc') // NaN
Number('') // 0
Number(true) // 1
Number(false) // 0
Number(undefined) // NaN
Number(null) // 0
Number函数和parseInt一样也会自动过滤一个字符串前导和后缀的空格。Number('\t\v\r12.34\n') // 12.34
Number()转换对象：
Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。Number([]) // 0
转换规则：
第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。
第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。
	如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。
第三步，如果toString方法返回的是对象，就报错。
默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，
而toString方法返回对象的类型字符串（比如[object Object]）。所以，Number({}) // NaN
如果toString方法返回的不是原始类型的值，结果就会报错。

String() 可以将任意类型的值转化成字符串：
转换原始类型：
String(123) // "123"
String('abc') // "abc"
String(true) // "true"
String(undefined) // "undefined"
String(null) // "null"
转换对象：
如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。
	String({a: 1}) // "[object Object]"
	String([1, 2, 3]) // "1,2,3"
	String([]) // ""
String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。
先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果valueOf方法返回的是对象，就报错。
String({a: 1})
// "[object Object]"
// 等同于
String({a: 1}.toString())
// "[object Object]"

Boolean函数可以将任意类型的值转为布尔值。
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true

自动转换数据类型的三种场景：
第一种情况，不同类型的数据互相运算。123 + 'abc' // "123abc"
第二种情况，对非布尔值类型的数据求布尔值。
	if ('abc') {
	  console.log('hello')
	}  // "hello"
第三种情况，对非数值类型的值使用一元运算符（即+和-）。
	+ {foo: 'bar'} // NaN
	- [1, 2, 3] // NaN
自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。
比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。
通常不建议使用自动转换。




















