					++++++++++++++++++++++	JAVASCRIPT参考	++++++++++++++++++++++++++

------基本语法-------

语句（statement）：是为了完成某种任务而进行的操作。
表达式（expression）：指一个为了得到返回值的计算式。
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

变量：是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。
var：是变量声明命令。它表示通知解释引擎，要创建一个变量。var a = 1;
注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。
不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量。
如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。
可以在同一条var命令中声明多个变量。var a, b;
变量的类型没有限制，变量可以随时更改类型。
如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。
JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。
这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。
console.log(a);
var a = 1;
输出：undefined

标识符（identifier）：指的是用来识别各种值的合法名称。
JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。
标识符规则：
第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。
第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。
中文是合法的标识符，可以用作变量名。
JavaScript有一些保留字，不能用作标识符：arguments、break、case等。

单行注释，用//起头；多行注释，放在/*和*/之间。<!--和-->也被视为合法的单行注释。但是-->只有在行首，才会被当成单行注释，否则会当作正常的运算。
对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。与不使用区块的情况没有任何区别。
if (2 = x) { ...}：将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。
优先采用“严格相等运算符”（===）。
else代码块总是与离自己最近的那个if语句配对。
switch语句部分和case语句部分，都可以使用表达式。
需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），
而不是相等运算符（==），这意味着比较时不会发生类型转换。

利用三元运算符，在字符串之中插入不同的值：
var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。
不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。
如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。
标签（label），相当于定位符，用于跳转到程序的任意位置。
标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。
标签通常与break语句和continue语句配合使用，跳出特定的循环。
top:
	for (var i = 0; i < 3; i++){
		for (var j = 0; j < 3; j++){
		  if (i === 1 && j === 1) break top;
		  console.log('i=' + i + ', j=' + j);
		}
	}
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) continue top;
      console.log('i=' + i + ', j=' + j);
    }
  }


------数据类型------

JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂时不涉及。）
数值（number）：整数和小数；
字符串（string）：文本；
布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；
undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；
null：表示空值，即此处的值为空；
对象（object）：各种值组成的集合。
数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）
对象的类型：
狭义的对象（object）
数组（array）
函数（function）
确定一个值到底是什么类型：
①typeof运算符：返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean。
	函数返回function。undefined返回undefined。对象返回object。null返回object。
②instanceof运算符：预留...
③Object.prototype.toString方法：预留...

在if语句中，null与undefined都会被自动转为false，相等运算符（==）直接报告两者相等。
根据 C 语言的传统，null可以自动转为0。	5 + null // 5
undefined是一个表示"此处无定义"的原始值，转为数值时为NaN。Number(undefined) // NaN		5 + undefined // NaN
undefined的应用场景：
// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。
将转为false的六个值（表达式计算结果）：undefined、null、false、0、NaN、""或''（空字符串）
注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 	1 === 1.0 // true
某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算 		预留...
使用浮点数表示小数是不精确的：
0.1 + 0.2 === 0.3				// false  
0.3 / 0.1						// 2.9999999999999996
(0.3 - 0.2) === (0.2 - 0.1)		// false

IEEE 754标准
64位浮点数格式：
第1位：符号位，0表示正数，1表示负数；
第2位到第12位（共11位）：指数部分；
第13位到第64位（共52位）：小数部分（即有效数字）

在IEEE-754 标准下，浮点数一共分为：

无穷数：指数位全部为1 同时尾数位全为0。
规格化数：指数位不全为1 同时尾不全为0。此时浮点数的隐含位有效，其值为1。
0 ：指数位与尾数位都全为0，根据符号位决定正负。
NaN：即Not a Number。非数的指数位全部为1 同时尾数位不全为0。在此前提下，根据尾数位首位是否为1，NaN 还可以分为SNaN 和QNaN 两类。
	前者参与运算时将会发生异常。
非规格化数：指数位全为0 且尾数位不全为0。此时隐含位有效，值为0。另外需要注意，以单精度时为例，真实指数E 并非0-127=-127，
	而是-126，这样一来就与规格化下最小真实指数E=1-127=-126 达成统一，形成过度。

精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，都可以精确表示。
如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，
即 JavaScript 无法表示这么小的数，这时会直接返回0。

NaN不等于任何值，包括它本身。
NaN与任何数（包括它自己）的运算，得到的都是NaN。

十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。
0888 // 888
0777 // 511
前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。
唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。
除以正零得到+Infinity，除以负零得到-Infinity
需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。
typeof NaN // 'number'

由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。但是0除以0会得到NaN。
0 / 0 // NaN
0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。
Infinity加上或乘以Infinity，返回的还是Infinity。、
nfinity减去或除以Infinity，得到NaN。
Infinity与undefined计算，返回的都是NaN。
Infinity与null计算时，null会转成0，等同于与0的计算。

=====================================================
parseInt
	parseInt('123') // 123
	parseInt('   81') // 81
	parseInt(1.23) // 1
	// 等同于
	parseInt('1.23') // 1
	parseInt('8a') // 8
	parseInt('12**') // 12
	parseInt('abc') // NaN
	parseInt('.3') // NaN
	parseInt('+1') // 1
	parseInt('0x10') // 16
	parseInt('011') // 11
对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。
	parseInt(1000000000000000000000.5) // 1
	// 等同于
	parseInt('1e+21') // 1
	parseInt(0.0000008) // 8
	// 等同于
	parseInt('8e-7') // 8
parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制：
	parseInt('1000', 2) // 8
	parseInt('1000', 8) // 512
	parseInt('10', 37) // NaN
	parseInt('10', 1) // NaN
	parseInt('10', 0) // 10
	parseInt('10', null) // 10
	parseInt('10', undefined) // 10
	parseInt('1546', 2) // 1
	parseInt('546', 2) // NaN
==========================================================
parseFloat
	parseFloat('3.14') // 3.14
	parseFloat('314e-2') // 3.14
	parseFloat('0.0314E+2') // 3.14
	parseFloat('3.14more non-digit characters') // 3.14
	parseFloat('\t\v\r12.34\n ') // 12.34
	parseFloat([]) // NaN
	parseFloat('FF2') // NaN
	parseFloat('') // NaN
parseFloat和Number比较：
	parseFloat(true)  // NaN
	Number(true) // 1

	parseFloat(null) // NaN
	Number(null) // 0

	parseFloat('') // NaN
	Number('') // 0

	parseFloat('123.45#') // 123.45
	Number('123.45#') // NaN
===========================================================
isNaN
	isNaN(NaN) // true
	isNaN(123) // false
	isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true。
	也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。
	isNaN('Hello') // true
	isNaN({}) // true
	isNaN(['xzy']) // true
	对于空数组和只有一个数值成员的数组，isNaN返回false。原因是这些数组能被Number函数转成数值
	isNaN([]) // false
	isNaN([123]) // false
	isNaN(['123']) // false
判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。
function myIsNaN(value) {
  return value !== value;
}
============================================================
isFinite方法返回一个布尔值，表示某个值是否为正常的数值
	isFinite(Infinity) // false
	isFinite(-Infinity) // false
	isFinite(NaN) // false
	isFinite(undefined) // false
	isFinite(null) // true
	isFinite(-1) // true









