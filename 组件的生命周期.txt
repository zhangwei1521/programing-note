组件的生命周期

	ReactDOM.render(
		<Header />, 
		document.getElementById('root')
	)
编译后：
	ReactDOM.render(
		React.createElement(Header, null), 
		document.getElementById('root')
	)
解释：
	// React.createElement 中实例化一个 Header
	const header = new Header(props, children)		---> constructor()
	
	// React.createElement 中调用 header.render 方法渲染组件的内容
	const headerJsxObject = header.render()     	---> render()

	// ReactDOM 用渲染后的 JavaScript 对象来来构建真正的 DOM 元素
	const headerDOM = createDOMFromObject(headerJsxObject)
	
	// ReactDOM 把 DOM 元素塞到页面上
	document.getElementById('root').appendChild(headerDOM)

	使用setState({stateA:'xx'})更新state后，会重新调用render返回一个新的虚拟DOM对象，react根据新的虚拟DOM和原虚拟DOM对象对比
	得出需要更新的部分，再更新对应的页面DOM部分
	
react提供另外的生命周期方法：（挂载阶段）
componentWillMount();   -----在constructor()调用后，render()调用前调用执行；
componentDidMount();    -----在 DOM 元素塞入页面以后调用执行；
componentWillUnmount(); ----->组件对应的 DOM 元素从页面中删除之前调用。

--生命周期方法做了什么？
constructor() 			--->完成组件自身的状态的初始化工作;
componentWillMount() 	--->一些组件启动的动作，包括像 Ajax 数据的拉取操作、一些定时器的启动等;
componentDidMount()		--->有些组件的启动工作是依赖 DOM 的，例如动画的启动，使用componentDidMount()来启动;
componentWillUnmount()  --->清除该组件的定时器和完成其他的数据清理工作;

更新阶段的组件生命周期方法：
shouldComponentUpdate(nextProps, nextState)：通过这个方法控制组件是否重新渲染。如果返回 false 组件就不会重新渲染。
componentWillReceiveProps(nextProps)：组件从父组件接收到新的 props 之前调用。
componentWillUpdate()：组件开始重新渲染之前调用。
componentDidUpdate()：组件重新渲染并且把更改变更到真实的 DOM 以后调用。

==================================================================================================================
Virtual DOM 初步理解：
// 1. 构建虚拟DOM
	使用原生JS对象表示 DOM 树上的结构、属性信息
	function Element (tagName, props, children) {
	  this.tagName = tagName
	  this.props = props
	  this.children = children
	}

	module.exports = function (tagName, props, children) {
	  return new Element(tagName, props, children)
	}
--------------------------------------------------------------
	var el = require('./element')
	var ul = el('ul', {id: 'list'}, [
	  el('li', {class: 'item'}, ['Item 1']),
	  el('li', {class: 'item'}, ['Item 2']),
	  el('li', {class: 'item'}, ['Item 3'])
	])
	现在ul是一个 JavaScript 对象表示的 DOM 结构，即虚拟DOM对象
	
// 2. 通过虚拟DOM构建真正的DOM
	Element.prototype.render = function () {
		var el = document.createElement(this.tagName) // 根据tagName构建
		var props = this.props

		for (var propName in props) { // 设置节点的DOM属性
		var propValue = props[propName]
		el.setAttribute(propName, propValue)
		}

		var children = this.children || []

		children.forEach(function (child) {
		var childEl = (child instanceof Element)
		  ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点
		  : document.createTextNode(child) // 如果字符串，只构建文本节点
		el.appendChild(childEl)
		})

		return el
	}
	render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来
------------------------------------------------------------------------------------------------------------
	var ulRoot = ul.render()
	document.body.appendChild(ulRoot)
	ulRoot是一个真正的DOM节点，可以被插入页码
	
// 3. 生成新的虚拟DOM
	var ol = el('ol', {id: 'list'}, [
		el('li', {class: 'item1'}, ['Item 1']),
		el('li', {class: 'item2'}, ['Item 2']),
		el('li', {class: 'item3'}, ['Item 3'])
	])
	
// 4. 比较两棵虚拟DOM树的不同
	var patches = diff(ul, ol)
	
// 5. 在真正的DOM元素上应用变更
	patch(ulRoot, patches)