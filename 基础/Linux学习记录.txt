										Linux学习记录
	Linux是一个操作系统内核，RHEL、CentOS、Ubuntu等发行版是将linux内核和各种GNU工具打包在一起后发布的完整操作系统。几种
常见linux发行版：
		早期 Red Hat --> Fedora		Debian -->		Slackware -->
				|						   |				|
				RHEL --> 					  Ubuntu -->		SUSE -->
				|
				CentOS --> 
	
	CentOS安装:基于Vmware Workstation
	新建虚拟机：vmware中选择创建新的虚拟机，然后选择“稍后安装操作系统”，继续直到选择安装位置，选择一个有足够空间的盘符下的文件夹，
输入虚拟机名，下一步设置分配的磁盘容量，使用默认20G就够了，下一步后点击“自定义硬件”，其中“CD/DVD”项不修改，网络设备
选择NAT，然后关闭就结束了。
	几种网络模式说明：桥接模式——虚拟机和物理机以并列方式连接同一个网络，NAT模式——物理机作为虚拟机的“路由器”，
仅主机模式——相当于使用网线直接连接虚拟机和物理机。
	安装linux：在新建的虚拟机主页，点击“编辑虚拟机设置”，“CD/DVD”项选择“使用ISO镜像文件”，选择下载的centos镜像。然后确定。
虚拟机主页点击“开启此虚拟机”，进入安装过程，选择第一行“Install ...”，回车后设置语言等，继续到安装信息摘要，点击“安装位置”，
选中“我要配置分区”，点击“完成”，进入分区界面，LVM下拉框选择“标准分区”，点击 + 号设置挂载点为 /boot，期望容量为 200M，然后
添加挂载点。继续添加 swap 分区，4GB，根分区 /，期望容量留空，表示将剩下的空间全部给根挂载点。点击完成-->接受更改-->开始安装，
点击“ROOT密码”设置root密码，然后继续直到安装完成，点击重启。输入root、root密码后登陆系统。

	NAT网络连接模式设置：
	1、检查宿主机的VMware DHCP Service 和VMwareNAT Service两个服务是否启动
	2、设置宿主机的本地连接的属性：共享--允许其他网络用户通过此计算机的Internet连接来连接，选择VMnet8.
	3、查看本机使用的DNS：ipconfig -all,设置VMnet8网络适配器的Ipv4属性：ip地址使用一个需要的局域网地址，DNS设置为宿主机使用的DNS
	4、VMware的虚拟网络编辑器中选择NAT模式，子网ip设置为VMnet8设定的网段，NAT设置中网关地址设置为VMnet8的地址。
	5、使用 dhclient 自动获取一个ip地址，使用 ip addr查看ip地址。使用 ping -c 4 www.baidu.com 测试网络联通性。
	6、使用 vi /etc/sysconfig/network-scripts/ifcfg-ens33 设置静态ip：ONBOOT=no 改为yes（网卡驱动随着系统一起启动），
		# BOOTPROTO改为static（静态ip）
		BOOTPROTO=dhcp
		# 设置静态ip
		IPADDR=192.168.112.88（VMnet8设置的网段中的一个地址）
		NETMASK=255.255.255.0
		GATEWAY=192.168.112.2（VMnet8的地址）
		DNS1=119.29.29.29（VMnet8设置的DNS地址，也就是宿主机的DNS）
	7、使用 systemctl restart network.service 重启网络服务。

	使用图形用户界面登陆，默认在tty1，但是tty命令显示是0，可以使用Ctrl+Alt+(F2~F6)不关闭图形服务切换到命令行，使用
Ctrl+Alt+F1切换回图形用户界面。
	图形用户界面使用 init 3 关闭图形服务并切换到命令行界面。
	使用 startx 开启图形服务。（最好不使用）
	centos 7.x 查询到当前所设定的状态:	
		systemctl get-default
		# multi-user.target 相当于以前的 level 3，也就是命令行终端；
		# graphical.target 相当于以前的 level 5，也就是图形界面。
	设置默认启动到图形界面:	
		systemctl set-default graphical.target
	
	快捷键：Ctrl+D 退出当前终端 Ctrl+C 结束当前命令 Ctrl+Z暂停当前进程，使用fg恢复 Ctrl+A移动光标到行首，Ctrl+E移动光标到行尾。

	关机：
		# 马上关机
		shutdown -h now
		# 1分钟后关机
		shutdown -h 1
		# 取消关机
		shutdown -c
		# 重启
		shutdown -r
		# 使用 init 0 也可以关机
		init 0
		# 关闭电源
		poweroff
	关机前将内存中数据写到磁盘:
		sync

	忘记root用户密码处理方法：
	1.重启系统，加载内核前使用下键停止继续启动，然后移动到第一行输入e进入编辑界面，找到linux16开头的行，修改ro为
		rw init=/sysroot/bin/bash
然后Ctrl+x进入emergency模式，使用chroot切换到sysroot（原始系统）[chroot /sysroot/]，使用LANG=en改变当前终端
语言为英语，然后使用passwd输入新密码,touch /.autorelabel 使修改生效，然后使用Ctrl+D，reboot重启系统。
	2.使用rescue模式：虚拟机中电源处选择“打开电源进入固件”，进入BIOS后设置启动系统从光驱开始（将CD-ROM移到最前），F10
保存退出后进入光驱启动模式，使用下键选择Troubleshooting，回车后选择Rescue a CentOS...连续回车到输出提示，输入1继续，
然后chroot /mnt/sysimage进入初试系统，使用passwd改密码。Ctrl+D退出Rescue模式，reboot重启。

	远程登录
	linux系统通过sshd服务提供远程登录功能，默认使用22号端口，通常安装完系统就默认安装并开启了该服务，所以不需要进行额外
的配置。sshd服务的配置文件是：/etc/ssh/sshd_config
	修改sshd配置文件不允许root远程登录：
		PermitRootLogin no
	查看登录用户：who -a
	重启sshd服务：systemctl restart sshd.system
	查看sshd进程：ps -ef|grep sshd
	centos默认使用openssh-clients作为远程登录客户端，使用ssh -V查看软件版本，安装该工具：yum install -y openssh-clients
	openssh-clients登陆远程主机：ssh root@192.168.1.103
	生产ssh密钥对：
		ssh-keygen -t rsa -C "zhangwei@win1"
	将生成的公玥文件 id_rsa.pub 发送给远程linux主机，远程linux将该公玥文件追加到 ~/.ssh/authorized_keys文件中，本地主机在
~/.ssh/config文件中配置：
		Host c1
			User root
			HostName 192.168.56.2
			IdentityFile "~\.ssh\id_rsa"
	即可使用 ssh root直接登录远程Linux主机。

	修改主机名：hostname asuser 永久修改：vi /etc/hostname
	永久修改主机名命令：
		hostnamectl set-hostname c1
	
	
	基础命令

		# -d通常和-l一起使用，写出-ld。-d用于查看参数目录的信息而不是参数目录的下级内容的信息
		ls -ld /tmp		
		
		# 不加参数会直接进入用户主目录
		cd /home
	
		# -p用于逐级创建目录，如果目录已存在也不会报错，也不会做其他事情
		mkdir -p /tmp/test/01
	
		# 只能删除空目录 -p可以从里到外逐级删除空目录
		rmdir /tmp/test
	
		# -r递归删除 -f取消提示
		# 警惕误操作 rm -rf /
		rm -rf /tmp/test

		# 查找某个命令的绝对路径
		which rmdir
	
		# 查看环境变量
			echo $PATH

		# 移动文件或目录
			mv /tmp/test/test.txt /root/
	
		# 复制文件 -r用于复制目录 CentOS中cp实际是cp -i
		cp aaa bbb 

		# 通过重定向写文件
		echo 'abc' > aaa 将'aaa'重定向写入aaa文件

		# 显示文件内容和行号
		cat test.txt -n
		
		# 显示所有内容，包括特殊字符（-A 会将中文作为特殊字符处理，即不能正确识别中文），在每行结束处显示"$"，将跳格字符显示为^I
		cat -A test.txt 
	
		# 倒序显示文件内容
		tac test.txt 
	
		# more和less用于分页查看文件
		# 使用ctrl+D(B)回翻到上一页，空格键到下一页
		# less中使用j和k进入下一行和上一行，可以使用/和?进行搜索，n跳转到下一个匹配项，/用于向下搜索，?用于向上搜索。
		more test.txt
		less test.txt
	
		# 默认显示前10行，-n 20 显示前20行，也可以写 head -20 test.txt
		head test.txt 
	
		# 默认查看文件末尾10行，-n 20显示最后20行，-f 动态查看最后10行
		tail test.txt
	
		# 列出目录下的子目录和文件
		ls  /
		# -l 显示详细信息，-a 显示所有文件和子目录，
		# -l 输出的第一列第一位表示文件的类型：
				d	目录	
				-	普通文件
				l	链接文件
				b 	块设备文件
				c	串行端口设备文件
				s	套接字文件
		# -l 输出的第三列是节点数

		# 查找命令文件
			which vi
		# 查找[二进制/源码/帮助]文件 在索引库中执行模糊查找
			whereis [-b/-s/-m] file 
		# 类似于whereis，可以使用updatedb更新索引库，但是这个命令可能会需要一段时间
			locate file
		# 查找文件
			find /path [options]
			# 查找10天以内进行过 “写入数据/访问文件/修改文件内容、属性”的文件 
			find /path -mtime[-atime/-ctime] -10
			find /path -name fileName
			find /path -name "test*"
			# 按类型查询和名称查找
			find . -type d -name solr

		# 查询文件的mtime、ctime、atime
			stat filename

		# 查看支持的文件系统
			cat /etc/filesystems
			# centos7默认使用xfs文件系统，centos6使用的文件系统是ext4
	

	目录/文件权限
		目录/文件的权限分为：读、写、执行；数字表示：r--4, w--2, x--1, -:0
		目录/文件权限的三个维度：所属人、所属组、其他人
		目录的默认权限是755(rwxr-xr-x)，文件的默认权限是644(rw-r--r--)
			# 改变目录权限 -r 用于目录权限的递归修改
			chmod 750 dir1
			chmod u=rwx,go=rx dir2
			chmod u-x,g+w dir3
		文件的默认权限是根据umask值来设置的：普通文件权限使用666按位减去umask值，目录权限使用777减去umask值
		每个用户都有自己的umask值，root用户默认umask值为022，普通用户为002，所以root创建的普通文件权限是 644，而目录为 755
			#  返回用户的umask值
			umask
			# 修改umask
			umask 002

	为目录/文件添加其他属性
		# 添加i属性后，文件不能删除、重命名、设定链接、写入和新增数据
		chattr +i dir4	
		# 添加a属性后，文件只能追加不能删除，只有root才能设置这个属性
		chattr +a dir5  
		# 列出目录下所有文件和递归子目录的特殊属性
		lsattr -aR dir6 
	
			
	修改文件所属组
		chgrp testgroup test.txt 
	修改目录和子目录所属组
		chgrp -R testgroup /tmp 
	修改文件所有者和所属组 -R 同时修改目录和子目录
		chown testuser[:testgroup] test.txt 
	
	特殊权限
		setuid（标识为s） 是二进制可执行文件上的一种附加权限，可以让执行人在文件执行时具有文件所有者的权限
		setgid(标识为g) 和 setuid 一样，用于让执行人在文件执行时具有文件所属组的权限
		sticky bit（标识t） 相当于防删除位，目录设置此权限后，对这个目录有写权限的用户不能删除其它用户的文件（除了root和文件所属人）
		查看/etc/passwd和/usr/bin/passwd的权限
			ls -l /etc/passwd /usr/bin/passwd
			# /etc/passwd的权限：	 rw-r--r--
			# /usr/bin/passwd的权限：rwsr-xr-x
			# 执行/usr/bin/passwd时需要修改/etc/passwd，虽然普通用户没有该文件的写权限，但是由于/usr/bin/passwd设置了setuid权限，
			# 所以普通用户在执行/usr/bin/passwd时，会获得/usr/bin/passwd所属用户root的权限，所以可以写入/etc/passwd	
		查看/tmp的权限
			ls -ld /tmp
			# /tmp的权限： 		rwxrwxrwt 
			# /tmp具有sticky bit权限

	
	现代linux支持最多可使用255个字符作为文件名
	软链接和硬链接：
		ln -s orifile soft-link 
		ln orifile hard-link
		# 删除原文件后软链接将不能打开。
		# 硬链接是复制了一个新的原文件的inode节点，这样删除原文件就不会实际删除文件，而只是删除了原文件名指向的inode节点，这时使用硬链接仍然可以访问原文件。
	查看系统内核版本：
		uname -r
	

	用户管理

	查看/etc/passwd文件：
		cat /etc/passwd | head
	文件格式：
		root:x:0:0:root:/root:/bin/bash
	/etc/passwd文件中每一行被:分隔为7个字段：第一个是用户名，可以是大小写字母、数字(不能再首位)、减号、点号和下划线
第二个字段是密码，现在不真正保存在这里，所以使用x占位，第三个字段是uid，root是0，自建的用户通常从1000开始；第四个字段
是gid，第五个字段是用户信息说明，第六个字段是用户的家目录；第七个字段是用户的shell，如果是/sbin/nologin表示这个用户
不能登陆。
	查看所有用户名：
		cut -d':' -f 1 /etc/passwd

	查看/etc/shadow文件：
		cat /etc/shadow | head -n 3
	文件格式：
		root:$6$xEeBczsD$U486aOPTUqBNei7PmpQVm9RqKIvy6XN3Rfr4F52sm1XP1WE6.T5HFdlmsLfyv6ltGZwvapet0rPlHzlF2uvhV.:17883:0:99999:7:::
	/etc/shadow文件每条记录被:分隔为9个字段：第一个是用户名，第二个是加密后的密码，第三个是上一次修改密码的日期(距离
1970年1月1日的天数，考虑闰年)，第四个字段表示要过多少天才能修改密码，默认为0，第五个是密码多少天后到期，第六个是密码
到期前发出警告的天数，第七个是失效日期，即到期未修改密码过后多少天锁定账号，第八个字段是账号有效日期，即从1970年开始
有效的天数，过了时间账号就被锁定，第九个是保留使用，没有意义
	为了安全，/etc/shadow文件权限通常被设置为000，只有root能修改查看

	用户组文件：/etc/group
	用户组分为主要组和附加组，主要组是用户文件 /etc/passwd 中用户关联的组，附加组则不在 /etc/passwd 中体现
	在 /etc/group 中，只包括一个组作为附加组时所关联的用户，而不包括作为主要组所关联的用户
	查看所有用户组名：
		cut -d':' -f 1 /etc/group
	新增用户组：
		groupadd [-g gid] groupName 
		查看：
			tail -n3 /etc/group
	删除用户组：
		groupdel groupName 不能删除具有用户的用户组，必须先删除用户
	查看用户组信息：
		getent group groupName

	新增用户：
		# -d表示自定义家目录，
		# -M表示不创建家目录(/etc/passwd文件中会有家目录名，但是这个目录实际没有创建)，
		# -s表示自定义shell
		useradd [-u uid] [-g gid] [-d homeDir] [-M] [-s shellDir] userName
	新增用户不指定用户组时默认会创建一个和用户同名的用户组，并把该用户加入该用户组。
	查看用户所属group：
		groups userName
	删除用户：
		userdel userName
	查看用户信息：
		id userName
	更改密码：更改自己的秘密直接使用passwd，root用户可以使用 passwd userName修改指定用户的秘密
	使用mkpasswd生成密码：
		先安装expect ： 
			yum install -y expect 
		然后直接使用mkpasswd生成9位随机密码
			# -l 12 指定长度
			mkpasswd -l 12
	更改/etc/passwd记录的第五个字段-用户说明：
		chfn shanyu
	根据关键词过滤查询：
		grep 'shanyu' /etc/passwd
	
	将现有的用户添加到附加组:
		usermod -G groupName userName
		#将一个用户同时添加到多个附加组
		usermod -G groupName1,groupName2 userName
	更改用户的主要组：
		usermod -g groupName userName
	
	切换用户：
		# [-]表示初始化用户环境变量
		su [-] userName
	root切换普通用户不需要密码，使用exit返回原用户
	普通用户使用su切换到root是需要root密码的，但是这不太安全，所以出现了sudo
	sudo配置文件：
		/etc/sudoers
	默认只有root能使用sudo
	使用visudo 编辑/etc/sudoers文件（先安装 yum install -y sudo）:
		# 允许shanyu用户在所有主机上以所有用户身份使用sudo执行所有命令
		shanyu  ALL=(ALL)  ALL 
	使用sudo：
		# 使用sudo需要输入自己的秘密
		sudo cat /etc/shadow 
	当用户以"sudo passwd"或者"sudo passwd root"方式运行命令的时候，可以直接把root用户的密码改掉，这是非常危险的，
必须要把这两条命令禁止调，在命令前面加上"!"来表示不可执行的命令：
	为用户组shanyu配置sudo：
		%shanyu  ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
	/etc/sudoers中配置用户别名：
		User_Alias USER_AUTH = shanyu,zhangwei
	/etc/sudoers中配置命令别名：
		Cmnd_Alias SU = /usr/bin/su
	/etc/sudoers中配置不需要密码切换用户：
		USER_AUTH ALL=(ALL) NOPASSWD:SU
	这样shanyu用户就可以使用 sudo su - root 直接切换到root，而不用输入密码
	
	

	磁盘管理
	df 不加参数查看挂载的磁盘和目录情况，大小单位为KB。其中/和/boot是安装系统时划分的分区。/dev和/dev/shm是内存分区，
保存在这两个分区的文件相当于保存在内存中，关机会丢失。/run等都是临时文件系统。
	df -i 查看inode节点使用情况，一个文件系统中可以保存的inode节点数是限定的，如果用完了，即使磁盘还有空间也不能继续
保存文件了。
	df -h 自动选择合适的单位显示文件系统大小
	df -k 以KB为单位，和不使用-k结果是一样的
	df -m 以MB为单位
	df -i | grep -v tmpfs 过滤掉包含字符串tmpfs的行
	du /home/zhangwei/test_dir 不加参数查看目录和子目录所占空间大小。-a 用于列出目录和子目录下的文件；-b指定单位为B，
-k指定单位为KB，-m指定单位为MB，-h自动使用合适单位。注意，使用-k,-h和不加参数，占用空间大小不足4KB会显示为4KB，
-m也会把不足1MB的大小显示为1MB. -c用于计算占用空间总和； -s用于只显示占用空间总和
	使用 du -sh /home/zhangwei/test_dir以合适单位显示指定目录占用空间总和
	fdisk -l 列出所有设备和分区表
	fdisk -l /dev/sdb 列出指定设备和分区表
	fdisk /dev/sdb 对/dev/sdb进行分区划分：
命令： m 显示命令说明；
	   p 打印分区情况；
	   n 建立新的分区；
	   w 保存；
	   q 退出；
	   d 删除分区；
	   建立分区时可以选择主分区(p)和扩展分区(e),一块磁盘最大只能划分4个主分区，设置分区结束扇区可以使用+1000M这种方法
	设置扇区大小。建立扩展分区后，再建立分区只能选择主分区和逻辑分区(l)，如果磁盘空间已经分完了，就不能再选主分区了，只能在扩展分区
	里面划分逻辑分区。逻辑分区的id总是从5开始。
	mke2fs 可以格式化分区为ext2、ext3和ext4格式，实际上还有mkfs.ext2、mkfs.ext3、mkfs.ext4命令。
参数：-b n*1024 设置数据块的大小，只能是1024的倍数，通常不能大于4096，单位是B
	  -t ext4 设置文件系统类型
	  -L LABEL 设置label
	  -i 设置inode节点的大小
	  -N 设置inode节点的数量
	  -c 格式化前检查磁盘
	  -j 设置类型为ext3，相当于使用mkfs.ext3
	格式化分区为xfs类型需要使用 mkfs.xfs 命令；mkfs.xfs 设置块大小参数：-b size=2048 
	mke2fs 可以直接重新格式化已经格式化的分区，mkfs.xfs重新格式化则需要加 -f
		mke2fs -t ext4 -b 2048 -L TEST-5 /dev/sdb5
		mkfs.xfs -b size=2048 -L TEST-6 /dev/sdb6
	e2label /dev/sdb5 查看extn格式分区标签
		e2label /dev/sdb5
	格式化后的磁盘分区被看成是一个块设备文件，使用前需要先挂载到某个目录下，挂载目录一般是空目录，如果挂载目录原来有
文件，挂载分区后就不能在看到目录下原来的文件了
	mount 不加参数可以查看所有挂载的分区信息
	mount /dev/sdb5 /newdir/ 挂载/dev/sdb5分区到/newdir/目录
	卸载：umount /newdir/
	使用LABEL挂载：mount LABEL=TEST-5 /newdir/
	/etc/fstab文件：
	cat /etc/fstab
		UUID=9d6efa31-598f-4326-b819-706d907fbaa6	/boot	xfs  defaults   0   0
	一共6列，第一列可以是挂载分区名、UUID、LABEL；第二列是挂载点，第三列是文件系统类型；第四列是挂载分区的一些特性，
第五列0表示不备份，1表示备份；第六列表示是否开机自检磁盘，0不自检，1自检优先级高于2
	第四列常用选项：async/sync 非实时同步/实时同步数据到磁盘；auto/noauto 开机自动/不自动挂载；ro/rw 只读/可读写挂载；
exec/noexec 允许/不允许可执行文件操作，不能把根分区挂载为noexec；user/nouser 允许/不允许非root用户挂载(卸载)；
defaults 包含rw、exec、auto、nouser、async
	通过/etc/fstab文件挂载：
	新增一行：
		LABEL=TEST-5 /newdir/ ext4 defaults 0 0
	使用 mount -a 挂载所有/etc/fstab文件中的分区
	使用mount 挂载分区可以使用 -t 指定分区格式类型，但是通常是可以自动识别的，并不需要这样指定，使用-o可以设置/ect/fstab
文件中第四列的挂载分区特性
	重新挂载： mount -o remount /newdir/  这里-o没有写具体值应该是使用defaults
	blkid 查看所有挂载过的分区的UUID；也可以使用：blkid /dev/sdb5
	使用UUID挂载：mount UUID="9d6efa31-598f-4326-b819-706d907fbaa6" /newdir/
	/etc/fstab文件中配置的分区会在系统启动后挂载，另一种让系统启动后挂载分区的方法是在/etc/rc.d/rc.local文件中写入
挂载命令：/usr/bin/mount UUID="xxxx" /newdir/ (这里mount最好使用完整路径)
	如果当前在挂载目录内，可以使用umount -l /newdir/来卸载
	虚拟内存不够，可以增加一个虚拟磁盘：先建立swapfile，然后格式化为swap格式，然后启用虚拟磁盘
	dd if=/dev/zero of=/tmp/newdisk bs=1M count=1024
	if指定源文件(UNIX系统/dev/zero文件可以提供0)，of指定目标文件，bs指定块大小，count指定块数量，目标文件大小=bs*count
	mkswap -f /tmp/newdisk 格式化为swap格式
	swapon /tmp/newdisk 启用虚拟磁盘
	free -m 使用MB为单位查看内存使用情况。
	partprobe命令用于重读分区表，当出现删除文件后，出现仍然占用空间。可以partprobe在不重启的情况下重读分区。
	
	使用Vim
	Vim是Vi的升级版，日常使用几乎没有什么差别。安装Vim：yum install -y vim-enhanced
	Vim有三种模式：一般模式、编辑模式和命令模式。
	使用vim filename进入一般模式，在这个模式下可以移动光标、删除字符和行、复制粘贴。
		h或<- 光标左移一个字符
		l或-> 光标右移一个字符
		j或下方向键 光标下移一行
		k或上方向键 光标上移一行
		(上面几个命令还可以在前面加一个数字n，表示移动n个字符)
		Ctrl+F 下翻一页
		Ctrl+B 上翻一页
		0或shift+6 光标移到行首
		shift+4 光标移到行尾
		gg 光标移动到首行
		G 光标移动刀尾行
		nG 光标移动到第n行
		x 向后删除一个字符
		X 向前删除一个字符
		nx 向后删除n个字符
		dd 删除/剪切光标所在行
		ndd 删除/剪切光标所在行开始的n行
		yy 复制光标所在行
		p 在光标所在行下方粘贴已复制或剪切的内容
		P 在光标所在行上方粘贴已复制或剪切的内容
		nyy 复制光标所在行开始的n行
		u 还原上一步操作
		v 按v后移动光标选中指定字符，然后可以使用y粘贴选中的内容，使用d剪切，x删除选中的内容
	进入编辑模式的几个命令：
		i 在当前字符前插入
		I 在当前行行首插入
		a 在当前字符后插入
		A 在当前行行尾插入
		o 在当前行下面新增一个空行输入
		O 在当前行上面新增一个空行输入
	命令模式：
		/word 在光标之后查找word，按n转到下一个匹配项
		?word 在光标之前查找word，按n转到上一个匹配项
		:n1,n2s/word1/word2/g 在n1行和n2行间替换word1为word2，不加g表示只替换每一行的第一个匹配项
		:1,$s/word1/word2/g 将文档中所有的word1替换为word2，不加g表示只替换每一行的第一个匹配项
		:q			退出
		:w			保存修改
		:wq			保存退出
		:w!			强制保存，root用户可以强制写入不允许写的文件(只要文件有写权限，root就可以直接保存，如果
所有用户都没有写权限，root可以使用w!强制写入)
		:q!			强制退出，不保存修改
		:set nu		显示行号
		:set nonu	不显示行号
	修改tab键缩进字符：
		vi /etc/vimrc
		新增一行：
			set ts=2
	以十六进制编辑二进制文件：
	打开文件：
		vim -b filename
	命令模式下输入进入十六进制模式：
		:%!xxd
	保存后返回正常模式：
		:%!xxd -r
	查看文件编码：
		:set fileencoding
	转换编码：
		:set fileencoding=utf8
	查看文档格式
		:set fileformat
	转换格式：
		:set fileformat=unix
	

	压缩和打包
	gzip压缩工具：gizp [-d#] filename -d用于解压，-#用于设置压缩级别，1最差，9最好，默认为6
	gzip压缩完成后会删除原文件，gzip不支持压缩目录，如果压缩的是文本文件，可以使用 zcat filename.gz查看内容
	bzip2压缩工具：bzip2 [-zd#] filename -z用于压缩，写不写都一样，-d用于解压，-#设置压缩级别，也是1~9，默认为9
	bzip2压缩完成后会删除原文件，bzip2不支持压缩目录，如果压缩的是文本文件，可以使用 bzcat filename.bz2查看内容
	xz压缩工具：xz [-dz] filename 
	xz也不能压缩目录，使用xzcat filename.xz 查看压缩文本文件的内容
	tar 打包工具：
		tar [-zjJxcvfpP] filename tarname 
		-z表示打包后使用gzip压缩
		-j表示打包后使用bzip2压缩
		-J表示打包后使用xz压缩
		-x表示解包或解压缩
		-t表示查看tar包里的文件列表
		-c表示建立一个tar包
		-v表示可视化
		-f 后跟文件名，表示打包后的包名(压缩包名)，解包则是要解包的包名。多个参数需要把f写到最后面
		-p表示为tar包添加原文件的属性
		-p表示可以使用绝对路径、
		--exclude filename表示打包时不包括指定文件
		-C dirname 解包时指定解包到指定目录
		--strip-components=1 解包时指定不保留包名作为目录
	打包文件：tar -cvf filename.tar filename
	查看tar包中的文件列表：tar -tf filename.tar
	安装tree工具：yum install tree
	使用tree查看目录内容：tree dirname
	使用tar打包文件或目录都不会删除原文件或目录，同样解包也不会删除tar包文件
	打包同时使用gzip压缩：tar -czvf dirname.tar.gz dirname/
	虽然对tar包进行了gzip压缩，还是可以使用tar -tf dirname.tar.gz查看文件列表
	排除指定文件并使用bzip2压缩：tar -cjvf test_tar.tar.bz2 test_tar/ --exclude first.c
	解压和解包：tar -xjvf test_dir.tar.bz2
	mm.tar.xz解包：先使用xz解压缩，xz -d mm.tar.xz 再使用tar解包：tar xvf mm.tar
	zip压缩包可以在windows和linux中通用，而且可以压缩目录
		zip filename.zip filename
	压缩目录：zip dirname.zip dirname/* 这种方式只会压缩目录下的文件和子目录本身，子目录下的文件不会被包含
使用-r压缩目录下的所有文件：zip dirname.zip dirname/
	解压缩：unzip filename.zip 
	zip压缩和解压缩都不会删除原文件。
	解压缩到指定目录：unzip -d tmpdir dirname.zip 
	查看zip压缩包内容：unzip -l dirname.zip
	检测是否损坏：unzip -t dirname.zip 
	解压缩后覆盖已有文件：unzip -o dirname.zip -d tempdir
	解压缩后不覆盖已有文件： unzip -n -d tempdir dirname.zip
	touch test.txt
	echo "hello" > !$		//!$表示上一个命令的参数
	xz压缩包需要先解压缩 xz -d xxx.xz 后才能解包：tar xvf xxx.tar
	
	安装RPM包
	RPM包是预先在Linux上编译并打包的文件，安装起来非常快捷
	软件为什么需要安装：安装的目的是把执行程序放到执行路径下来，把配置文件放到程序可读位置，把需要的链接库放到可
找到的位置，以及配置一些需要预先配置的参数等。如果一个程序不需要这些准备就可以执行，就不需要安装了。
	挂载安装linux的光盘：mount /dev/cdrom /mnt/cdrom		#如果没有/mnt/cdrom目录，将会报错，直接创建这个目录就可以
	#卸载挂载的光盘：umount -v /mnt/cdrom
	查看安装光盘里的rpm包：ls /mnt/cdrom/Packages | head
	rpm包：	abrt-2.1.11-48.el7.centos.x86_64.rpm
			包名 版本号  发布版本号	  运行平台
	安装：rpm -ivh libjpeg-turbo-devel-1.2.90-5.el7.x86_64.rpm
		  -i 表示安装 -v表示可视化 -h表示显示进度
	升级：rpm -Uvh filename.rpm
	卸载：rpm -e name 这里的name只是安装的包名，而非rpm文件名，可以使用rpm -qa name查询
	查询是否已安装指定包：rpm -q name
	查询系统已安装的所有rpm包： rpm -qa | head
	查询已安装包的详细信息：rpm -qi name
	列出rpm包安装后的所有文件：rpm -ql name
	查询某个文件属于哪个rpm包：rpm -qf filename
    查看系统自带的jdk：rpm -qa | grep java
    强制卸载已安装的jdk rpm包：rpm -e --nodeps java-1.8.0-openjdk-1.8.0.131-11.b12.el7.x86_64
	使用rpm安装需要自己处理依赖问题，也就是说需要自己先手动安装依赖包，才能安装当前包。
	
	yum工具可以联网下载需要的rpm包，同时会自动解决依赖包的安装
	列出所有的rpm包资源：yum list | head
	搜索rpm包：yum search vim 也可以使用：yum list | grep 'vim'
	使用安装yum安装：yum install -y vim-enhanced		//不加-y表示以与用户交互的方式安装
	卸载：yum remove name（卸载时最好不使用-y，防止卸载了某些依赖的重要的包）
	升级：yum update name 
	使用光盘作为yum源：
	先挂载光盘：mount /dev/cdroom /mnt/cdrom
	删除/etc/yum.repos.d目录下的文件：cp -r /etc/yum.repos.d /etc/yum.repos.bak
		rm -rf /etc/yum.repos.d/*
	在/etc/yum.repos.d创建新文件：dvd.repo:  vim /etc/yum.repos.d/dvd.repo
		[dvd]
		name=install dvd
		baseurl=file:///mnt/cdrom
		enabled=1
		gpgcheck=0
	刷新repos生成缓存(缓存软件源中有哪些软件等信息，如果使用了fastestmirror插件，也会缓存各个软件源镜像地址列表中访问最快的镜像地址)：
		yum makecache
	然后就可以使用yum安装了：yum install -y tftp
	恢复yum源：rm -rf /etc/yum.repos.d
		mv /etc/yum.repos.bak /etc/yum.repos.d
		yum list
	使用yum下载rpm包而不安装：
		yum install rpmname -y --downloadonly --downloadonlydir=/usr/local/src/
		如果已经安装该rpm包，可以使用：
		yum reinstall rpmname -y downloadonly --downloadonlydir=/usr/local/src/
	编译源码安装：
		获取源码 wget http://archive.apache.org/dist/apr/apr-util-1.5.1.tar.gz
		解压：tar -zxvf apr-util-1.5.1.tar.gz
		进入解压后的目录：cd apr-util-1.5.1
		执行： ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr/
		执行：make
		执行：make install
	yum-config-manager: command not found
	这个是因为系统默认没有安装这个命令，这个命令在yum-utils 包里，可以通过命令yum -y install yum-utils 安装就可以了。
	
	查找提供命令的安装包：
		yum whatprovides */lspci

	centos默认使用的软件库提供的软件通常都是经过充分测试的版本，因此版本比较旧，scl软件仓库则较新的软件版本。
	安装scl仓库：
		yum install -y centos-release-scl
	安装scl工具：
		yum install -u scl
	查看base库中的gcc版本：
		yum --disablerepo=\* --enablerepo=base info gcc
	查看scl库中gcc 8.x的最新版本：
		yum --disablerepo=\* --enablerepo=centos-sclo-rh info devtoolset-8-gcc.x86_64
	安装devtoolset-8，其中包含gcc等一系列软件：
		yum install devtoolset-8
	也可以直接安装gcc 8.x，scl允许安装多个不同版本的软件，这里安装devtoolset-9-gcc.x86_64
		yum install devtoolset-9-gcc.x86_64
	scl库的软件不会被安装到/usr/bin等路径，所以不能直接使用，需要使用 scl enable命令进入新的shell环境：
		scl enable devtoolset-8 bash
	如果要把新版本的gcc加入默认的shell环境中，可以新增文件：/etc/profle.d/gcc.sh
		#!/bin/bash
		source /opt/rh/devtoolset-8/enable
	
	kill 命令
	执行一个 kill 命令，实际上是发送一个信号给系统，让系统去终结指定的应用。使用 kill -l 可以查看可以使用的信号，常用的
有 SIGTERM(15) 和 SIGKILL(9)。
	SIGTERM 信号请求一个进程停止运行。这个信号是默认的信号（可以省略）。发送这个信号后，进程将进行进度保存和释放资源，这
通常需要一段时间，然后正常关闭，所以它不是强制停止。
	SIGKILL 信号强制进程立刻停止运行，未保存的进度将会丢失。
	语法： kill [信号或选项] PID(s)
	可以使用信号名称，也可以使用信号量：
		kill SIGKILL 12345
		或
		kill -9 12345
	可以在同一时间kill多个进程：
		kill -9 12345 8023
	kill -0 pid 不发送任何信号，但是系统会进行错误检查,如果进程存在就返回1，否则返回0
	pkill 命令使用进程名执行 kill ，它使用扩展的正则表达式和其它匹配方式匹配进程名称然后执行 kill，为了避免 kill 掉错误的
进程，通常应该先执行 pgrep -l [进程名] 来确认匹配进程的名称。
		pgrep -l nginx
		pkill nginx
	killall同样使用进程名执行 kill ，并且它会kill掉所有的同名进程：
		killall firefox
	
	ps 命令
	ps 命令能够显示出当前进程列表的快照：
		ps [选项](这里的选项可以使用三种风格：UNIX风格：选项前加 - ；BSD风格：选项前不加 - ；GNU风格：选项前加 -- ，通常只选择一种风格使用)
	选项包括：
		a 显示所有用户的进程
		u 显示进程的用户和拥有者
		x 显示不依附于终端的进程
		f 输出完整格式化格式
		e 显示所有进程信息
		u 指定用户
		-C 指定进程名
		...
	可以使用管道将 ps 命令的输出传递给 grep 命令，然后输出匹配的样式：
		ps -aux | grep chrome

	bash启动需要从两个维度来描述：是否为交互式启动和是否登录。
	查看当前bash进程是否为交互式模式：
		#返回字符串包含 字符i 则为交互式启动，否则为非交互式启动 
		echo $-
		#返回非空则为交互式启动，否则为非交互式启动
		echo $PS1
	查看当前bash进程是否登录：
		#显示为off，则为非登录，显示为 on 则为已登录
		shopt login_shell
	启动bash的几种模式：
		交互式登录启动：从终端或ssh等正常登录，使用bash --login，使用su - user
		交互式非登录启动：执行bash，执行su user，从图像用户界面打开终端
		非交互式非登录启动：执行shell脚本，使用ssh远程执行命令
		非交互式登录启动：执行shell脚本带有--login选项

	/etc/profile、/etc/bashrc、~/.bash_profile、~/.bashrc文件
	/etc/profile是一个全局配置文件，系统中每个用户在他们第一次登陆系统时，这个文件都会被读取执行，这个文件会读取 /etc/profile.d/
下的配置文件为每个用户配置他们的shell。
	/etc/bashrc也是一个全局配置文件，每个用户每次进入 bash shell，这个文件就被执行，用于配置用户的bash shell。
	~/.bash_profile是各个用户自己的配置文件，这个文件保存专用于自己使用的shell信息，当用户登录时，这个文件被读取执行一次。
	~/.bashrc是用户的 bash shell配置文件，该文件包含专用于用户自己的bash shell的bash信息，用户登录时和每次打开新的bash shell时，
该文件被读取执行。
	修改bashrc文件出现错误导致ls等不可用时，可以使用export PATH=/usr/bin:/usr/sbin:/bin:/sbin先临时修改PATH使ls等可用。

	bash登录启动时，首先读取/etc/profile文件，在这个文件中，会读取 /etc/profile.d/下的配置文件，如果当前为非交互式启动，则输出将被重定向
到/dev/null。然后继续按顺序搜索~/.bash_profile、~/.bash_login、~/.profile，找到其中一个就不再继续搜索。~/.bash_profile中
会去读取~/.bashrc文件，~/.bashrc文件又会读取/etc/bashrc文件，/etc/bashrc文件又会读取/etc/profile.d/下的配置文件，非交互式模式下将输出
重定向到/dev/null。所以只要登录，不管是否为交互式启动，都会读取/etc/profile、/etc/profile.d/*、~/.bash_profile、/etc/bashrc设置环境。
	bash交互式非登录启动时，不读取/etc/profile、~/.bash_profile、~/.bash_login、~/.profile这些文件，仅读取~/.bashrc文件。
	非交互式非登录启动时，以上文件都不会被读取，而是读取环境变量 BASH_ENV 的值表示的文件来设置环境。
	在ContOS7中，使用ssh远程执行命令，即使用非登录非交互式启动shell，会读取~/.bashrc文件，而环境变量 BASH_ENV的值为空。
	在alpine中通过apk安装的5.0.17(1)-release版本的bash，使用ssh远程执行命令，即使用非登录非交互式启动shell，不会读取~/.bashrc文件，需要
设置环境变量 BASH_ENV的值为~/.bashrc ：
		修改sshd配置文件:/etc/ssh/sshd_config：
			PermitUserEnvironment yes
		然后在~/.ssh/下新增文件environment：
			BASH_ENV=~/.bashrc
		如此即可使用ssh执行远程命令。
	
	export 命令
	export 命令用于设置或显示环境变量。export 的效力仅限于该次登陆操作。
	语法：
		export [-fnp][变量名称]=[变量设置值]
		-f 　代表[变量名称]中为函数名称。
		-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
		-p 　列出所有的shell赋予程序的环境变量。
	示例：
		# 列出当前的环境变量值
		export -p
		#或者
		env
		# 自定义环境变量
		export MYENV
		# 赋值
		export MYENV=7
	在~/.bashrc、/etc/bashrc、/etc/profile.d/*.sh中的变量不需要export，因为进入新的shell环境总是会执行这些文件，/etc/profile、~/.bash_profile
中的变量最好是使用export导出，这样可以让登录后进入新的shell环境时仍然可以使用这些变量。
	

	使用防火墙firewalld
	启动：
		systemctl start firewalld 或 systemctl start firewalld.service
	停止：
		systemctl stop firewalld 或 systemctl stop firewalld.service
	查看防火墙状态：
		systemctl status firewalld	或 firewall-cmd --state
	重启：
		systemctl restart firewalld 或 systemctl restart firewalld.service
	设置开机启动：
		systemctl enable firewalld 或 systemctl enable firewalld.service
	禁用开机启动：
		systemctl disable firewalld.service 或 systemctl disable firewalld.service
	查看版本：
		firewall-cmd --version
	查看使用说明：
		firewall-cmd --help
	开放80端口：
		firewall-cmd --zone=public --add-port=80/tcp --permanent 
	firewalld简介：
	firewalld配置文件以xml格式为主（主配置文件firewalld.conf例外），他们有两个存储位置：/etc/firewalld/ 和 /usr/lib/firewalld/
	当需要一个文件时firewalld会首先到 /etc/firewalld/ 去查找，如果可以找到，那么就直接使用，否则会继续到第 /usr/lib/firewalld/ 查找。
	/usr/lib/firewalld/ 存放的是firewalld提供的通用配置文件，如果需要修改配置，最好的做法是copy一份到/etc/firewalld/ ，然后再进行修改。
这样可以保证原始配置始终没有被修改过，相当于进行了备份，有利于以后恢复默认配置。
	目录/usr/lib/firewalld/下只包含三个目录：zones、services、icmptypes，目录/etc/firewalld/下则还有两个配置文件：firewalld.conf、
lockdown-whitelist.xml。
	firewalld.conf 是 firewalld的主配置文件，是键值对的格式，内部DefaultZone表示默认使用的zone，默认为public（一个zone就是一个规则集）。
	zones目录保存zone配置文件，services目录保存service配置文件，icmptypes目录保存和icmp类型相关的配置文件。
	firewalld默认提供了九个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、home.xml、internal.xml、public.xml、trusted.xml、
work.xml，即9个规则集。public.xml内容入下：
		<?xml version="1.0" encoding="utf-8"?>
			<zone>
			<short>Public</short>
			<description>
				For use in public areas. You do not trust the other computers on networks to not harm your computer. 
				Only selected incoming connections are accepted.
			</description>
			<service name="ssh"/>
			<service name="dhcpv6-client"/>
		</zone>
	可以看出zone中引用了service，一个service表示一个firewalld中配置的服务，它是在service目录配置的，/usr/lib/firewalld/service/目录下提供了
很多配置文件，包括了常用的各种服务，如果需要修改，可以复制相应的文件到/etc/firewalld/service/下修改，如果需要新增服务，也可以添加一个service文件。

	nohup命令
	nohup命令用于不挂断(no hang up)地运行命令，即退出账号登录和终端（terminal）后程序能一直执行。
	用法：
		nohup Command [ Arg ... ] [　& ]
	实例：
		nohup redis-server --port 6379 --bind 127.0.0.1 --dbfilename master.rdb > master.out &
	最后面的 & 表示后台运行。
	> master.out 表示将输出重定向到master.out 文件中。
	操作系统中有三个常用的流：
	　　0：标准输入流 stdin
	　　1：标准输出流 stdout
	　　2：标准错误流 stderr
　　上面的 > master.out，实际是 1 > master.out的省略用法；< input.txt ，实际是 0 < input.txt的省略用法。
	如果要将错误输出也保存到标准输出中，可以这样写：>master.out 2>&1

	下载netcat源码：
		wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz
	查看开放端口： 
		nc -z -v -n 127.0.0.1 21-25
	-z表示使用0 IO，即连接后就关闭连接，不进行数据交换。
	-v表示输出详细信息
	-n表示不使用DNS反向查询IP的域名。
	查看使用指定开放端口的服务的banner信息（只有部分服务会提供banner信息）
		nc -v 127.0.0.1 22
	安装iptables防火墙:
		yum install iptables-services
	iptables配置文件路径：
		/etc/sysconfig/iptables
	启用iptables服务（需要先停止在用的firewalld服务）：
		systemctl restart iptables.service

	升级Linux内核：
		1、导入key
			rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
		2、安装yum源，使用elrepo源
			rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm
		   查看当前可以升级到的内核版本：
		    yum --disablerepo="*" --enablerepo="elrepo-kernel" list available
		3、安装内核
			yum --enablerepo=elrepo-kernel install kernel-ml-devel.x86_64 kernel-ml.x86_64 -y
		4、更改内核默认启动顺序
			grub2-set-default 0
		5、重启
			reboot
		6、查看
			uname -r
    查看内核列表：
        cat /boot/grub2/grub.cfg |grep menuentry
    查看其他内核：
        rpm -q kernel
    查看当前启动时默认内核：
        #grub2-editenv list
		awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfg
    修改启动时默认内核：
        grub2-set-default "CentOS Linux (5.4.3-1.el7.elrepo.x86_64) 7 (Core)"
    删除旧的内核（如果不删除，旧内核会继续占用/boot空间）：
        yum remove kernel-3.10.0-327.el7.x86_64
    查看/boot空间占用情况
        df -h
	查看centos发布版本：
		 cat /etc/redhat-release
	
	tee命令：
		tee [OPTION]... [FILE]...
		选项：
			-a, --append               追加到文件中而不是覆盖。
	用于从标准输入读取数据并重定向到标准输出和文件：
		tee -a ./file1 << -EOF
		hello
		-EOF
	
	debian系使用APT工具集管理软件包，常用的工具包括apt-get、apt-cache等。
	Ubuntu1604开始可以使用apt命令部分代替原来的apt-get使用。
	配置国内源：
		检查更新（更新仓库缓存信息）：
			apt-get update
		安装ca-certificates（需要在http下安装，默认官方仓库就是http）
			apt-get install ca-certificates
		切换清华的源：
			cd /etc/apt
			mv sources.list sources.list.bak
			tee sources.list << -EOF
			deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
			...
			-EOF
    
    使用cat创建文件：
        #使用b作为结束
        cat > test.txt <<b
    
	exec命令
        用于调用并执行指令的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，
        则当指定的命令执行完毕后会立即退出终端。	
        语法：exec(选项)(参数)
        选项：-c：在空环境中执行指定的命令。

	查看端口占用：
		lsof -i:3306
		或者
		netstat -tunlp | grep 3306
    
    sed
    sed是一个流式编辑器，它逐行处理文件。sed运行时使用一个称为模式空间的缓冲区来保存读入的文件行，然后对该缓冲区的行数据进行
处理，处理完成后便将处理后的数据输出到屏幕，然后再读取文件的下一行到缓冲区，如此循环处理文件的每一行直至结束。
    用法：
        sed [OPTION]... {script-only-if-no-other-script} [input-file]...
    OPTION的值：
        -i ：直接修改读取的文件内容，而不是输出到终端
        -n ：使用安静(silent)模式。sed正常输出时会将来自 STDIN 的数据所有行输出到终端上。使用 -n 后，只有经过sed 处理的那些行才会被输出。
        -e ：多点编辑
    {script...}：
        a ：新增行，例(显示/etc/passwd，在其第二行后添加一行文本)：nl /etc/passwd | sed '2a hello sed'
        i ：插入行，例(显示/etc/passwd，在其第二行前添加一行文本)：nl /etc/passwd | sed '2i hello sed'
            新增或插入多行，可以使用 \ ：
                nl /etc/passwd | sed '2i hello sed \
                another line'
        s ：替换行内内容，通常搭配正则表达式使用。用法：sed 's/要被取代的字串/新的字串/g' g表示替换所有匹配字符串
        c ：替换行，例(显示/etc/passwd，替换其第2~5行为一行文本)：nl /etc/passwd | sed '2,5c hello sed'
        d ：删除行，例(显示/etc/passwd，排除其2~5行)：nl /etc/passwd | sed '2,5d' 
        p ：打印行，通常和参数 sed -n 一起使用，例(显示/etc/passwd 文件的第 5-7 行)：nl /etc/passwd | sed -n '5,7p'
        q ：退出。 
    使用正则表达式搜索：
        # 搜索并输出所有含有root关键词的行
        nl /etc/passwd | sed -n '/root/p'
        # 删除/etc/passwd所有包含root的行，输出其他行
        nl /etc/passwd | sed '/root/d'
    搜寻并执行命令：
        # 首先查找包含keyword的行，然后对找到的行执行cmd1和cmd2
        sed '/keyword/{cmd1;cmd2}'
        # 查找包含root的行，并将行内的bash替换为blueshell并输出：
        nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p}'
        # 查找包含root的行，将找到的第一行中的bash替换为blueshell并输出
        nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p;q}'
        # 显示ens33的ip地址：
        ifconfig ens33 | grep 'inet ' | sed 's/^.*inet //g' | sed 's/netmask.*$//g'
    多点编辑：
        # 删除/etc/passwd第三行到末尾的数据，并把剩下行内的bash替换为blueshell
        nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'
    直接修改源文件（这是一个危险操作，不要用它去编辑系统配置文件）
        # 将以 . 结尾的行末尾的 . 替换为 !
        sed -i 's/\.$/\!/g' file1
        # 在文件末尾追加一行文本：
        sed -i '$a a new line' file1
        # 在每个单词前添加一个#：
        sed -i 's/\</#/g' file1
        # 在每个单词后添加一个#：
        sed -i 's/\>/#/g' file1
        # 替换行内第二个?为!：
        sed 's/\?/\!/2' file1
		# 替换windows换行符为linux换行符
		sed -i 's/\r$'

    awk(参考：【酷 壳】[AWK 简明教程] https://coolshell.cn/articles/9070.html)
    awk是一个文本处理工具，支持使用脚本文件来编写文本处理逻辑
    用法：
        # 使用脚本文件progfile处理目标文件file
        awk [POSIX or GNU style options] -f progfile [--] file ...
        # 使用命令行命令处理目标文件file
        awk [POSIX or GNU style options] [--] 'program' file ...
    内建变量:
        $0	    当前处理的行
        $1~$n	当前行的第n个字段，字段间由FS分隔
        FS	    输入行内字段的分隔符，默认是空格和Tab
        NF	    当前行中的字段个数，即有多少列
        NR	    已经读出的记录数，即行号，从1开始，如果有多个文件话，后续文件的NR值是在前一文件的NR基础上增长。
        FNR	    每个文件内的正在处理的行号
        OFS	    输出字段分隔符，默认是空格
        RS	    输入的记录分隔符， 默认为换行符
        ORS	    输出的记录分隔符，默认为换行符
        FILENAME	当前输入文件的名字
    示例：
        # 显示netstat.txt的第1列和第4列，输出列间使用制表符间隔
        awk '{print $1,$4}' OFS='\t' netstat.txt
        # 显示netstat.txt的第1列和第4列，输出列间使用制表符间隔，不显示列名：
        awk 'NR!=1 {print $1,$4}' OFS='\t' netstat.txt
        # 格式化输出
        awk '{printf "%02s %-8s %-18s\n",NR,$1,$4}' netstat.txt
        
        # 过滤行
        awk '$6=="ESTABLISHED" || NR==1 {print $1,$4,$5,$6}' netstat.txt
        awk '$4 ~ /6379/ || NR==1 {printf "%-4s %-8s %-18s %-18s %-12s\n",NR,$1,$4,$5,$6}' netstat.txt
        awk '$4 !~ /6379/ || NR==1 {printf "%-4s %-8s %-18s %-18s %-12s\n",NR,$1,$4,$5,$6}' netstat.txt
        awk '/LISTEN/' netstat.txt
        awk '/LISTEN|ESTABLISHED/' netstat.txt
        awk '!/LISTEN/' netstat.txt

        # 指定文件的列分隔符
        awk 'BEGIN {FS=":"} {print $1,$3,$6}' passwd
        # 等价于：awk -F: '{print $1,$3,$6}' passwd
        # 指定多个分隔符：awk -F '[;:]'
        
        # 折分文件
        # 根据列类容拆分(这里会将第6列内容相同的行写到同一个文件，文件名就是第6列的内容文本)
        awk 'NR!=1 {print > $6}' netstat.txt
        # 根据列类容拆分，只输出指定列
        awk 'NR!=1{print $4,$5 > $6}' netstat.txt
        # 统计目录大小
        ls -al | awk '{sum+=$5} END {print sum}'
        # 统计不同状态的连接数量
        awk 'NR!=1 {a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt
        统计每个用户的进程的占了多少内存
        ps aux | awk 'NR!=1 {a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'
    awk脚本：
        #!/bin/awk -f
        #运行前
        BEGIN {
            math = 0
            english = 0
            computer = 0

            printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
            printf "---------------------------------------------\n"
        }
        #运行中
        {
            math+=$3
            english+=$4
            computer+=$5
            printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
        }
        #运行后
        END {
            printf "---------------------------------------------\n"
            printf "  TOTAL:%10d %8d %8d \n", math, english, computer
            printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
        }
    执行： ./cal.awk score.txt 或 awk -f cal.awk score.txt

    在awk中使用环境变量需要使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export：
        x=5
        y=10
        export y
        echo $x $y
        awk -v val=$x '{print $1,$2,$3,$4+val,$5+ENVIRON["y"]}' OFS='\t' score.txt

	使用awk获取当前目录下最新修改的文件的文件名：
		# 第一行是文件数
		# 如果最新修改的是 . 和 ..，可以调整为 NR==3 或 NR==4
		ls -alt | awk 'NR==2 {print $0}'

	安装ntpdate
		yum install ntpdate
	同步时间
		ntpdate cn.pool.ntp.org


	获取系统时间：
		date
	获取系统时间戳（不计入闰秒，即跳过闰秒，现在都是减去闰秒）：
		date +%s

	使用 scp 传输文件/目录：
		scp [option] [option] ... source target
	option 说明：
		[-1246BCpqrv]
			-1： 强制scp命令使用协议ssh1
			-2： 强制scp命令使用协议ssh2
			-4： 强制scp命令只使用IPv4寻址
			-6： 强制scp命令只使用IPv6寻址
			-B： 使用批处理模式（传输过程中不询问传输口令或短语）
			-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
			-p： 保留原文件的修改时间，访问时间和访问权限。
			-q： 不显示传输进度条。
			-r： 递归复制整个目录。
			-v： 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
		[-c cipher]
			以cipher将数据传输进行加密，这个选项将直接传递给ssh。
		[-F ssh_config] 
			指定一个替代的ssh配置文件，此参数直接传递给ssh。
		[-i identity_file]
			从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
		[-l limit]
			限定用户所能使用的带宽，以Kbit/s为单位。
		[-o ssh_option]
			使用ssh_config(5)中的参数传递方式
		[-P port]
			指定数据传输用到的端口号
		[-S program]
			指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项
	上传文件：
		#上传后使用新的文件名
		scp -p file1 root@192.168.56.2:~/tmp/file2
		#只指定目录，文件名不变
		scp file1 root@192.168.56.2:~/tmp/
		#不指定用户名，执行后输入用户名
		scp file1 192.168.56.2:~/tmp/
		#使用ssh_config中的配置
		scp c1:~/tmp/
	上传目录：
		scp -r dir1 c1:~/tmp/
	下载文件：
		scp c1:~/file2 ./
	下载目录：
		scp -r c1:~/dir2 ./

	开机时输出的信息会被内核保存在 /var/log/ 下的 dmesg 文件中，使用 dmesg 命令也可以查看这些信息。
	使用 dmesg | grep -i virtual 可查看当前Linux系统是运行在虚拟机上还是物理机上，在此命令输出中，如果有 Booting paravirtualized kernel on KVM，则表示运行环境位KVM，如果是
Booting paravirtualized kernel on bare hardware，则表示运行在物理机上。
	
	使用openssl自签CA证书并使用自签证书签发次级证书
	1.生成CA密钥(pkcs1标准)
		openssl genrsa -out caroot.key 2048
	2.生成CA证书请求文件
		openssl req -new -key caroot.key -out caroot.csr
		#查看证书请求文件
		openssl req -in caroot.csr -noout -text
	3.自签CA证书
		openssl x509 -req -extensions v3_ca -signkey caroot.key -in caroot.csr -out caroot.crt
	4.生成客户密钥
		openssl genrsa -out sps1.key 2048
	5.生成客户证书请求文件
		openssl req -new -key sps1.key -out sps1.csr
	6.使用CA证书签发客户证书
		#签发次级证书需要读openssl.cnf文件，Centos7中位于/etc/pki/tls/目录下，默认配置中openssl需要使用/etc/pki/CA/index.txt 、/etc/pki/CA/serial文件和/etc/pki/CA/newcerts目录
		#如果不存在这几个文件和目录就创建
		# touch /etc/pki/CA/index.txt
		# echo '01' > /etc/pki/CA/serial
		# mkdir /etc/pki/CA/newcerts
		#签发证书需要知道客户的身份，可以在openssl.cnf文件中配置，这里把这个文件复制到/root/ssl目录下，并把/etc/pki/CA复制到/root/ssl目录下
		#修改/root/ssl/openssl.cnf：
			#openssl.cnf
			#修改dir
			dir = /root/ssl/CA
			#在 [ v3_req ]下增加
			subjectAltName = @alt_names
			#增加[alt_names]
			[alt_names]
			DNS.1 = localhost
		使用/root/ssl/openssl.cnf签发证书：
			openssl x509 -req -days 365 -in sps1.csr -CAkey caroot.key -CA caroot.crt -CAcreateserial -out sps1.crt -extensions v3_req -extfile openssl.cnf
		也可以使用单独的文件：
			#dnsext.cnf
			authorityKeyIdentifier=keyid,issuer
			basicConstraints=CA:FALSE
			keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
			subjectAltName = @alt_names
			[alt_names]
			DNS.1 = zhangwei.org
		签发：
			openssl x509 -req -days 365 -in sps1.csr -CAkey caroot.key -CA caroot.crt -CAcreateserial -out sps1.crt -extfile dnsext.cnf
			#也可以使用openssl ca 签发
			openssl ca -policy policy_anything -days 365 -cert caroot.crt -keyfile caroot.key -in sps2.csr -out sps2.crt -extfile dnsext.cnf
	7.查看证书
		openssl x509 -in sps1.crt -noout -text
		指定格式：openssl x509 -in iciba.cer -inform der -text -noout

	openssl的其他用法：
		加密文件：
			openssl enc -e -des3 -a -salt -in D:\zhangwei.txt -out D:\zhangwei100.txt
		解密文件：
			openssl enc -d -des3 -a -salt -in D:\zhangwei100.txt 
		计算文件的哈希值：
			openssl dgst -md5 D:\zhangwei.txt
			openssl dgst -sha256 D:\zhangwei.txt


	locate命令是mlocate提供的命令，作用和find -name相同，但是它是通过检索索引库文件而不是搜索目录查找，所以效率更高。
	安装mlocate:
		yum install -y mlocate
	手动更新索引库(默认为/var/lib/mlocate/mlocate.db，每天自动更新)：
		updatedb
	查询文件位置：
		locate openssl.cnf
	
	alpine linux
		网络配置：vi /etc/network/interface
			#本地环回网卡
			auto lo
			iface lo inet loopback

			#NAT网卡
			auto eth0
			iface eth0 inet dhcp
					hostname a1

			#HostOnly网卡
			auto eth1
			iface eth1 inet static
					address 192.168.56.3
					netmask 255.255.255.0
					gateway 192.168.56.1
			#从路由表中删除eth1作为默认网关，因为这个网卡不能访问外网
			up route del default eth1
		重启网络
			ip addr flush eth0
			ip addr flush eth1
			/etc/init.d/networking restart
		关机
			poweroff
		安装glic:(JDK依赖glibc)
			wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub
			wget -O /usr/local/download/glibc-2.32-r0.apk https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.32-r0/glibc-2.32-r0.apk
			apk add glibc-2.32-r0.apk
	alpine使用apk作为包管理工具。
	apk使用：
		apk --help
		apk info --help
		apk list --help
	
	alpine使用OpenRC管理服务：
		apk info openrc
		apk add openrc
		rc-service --help
		rc-service --list
		#开机启动sshd服务
		rc-update add sshd
		#启动sshd
		rc-service sshd start/stop/restart
		#也可以使用
		/etc/init.d/sshd restart
		#查询服务状态
		rc-status
	
	alpine使用busybox来提供常用的命令，如cat、ps等，其中的ps命令输出超出一定长度后会被截断。


	重定向：
		cmd > a	等同于 cmd 1> a1		表示将标准输出重定向到文件a
		cmd 2> b 						表示将标准错误重定向到文件b
		cmd > a 2>&1					表示将标准错误重定向到标准输出，标准输出重定向到文件a
		eg：echo aa > a
			cat -h 2> b
			cat -h > b 2>&1
	
	正则表达式：
		标准元字符：
			^	行首
			$	行尾
			.	任意字符
			[a]		字符a
			[a|b]	字符a或字符b
			[0-9]	0-9中的任意数字
			*		数量限定，任意多个前置匹配
			{n,}	数量限定，至少n个前置匹配，需转义使用：\{1,\}
			\1		第一个匹配组
		posix方括号字符集：
			[:space:]	空白字符
		示例：
			grep "^[[:space:]]\{1,\}" test.txt
	
	syslog
	syslog日志系统用于记录系统中发生的各类事件，虽然被标准化为一种标准协议，但是由于历史实现各异，导致这个标准不是特别严格。syslog报文并没有对最小
长度有所定义，只要求报文的总长度必须在1024字节之内。
	syslog报文由三部分组成：PRI、HEADER、MSG。
	PRI是报文的第一部分，使用<x>表示日志的优先级，这个优先级根据产生日志的源（Facility）和日志级别（Severity）计算得到，计算规则为：
		PRI = Facility << 3 + Severity
	Facility取值范围为为0-23，标准没有规定每个编码代表的具体源，主流操作系统同一使用 0 用于内核日志，2 用于邮件系统日志， 1，16-23则留给用户程序
使用，其他编码则在不同实现中表示不同的日志源。
	Severity只有0-7共8个级别。0为最高级，表示系统不可用，7为最低级，表示debug日志。
	HEADER部分包括两个字段，时间和主机名（或IP）。时间紧跟在PRI后面，中间没有空格，格式必须是“Mmm dd hh:mm:ss”，不包括年份。“日”的数字如果是1～9，
前面会补一个空格（也就是月份后面有两个空格），而“小时”、“分”、“秒”则在前面补“0”。月份取值包括：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
时间后边跟一个空格，然后是主机名或者IP地址，主机名不得包括域名部分.
	MSG部分又分为两个部分，TAG和Content。其中TAG部分是可选的。TAG后面用一个冒号隔开Content部分，这不是标准要求的，由实现程序自定义。
	
	rsyslog配置文件：/etc/rsyslog.conf
	发送日志给远程日志服务器：
		*.* @@remote-host:514
		# 这里@@表示TCP传输，@表示使用UDP传输
	重启rsyslog服务：
		systemctl restart rsyslog
	手动记录日志
		logger -t mytag 'hello'
		#产生的日志
		<13>Jan 15 15:03:20 c1 mytag: hello
	
	发送消息给指定终端登录的指定用户：
		write root pts/1
		#使用 Ctrl+D 退出
	发送消息给所有终端登录的指定用户：
		write root
	发送消息给所有终端的所有登录用户：
		wall 'message'

	使用grep递归查询：
		grep -r JAVA_HOME /etc/*

	虚拟磁盘：
	使用dd根据/dev/zero创建一个空文件vda：
		dd if=/dev/zero of=vda bs=1M count=128
	把创建的空文件vda连接到循环设备/dev/loop0（完成后文件被当作块设备）：
		losetup /dev/loop0 vda
	对该循环设备进行分区：
		#使用parted查看分区信息
		parted /dev/loop0 print
		#使用fdisk进行MBR分区
		fdisk /dev/loop0
		#或使用gdisk进行GPT分区
		gdisk /dev/loop0
		#这里将/dev/loop0使用gdisk做成两个GPT分区
	断开/dev/loop0和vda文件的连接
		losetup -d /dev/loop0
	使用kpartx将vda文件和其内的两个分区连接到/dev/loop0、/dev/mapper/loop0p1、/dev/mapper/loop0p2
		kpartx -av vda
		#/dev/mapper/loop0p1对应第一个分区，类型为标准主分区
		#/dev/mapper/loop0p2对应第二个分区，类型为LVM分区
	将/dev/mapper/loop0p1格式化为xfs
		mkfs.xfs -b size=2048 -f /dev/mapper/loop0p1
	挂载/dev/mapper/loop0p1到 /mnt/test
		mount /dev/mapper/loop0p1 /mnt/test/
	将/dev/mapper/loop0p2做为一个物理卷
		pvcreate /dev/mapper/loop0p2
	创建卷组
		#有多个物理卷时，可以通过列出所有物理卷把它们都加入到卷组中
		vgcreate vg1 /dev/mapper/loop0p2
	创建逻辑卷lv1、lv2
		lvcreate -n lv1 -L 12M vg1
		lvcreate -n lv2 -L 12M vg1
	格式化lv1
		mkfs.ext4 -b 2048 /dev/vg1/lv1
	挂载lv到/mnt/lv/
		mount /dev/vg1/lv1 /mnt/lv
	查看所有块设备：
		lsblk
		输出：
			NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
			sda               8:0    0   50G  0 disk
			├─sda1            8:1    0  247M  0 part /boot
			└─sda2            8:2    0 49.8G  0 part
				├─centos-root 253:0    0 38.5G  0 lvm  /
				├─centos-swap 253:1    0  3.8G  0 lvm  [SWAP]
				└─centos-var  253:2    0  7.5G  0 lvm  /var
			sr0              11:0    1 1024M  0 rom
			loop0             7:0    0  128M  0 loop
			├─loop0p1       253:3    0   32M  0 part /mnt/test
			└─loop0p2       253:4    0   94M  0 part
				├─vg1-lv1     253:5    0   12M  0 lvm  /mnt/lv
				└─vg1-lv2     253:6    0   12M  0 lvm
	查看挂载的文件系统
		df -hT
		输出：
			文件系统                类型      容量  已用  可用 已用% 挂载点
			devtmpfs                devtmpfs  2.0G     0  2.0G    0% /dev
			tmpfs                   tmpfs     2.0G     0  2.0G    0% /dev/shm
			tmpfs                   tmpfs     2.0G  8.6M  2.0G    1% /run
			tmpfs                   tmpfs     2.0G     0  2.0G    0% /sys/fs/cgroup
			/dev/mapper/centos-root xfs        39G  3.7G   35G   10% /
			/dev/sda1               xfs       244M  161M   84M   66% /boot
			/dev/mapper/centos-var  xfs       7.5G  322M  7.2G    5% /var
			tmpfs                   tmpfs     396M     0  396M    0% /run/user/0
			/dev/mapper/loop0p1     xfs        30M  1.7M   28M    6% /mnt/test
			/dev/mapper/vg1-lv1     ext4      9.7M   42K  8.8M    1% /mnt/lv
	查看所有逻辑卷
		lvs/lvdisplay/lvscan
	卸载lv2
		umount /mnt/lv
	删除逻辑卷：
		lvremove vg1/lv2
	删除卷组
		vgremove vg1
	删除物理卷
		pvremove /dev/mapper/loop0p2
	卸载/dev/mapper/loop0p1
		umount /dev/mapper/loop0p1
	断开vda到/dev/loop0、/dev/mapper/loop0p1、/dev/mapper/loop0p2的连接
		kpartx -dv vda
	
	
	系统限制
		查看系统限制：
		ulimit -a
			# 当前用户的单个进程所能同时打开的文件数最大值，默认为1024
			open files (-n) 1024
			# 当前用户能同时运行的进程数的最大值，默认为5875
			max user processes (-u)
		修改当前用户的单个进程所能同时打开的文件数最大值：
			ulimit -n 65000
		修改当前用户能同时运行的进程数的最大值：
			ulimit -u 65000
	
	安装telnet
		1. 安装 telnet 需要先安装 xinetd 
			yum install xinetd
		2. 安装 telnet
			yum install telnet-server telnet
		3. 设置开机启动 xinetd
			systemctl enable xinetd
		4. 启动 xinetd
			systemctl start xinetd
		5. 启动 telnet-server
			systemctl start telnet.socket
	centos7中不要在 /etc/xinetd.d/ 下配置telnet文件，否则不能启动telnet
	注：xinetd已经被systemd取代，不建议再使用，同样，telnet也被ssh取代了，尽量不要再使用（telnet登录时没有加密用户名密码，不安全）

	环境变量 TERM
	终端是一类输入输出设备，linux支持的终端信息放在 /usr/share/terminfo下，终端映射文件为 /dev/tty*，/dev/tty代表当前终端，执行：
echo "hello" > /dev/tty 会把 hello 输出到当前终端。伪终端是逻辑终端设备，多用于模拟终端程序，如通过 ssh 登录linux。伪终端映射文件
为 /dev/pts/*
	如果linux不能识别终端/伪终端，则环境变量 TERM 被设置为 dumb，这可能会造成输入输出异常，可以在 .bash_profile等文件中设置 TERM 的
默认值，如果是通过是ssh登录，则可以在客户端设置环境变量 TERM，这个变量值将被设置为ssh终端的类型。

	查询进程启动文件的位置
	首先通过 ps 命令找到需要查找进程的进程ID：
		ps aux | grep hadoop
	然后使用 ls 查询进程ID对应的状态信息文件：
		ls -al /proc/25346
	这里列出的文件中：
		exe 链接到启动文件
		cwd 链接到执行进程的目录
		cmdline 文件里存储了启动进程执行的命令
		environ 记录了进程运行时的环境变量
		fd目录下是进程打开或使用的文件的符号连接
	
	修改命令提示符：
		命令提示符根据环境变量 PS1 设置，查看：echo $PS1，修改可以在/etc/profile中设置PS1变量：
			PS1=[\u@\h \W]\$
		\u 用户名
		\h 主机名
		\W 当前工作目录（只显示当前目录名）
		\w 当前工作目录完整路径
	
	启动sshd服务报错：sshd: no hostkeys available -- exiting
	执行以下命令处理报错：
		ssh-keygen -A
		/etc/init.d/ssh start
	
	查看内存、swap空间使用量：
		free -m
	临时关闭swap：
		swapoff -a 
	永久关闭swap
		sed -ri 's/.*swap.*/#&/' /etc/fstab
	安装了新的systemd管理的服务后，加载新的unit 配置文件 :
		systemctl daemon-reload
