										数据结构与算法
	第一章
	①变量：从机器的角度来看，变量其实就是一个内存地址；在数学或者程序上，变量是一个在运算过程中
确定值的代表量。
	②数据类型：对变量中存储数据的类型的说明。我们需要程序处理的数据天然的就分为几种类型，如数值和
文本等。编程语言使用数据类型来防止对变量进行错误的运算。现代编程语言通常会预定义一些基本数据类型，
同时允许开发者自定义复合数据类型。
	数据项：可以理解为简单对象的属性，比如一个人的体重，数据项通常不能再被细分。
	数据元素：可以理解为一个简单对象，它的属性就是数据项。（当然也可以是一个复杂对象，属性也是一个
数据元素）。
	数据对象：可以理解为一组类似的数据元素的集合。
	数据：在不同的语境下，数据指代不同的概念，可以是数据项，也可以是数据元素或数据对象。
	③数据结构：硬件上来说，数据结构是在机器中组织并存储数据的形式，如数组。数学上来说，数据结构则是
数据（间）逻辑关系的描述，可以以数学的方式表示，也可以用编程语言来描述。所以数据结构包括逻辑结构定义
和物理结构实现。编程语言实现的数据结构通常还包括一组接口，这些接口用于操作数据结构内部的数据。典型的
数据结构可分为线性结构和非线性结构。
	④抽象数据类型ADT：ADT不强调数据结构存储数据和接口的具体实现，而是强调接口功能的描述。
	⑤算法：实现某个目的(解决某个问题)的步骤或步骤的描述。
	⑥算法的比较和分析：解决同一个问题的算法可以有多个，不同的算法执行的效率不相同，描述算法的效率
的一种典型的方法是用函数表示算法执行的步骤数和输入量之间的关系：f(n)=...(算法效率函数)，通常被称为
算法的时间复杂度，使用T(n)=...表示。算法执行的步骤数除了和输入量有关，还和数据的分布有关。特定分布
状态的数据可能导致算法的执行步骤数出现极小值和极大值。也就是说在不清楚数据的分布的情况下，同一个算法
的执行效率具有三种形式：最坏情况、平均情况和最好情况。
	⑦增长率：输入量的增长引起的算法的执行步骤数增长的速度，例如在无序数组中找出某个元素使用从头遍
历算法，算法效率函数为f(n)=kn+c，增长率为n型(线性)增长。
	⑧渐进表示：在大多数场景下算法效率的最好和最坏情况都是不实用的，所以通常使用平均情况下的算法效
率函数。渐进表示描述的是在平均情况下算法效率函数的上界和下界。
	⑨大O表示法：如果存在正常数c和n0使得 n>=n0时，f(n)<=c*g(N)，则记为：f(N)=O(g(n))
	对于f(n)=O(g(n))，大O表示法给出了函数f(n)的严格上界，表示的是当n很大时，f(n)的上界是g(n)，实际
上描述的是简化了的算法的增长率(主增长率)。g(n)是f(n)的上界，c*g(n)增长率大于或等于f(n)的增长率，
所以g(n)有无数个，分析算法要求的则是最小的那个，通常这样的g(n)具有和f(n)相同的增长率。使用大O
表示法的目的是简化算法复杂性分析，只关注决定算法效率的最重要的那个部分，而不必陷入细节的过度分析。
当我们使用大O表示法来作为某个算法的效率函数时，比如假设我们得到某个算法的效率函数为：f(n)=O(n)，我们
就知道这个算法的增长率为线性增长。要得到算法效率函数的大O表示，只需要提取算法的主增长率就可以。
	Ω表示法：如果存在正整数c和n0，当n>=n0时，f(n)>=c*g(n0)，则记为：f(N)=Ω(g(n))，Ω表示法给出了f(N)
的下界，算法分析取所有g(n)中最大的那个，通常这样的g(n)也具有和f(n)相同的增长率。
	Θ表示法：存在c1、c2和n0，当n>=n0时，c1*g(n)<=f(n)<=c2*g(n)，则记为：f(n)=Θ(g(n))，这样的g(n)是
一个函数集合，每一个g(n)和f(n)的增长率都相同。
	复杂度分析：使用大O表示法分析算法效率，算法效率函数的大O表示法实际上是算法效率函数的简化，
其增长率大于或等于算法效率函数的(主)增长率，在几何上表现为算法效率函数的渐进线。所以求大O表示法也
叫做渐进分析。
	常见程序结构的算法效率：(给出精确的算法效率函数是很麻烦的，通常也是不必要的，所以使用大O表示法)
		循环：f(n)=c*n=O(n)
		嵌套循环：f(n)=c*n*n=O(n^2)
		顺序执行语句：f(n)=c0+k=O(1)
	分治法：分治法是将原问题分解为多个较小规模的子问题，子问题和原问题的本质是一样的，只是规模较小，
子问题又可以继续分解，通常分治算法的运行时间是子问题算法执行时间的和再加上一些额外的处理时间。
	分治法主定理：设计的分治算法中原问题和分解的子问题的执行时间满足条件：T(n)=aT(n/b)+Θ(n^k(logn)^p,
a>=1,b>1,k>=0,p为实数;
		1)如果a>b^k,则 T(n)=Θ(n^(log`ba));
		2)如果a=b^k, 
			a)如果p>-1,则T(n)=Θ(n^(log`ba)(logn)^(p+1));
			b)如果p=-1,则T(n)=Θ(n^(log`ba)(log(logn)));
			c)如果p<-1,则T(n)=Θ(n^(log`ba));
		3)如果a<b^k,
			a)如果p>=0,则T(n)=Θ(n^k(logn)p);
			b)如果p<0,则T(n)=Θ(n^k);
	递归求解主定理：如果某一问题的递归求解算法执行时间可以表示为：
		n<=1, T(n)=c, c为常数;
		n>1,  T(n)=aT(n-b)+f(n), a>0,b>0,f(n)=O(n^k);
		则可以直接得到:
		a)如果a<1,	T(n)=O(n^k);
		b)如果a=1,	T(n)=O(n^(k+1));
		c)如果a>1,	T(n)=O(n^ka^(n/b));
	平均情况分析和平摊分析：平均情况分析是假设一次输入的数据的分布不是最好，也不是最坏的分析；平摊分析
则是将一个序列的操作的开销平均分摊给每次操作，是对一系列操作的分析，当某次操作会影响后面的操作开销时，
平摊分析就非常有用了。

	第二章 递归过程
	递归是一种数学方法，它是这样一种函数，计算函数结果时，向函数自身传入一个比输入数据更小的量，使用返回
的结果参与计算，当然这个函数会有一个基准输入值，当输入量小于等于这个基准值，就直接可以得到一个结果而不需要
继续调用自身。
	递归的好处在于非常简单易懂，在现代高级程序语言中，递归实现通常会被编译为循环过程。
	阶乘的递归描述：
		int fact(int n){
			if(n==0 || n==1){
				return 1;
			}
			else{
				return n*fact(n-1);
			}
		}
	在程序领域，因为递归最终是被转换为循环来进行的，所以在高级语言层面，递归实现也一定可以改写为循环形式，
但是在程序中实现的循环和由编译器转换递归得到的循环是不一样的，递归总是会在每次递归调用时创建新的栈帧，所以
递归次数过多将有可能导致栈溢出。程序中的循环则没有这种风险，但是如果出现死循环会导致程序一直处在运行中。
递归本质就是循环加上压栈。
	通常某些场景下，使用递归可以清晰的说明问题的解，但是很难设计一个清晰的循环实现。
	汉诺塔问题的递归算法：
		void movePanOfHanoiTower(int n,char towerA,char towerB,char towerC){
			if(n==1){
				println("move pan from " + towerA + " to " + towerC);
			}
			else{
				movePanOfHanoiTower(n-1,towerA,towerC,towerB);
				println("move pan from " + towerA + " to " + towerC);
				movePanOfHanoiTower(n-1,towerB,towerA,towerC);
			}
		}
	判断数组是否有序的递归算法：
		int whetherRegular(int[] arr,int index){
			if(index==0){
				return 1;
			}
			else{
				return arr[index]<arr[index-1] ? 0 : whetherRegular(arr,index-1);
			}
		}
	回溯：回溯是一种利用分治法进行穷举搜索的方法，回溯和递归的区别在于，递归使用递归调用的结果参与调用层的运算，
回溯则是使用递归调用层的计算结果参与内层运算，这是因为回溯通常需要穷举所有可能的结果。
	生成n位2进制字符串的回溯算法：
		char[] A = new char[?];
		void productBynaryStr(int n){
			if(n==0){
				println(A);
			}
			else{
				A[n-1] = '0';
				productBynaryStr(n-1);
				A[n-1] = '1';
				productBynaryStr(n-1);
			}
		}
	这个算法的时间复杂度：T(n)=2T(n-1)+c ; 根据递归求解主定理，可以得到：T(n)=O(2^n);
	根据这个算法可以很容易地写出生成n位k进制字符串的算法。
	
	