										计算机组成和结构
											第一章
	计算机是信息技术产业的产物，信息技术是操作和应用各种信息的技术。计算机引发了人类第三次文明革命：信息革命。计算机不仅
直接方便了我们的生活，也改变了我们探索新知识的方式，其它学科使用计算机技术辅助它们的研究。
	各种不同类型的计算机使用了相同的硬件技术，不同的使用硬件技术的方式。简单的分类是按照用途将计算机划分为台式机、服务器
和嵌入式计算机。
	软硬件部件对程序性能影响的分析：
		算法 					   决定源程序级语句的数量以及执行I/O操作的数量
		程序设计语言和编译系统 		决定每一条源程序级的语句对应的机器指令
		I/O系统(硬件和操作系统)		决定I/O操作的执行速度
		处理器和存储器系统			决定指令的执行速度
	从应用软件到硬件是一种层次化组织的结构，计算机硬件(处理器)只能执行简单的指令，应用软件需要经过系统软件的翻译才能被
处理器执行。现在的系统软件主要是两类：操作系统和编译系统。
	操作系统是用户程序(应用程序)和硬件的接口，提供多种服务和管理功能，包括输入输出处理、内存和外存的分配管理、多个应用
程序同时执行的支持等。
	编译系统负责将高级语言编写的源程序翻译为机器指令。
	指令是计算机能识别理解的二进制位的集合，同时计算机也使用二进制位表示数据。
	汇编语言需要为每一条机器要执行的指令编写一条语句，这实际上是在强迫程序员按照机器的方式去思考。将高级语言程序翻译成
机器指令集合的可行性研究是计算机发展早期的最重要突破。
	计算机的五个经典组成部分：输入、输出、存储器(内存)、数据通路、控制器(数据通路和控制器合称为处理器)
	鼠标演进：机电式->光电式
	屏幕：早期使用光栅阴极射线管显示器，图片使用位图表示，每个像素可以只用一位二进制数表示黑白，也可以用八位表示不同的
灰度，彩色显示器可能为每一种原色使用8位，则一个像素使用24位表示。现代显示技术主要使用LED(液晶显示器)，通过活动矩阵为每
一个像素配置三个晶体管开关，调整液晶液体中棒状分子的形态，使得进入显示器的光弯曲产生不同颜色。
	计算机硬件使用光栅刷新缓冲区(帧缓冲区)保存位图。
	数据通路执行算术运算，控制器根据指令告诉数据通路、内存、输入输出执行什么操作。
	内存使用DRAM，动态随机存储器，高速缓存使用SRAM，静态随机存储器
	指令系统结构：也称系统结构，硬件和底层软件的抽象接口，包含了编写能够正常运行的机器语言程序的所有必需信息，包括：
指令、寄存器、存储器访问、I/O等。
	应用程序二进制接口(ABI)：指令集中用户指令部分和操作系统提供应用程序使用的接口。
	外部存储设备：磁盘、闪存、光盘等。
	
											第二章 指令系统
	机器语言可以类比于人类语言，一条汇编语句对应的机器语言语句就是基本句子，指令就是单词，指令集就是单词表。
	“从形式逻辑中可以推出，可以设计出一种简单的指令集（基础功能集）解决复杂的问题，而它要求的设备也具备原理上的简单性”。
	MIPS指令集：是一种精简指令集，有32位和64位版本，这里介绍32位。
add   a, b, c				指令操作数个数：3	//通常指令都要求指令操作数数量为3个，固定数量的操作数使得硬件复杂性可控
add   $t0, $s1, $s2		    算术运算指令操作数必须直接取自寄存器，这里MIPS提供32个寄存器，寄存器为32位，即字长为32位
lw    $t0, 4($s0)			数据传送指令 $t0目标寄存器 $s0基址寄存器 4偏移量（内存使用字节编址，机器字长为4，所以偏移量必是4的倍数）
sw    $t0, 4($s0)
addi  $s3, $s3, 4			立即数加，将常数放入指令使得执行更快

	MIPS寄存器：$s0~$s7 对应 16~23 号寄存器，$t0~$t7 对应 8~15 号寄存器 $zero 0号寄存器（存储0）
	MIPS指令格式：R型格式（寄存器型） 和 I型格式（立即数型）
R型：	op			rs			rt			rd			shamt			funct
	    6位		    5位			5位			5位			5位				6位
	  操作码   源寄存器1  	 源寄存器2	目标寄存器	   位移量		  函数码（和操作码配合使用）
	  
I型：	op			rs			rt			constant or address
		6位			5位			5位			     16位
	   操作码 	  源寄存器	目标寄存器		  常数或地址偏移量

	硬件设计四原则：
		1、简单源自规整
		2、越少越快
		3、加速执行常用操作
		4、适当折中
	算术运算指令：
		add $s1, $s2, $s3		释义：$s1 = $s2 + $s3			加
		sub $s1, $s2, $s3		释义：$s1 = $s2 - $s3			减
		addi $s1, $s2, 100		释义：$s1 = $s2 + 100			立即数加
	逻辑运算指令：
		and $s1, $s2, $s3		释义：$s1 = $s2 & $s3			与
		or $s1, $s2, $s3		释义：$s1 = $s2 | $s3			或
		nor $s1, $s2, $s3		释义：$s1 = ~($s2 | $s3)		非或($s3 为 0 时这条指令就是对$s2取反)
		andi $s1, $s2, 100		释义：$s1 = $s2 & 100			立即数与
		ori $s1, $s2, 100		释义：$s1 = $s2 | 100			立即数或
		sll $s1, $s2, 10		释义：$s1 = $s2<<10				左移(不考虑数的正负)
		srl $s1, $s2, 10		释义：$s1 = $s2>>10				右移(不考虑数的正负)
	数据传送：
		lw $s1, 100($s2)		释义：$s1 = Memory[$s2+100]		取数
		sw $s1, 100($s2)		释义：Memory[$s2+100] = $s1		存数
	条件转移指令：
		beq $s1, $s2, L			释义：if($s1==$s2) L			相等测试转移(L是一个内存地址直接量(标号))
		bne $s1, $s2, L			释义：if($s1!=$s2) L			不等测试转移(L是一个内存地址直接量(标号))
		slt $s1, $s2, $s3		释义：if($s2<$s3) $s1=1 else $s1=0	小于则置1
		slti $s1, $s2, 100		释义：if($s2<100) $s1=1 else $s1=0	立即数小于则置1
	无条件跳转：
		j L						释义：goto L					直接跳转到标号(L是一个内存地址直接量(标号))
	过程：根据给定的参数完成特定任务的已存储的子程序。
	跳转链接指令：跳转到某个地址，同时将下一条指令地址保存到寄存器中：jal ProcedureAddress
	MIPS为过程调用分配的寄存器：
		$a0 ~ $a3 参数寄存器（用于保存要传入的参数）
		$v0 ~ $v1 储值寄存器（用于保存过程返回值）
		$ra 返回地址寄存器（用于保存调用者下一条指令地址）
	程序计数器(PC)：保存当前运行指令的地址的寄存器。jal指令将PC+4保存到$ra寄存器中。
	寄存器跳转指令：非条件跳转到寄存器中指定的地址：jr $ra
	过程调用过程：调用者将参数保存到 $a0 ~ $a3，使用 jar X 跳转到过程X，过程X执行，将结果放到 $v0 ~ $v1,使用jr $ra
将控制返回到调用者。
	栈指针寄存器：$sp 保存被调用者可使用的栈的栈顶地址，栈的增长是按照从高到低的地址顺序。
	全局指针寄存器：$gp 用于保存静态数据
	MIPS将18个寄存器分成两组：
		$t0 ~ $t9 10个零时寄存器，过程调用中被调用者不需要保存其中原来的值
		$s0 ~ $s7 8个保留寄存器，过程调用中必须保存原来的值，使用完后必须恢复原状。
	叶过程：没有调用其它过程的过程。对于调用其它过程的非叶过程，调用其它过程前就需要把参数寄存器$a0~$a4、返回地址寄存器
$ra等进行压栈，调用结束后再从栈中恢复这些寄存器的值。
	过程的局部变量如数组等也需要保存到栈中，栈中包含过程的寄存器和局部变量的段称为过程帧或活动记录，MIPS使用帧指针寄存器
$fp存储栈中过程帧的开始地址，$sp指向栈顶，过程执行中$sp可能会改变，但$fp一般不会改变。
	程序内存分配（从低地址到高地址）：保留段-->正文段(初始阶段PC寄存器保存其地址)-->静态数据段(保存程序的静态数据、常量
等，$gp寄存器保存其地址)-->动态数据段(通常称为 堆，C中使用malloc分配其中空间使用)-->栈（从高地址向低地址增长，栈和堆
相向增长）
	上面所说的MIPS寄存器使用和内存分配其实是典型的编译器对寄存器和内存的划分使用，部分其它编译器可能不使用这种规则。
	1号寄存器称为$at，受汇编器保护，26号~27号寄存器称为	$k1~$k1，受操作系统保护
	字节读取、存储指令：
		lb $t0, 0($sp)			释义：$t0 = Memory[$sp+0] 读取单个字节（ASCII字符）	
		sb $t0, 0($sp)			释义：Memory[$s2+0] = $t0 存储单个字节（ASCII字符）
	双字节读取、存储指令：
		lh $t0, 0($sp)
		sh $t0, 0($sp)
	取立即数高位指令：
		lui $t0, 255			释义：使用立即数 255填充 $t0的两个高位字节
	读取一个32位常数到寄存器$s0中：0000 0000 0011 1101 0000 1001 0000 0000
		lui $s0, 61
		ori $s0, $s0, 2304
	J型指令格式：
		op			address	
		2(6位)		  26位
	MIPS寻址模式：指令机器码分为操作码和操作数两个部分，寻址模式指的就是操作数的获取方式。MIPS使用5中寻址模式：
		1、寄存器寻址，操作数就在寄存器中，如 add $s1, $s2, $s3
		2、基址寻址（或偏移寻址），操作数在内存中，其地址是指令中寄存器中地址和常数的和，如 lw $s0, 4($s1)
		3、立即数寻址，操作数是指令中的常数，如 addi $s0, $s1, 100
		4、PC相对寻址，操作数在内存中，其地址是PC寄存器中地址和指令中常数的和，如 bne $t0, $s5, Exit，这里Exit是一个常量，
			但是取得单位是字，所以和PC中地址相加前需要先乘以4变成字节
		5、伪直接寻址：将PC中的高位和指令中的26位常数相连，这里的26位常数也使用字作单位。如 j Loop
	从源程序文件到可执行文件的处理过程：
		源文件-->（编译器）-->汇编语言程序文件-->（汇编器）-->目标代码：机器语言模块-->链接器（加入机器语言形式的库程序）
-->可执行文件-->（加载器）-->将可执行文件放入合适的内存位置
		编译和汇编可以组合在一起，链接和加载也可以组合到一起以加快翻译过程。
	伪指令：硬件不提供实现，但是可以像使用普通指令一样使用该指令，实际上伪指令是通过汇编器转换成了等价的普通指令，例如
move $t0, $t1 指令并没有硬件实现，但是汇编器可以将其转换为：add $t0, $t1, $zero ,blt伪指令：blt $s1, $s2, L 表示小于则跳转会被汇编器转为
slt和bne，两条指令: slt $at, $s1, $s2 , bne $at, $zero L, ，同时需要使用$at寄存器，这也是$at寄存器被保留给汇编器使用的原因
	UNIX中目标文件通常包含6个不同部分：目标文件首部、正文段(指令)、静态数据段、重定位信息(标记依赖其它模块的指令、数据字)、
符号表(记录依赖的标记)、调试信息
	使用链接器的原因：拼接多个汇编后的目标文件可以在修改了某个模块后只编译那个模块。链接器将处理目标文件中对其它模块或库调用
的引用，生成的可执行文件中不再含有外部依赖。可执行文件中的地址其实是逻辑地址，执行时会被转换为内存中的绝对地址。
	动态链接库DLL：使用动态链接库的可执行文件不包含引用的库调用机器码，而是在调用该库调用时才链接加载库例程。
	
	现代优化编译器的结构：高层优化（语言优化器）-->局部/全局优化器（可能会关联寄存器和全局变量设置）-->代码产生器
	最常用的高层优化技术主要有过程内联，即使用函数体替换函数调用，其它高层优化技术包括循环变换（循环展开）、存储访问
优化技术等。
	常用的局部/全局优化技术包括：公用子表达式消除（如x[i] = x[i]+4 中的x[i]的求值指令可以被消除成只使用一条）、强度
削弱（将复杂的操作用简单指令替换，如mult指令可以用左移替换）、常数传播（查找常数并替换）、复制传播（类似于上面的公用
子表达式消除）、无用内存/代码写消除（查找不使用的内存、指令并消除）。
	C语言中的指针和数组：
		int *array1;		
		int array2[];
	array1 和 array2 都是数组的起始地址
	数组获取值：array2[i] 就可以直接取到对应位置的值
	数组指针取值：*(&array1[i])	先使用 &array1[i]获取对应位置元素的地址，再使用*取值
	
											第三章 运算逻辑
	计算机使用二进制表示数，这涉及到几个问题：1、怎么表示正数和负数，2、怎么表示整数和小数，3、机器支持的数的范围和
超出该范围的数怎么处理，4、运算的硬件基础
	现在几乎所有的计算机都使用补码表示法来存储整数，32位MIPS机器使用最高位（第31位）表示符号位，0为正数，1为负数。这样
32位的字长能表示的最大整数是：2^31-1，最小负数为-2^31
	符号扩展：将有符号数写入寄存器时，需要用符号位填充寄存器左侧多余的空位。
	带符号字节装入指令：lb	将要装入的字节看成有符号数
	无符号字节装入指令：lbu	C语言使用单个字节存储字符，所以使用lbu装入字符
	lh: 带符号半字装入	lhu: 无符号半字装入
	sltu: 小于无符号数则置1 	sltiu: 小于无符号立即数则置1
	加法和减法触发溢出的条件：
		两个正数相加结果为负数；
		两个负数相加结果为正数；
		正数减去负数结果为负数；
		负数减去整数结果为正数
	MIPS提供两种不同的运算指令来支持是否需要对运算中的溢出进行处理：
		add、addi、sub 在发生溢出时会产生异常（中断）；
		addu、addiu、subu 在发生溢出时不会产生异常（中断）
	C语言不会处理溢出，所以其加法最终使用的是addu等指令，而Fortran等语言会处理这类溢出，所以会使用add等指令。
	MIPS有一个异常程序计数器（EPC）寄存器，会在发生异常时记录发生异常的指令地址，使用 mfc0 指令可以复制该寄存器中的地址
到某个通用寄存器中，从而在处理异常后回到原来的位置继续执行
	MIPS提供$k0~$k1两个寄存器给操作系统使用，目的就是用作 mfc0 的目标寄存器
	串行乘法算法及硬件：
	使用64位被乘数寄存器，32位乘数寄存器，64位ALU和64位积寄存器，运算步骤：
			判断 乘数最右一位=0？ 是则走下一步，不是则将被乘数加到积寄存器，
			将乘数右移一位，将被乘数左移一位，
			判断移位次数是否小于32，是则循环此过程，否则结束
	这种算法实现一个32位乘法运算需要大约100个时钟周期
	另一种快速乘法硬件：
		使用32个加法器ALU，上一个加法器的输出作为下一个加法器的输入。
	IEEE754标准中的浮点表示法：
	MIPS使用IEEE754标准的浮点数格式存储浮点数，单精度浮点数使用32位：
	1/0		10...01		10....01
	31th 	23~30th		 0~22th
	 s			f			e	
	单精度浮点数使用127作为指数偏移量，计算：
	x = (-1)^s * (1.e) * 2^(f-127)
	双精度浮点数格式：
	1/0		10...01		10....01
	63th 	52~62th		 0~51th
	 s			f			e	
	双精度浮点数使用1023作为指数偏移量，
	x = (-1)^s * (1.e) * 2^(f-1023)
	MIPS机器提供单独的浮点寄存器（32位）：$f0~$f6
	MIPS浮点计算指令：
		单精度：
		add.s	$f2,$f4,$f6			$f2 = $f4+$f6
		sub.s	$f2,$f4,$f6			$f2 = $f4-$f6
		mul.s	$f2,$f4,$f6			$f2 = $f4*$f6
		div.s	$f2,$f4,$f6			$f2 = $f4/$f6
		双精度：
		add.d	$f2,$f4,$f6			$f2 = $f4+$f6
		....
		取一个字装入浮点寄存器：
		lwcl 	$f1,100($s1)
		从浮点寄存器保存值：
		swcl	$f1,100($s1)
		
										第四章 评估计算机性能
	性能的定义：对于单机用户，其所关心的主要是响应时间，即作业提交到完成的时间；对于数据中心而言，更关心的是机器的
吞吐率，即一定时间内完成的工作量。对于不同的机器甚至是不同的使用场景，应该使用不同的指标来考察机器的性能。
	主要考虑响应时间时，可以使用响应时间的倒数作为性能参数：性能x = 1 / 执行时间x
	性能测量：使用CPU执行时间来描述CPU花费在特定应用上的时间，这又可以分为用户程序CPU时间和系统CPU时间，使用系统性能
来表示系统CPU时间，使用CPU性能来表示用户程序CPU时间
	系统设计人员使用时钟周期来考察机器性能
	CPU执行时间 = 一个程序的CPU时钟周期数 x CPU时钟周期长度
	所以设计系统时可以通过缩短时钟周期或者减少程序所需要的时钟周期数来改善性能，但是通常这是互相矛盾的，减少时钟周期
数的技术通常会导致时钟周期变长。
	另一种计算方法：
	程序执行的CPU时钟周期数 = 程序的指令数 x 指令的平均时钟周期数
	每条指令的平均时钟周期数（CPI）可以用作评比使用相同指令集的不同实现的性能指标
	CPU时间 = 指令数 x CPI / 时钟频率
	两个影响CPI的主要因素是流水线性能和内存系统性能
	
										第五章 逻辑设计基础
	组合逻辑电路：不包含存储单元的逻辑电路。相同的输入总是得到相同的输出。
	时序逻辑电路：包含存储单元的逻辑电路。输出依赖于输入和当前逻辑电路存储单元里的内容。
	组合电路的输出值可以由输入值完全确定，可以使用真值表来描述这种确定的对应关系。
	真值表可以描述任何一种组合逻辑函数，但是真值表的大小随着输入值数量的增加呈指数级增长。
	布尔代数可以用来表示逻辑表达式，常用的三种操作符：+或操作符，.与操作符和-非操作符
	布尔代数具有一些基本的运算定律，如分配律等。
	门电路可以实现基本逻辑功能，三种基本门电路：与门、或门、非门
		 ______				______				|\
	 ---|	   \		 ---\     \			  --| \
		|	    |-----		 |	   |------	  --| /O--
	 ---|______/		 ---/_____/				|/
	 
	任何一个逻辑表达式都可以用与门、或门和非门的组合来表示。
	译码器：常用的译码器有n个输入位，2^n个输出位，输出位中只有一位是有效输出位。
	多路复用器（选择器）用于选择多个输入量中的一个作为输出量。具有n个输入量需要log2n个选择信号。多路
复用器使用译码器将log2n位选择信号解析为n位控制信号和n个输入量相与。
	二级逻辑表达：输入量之间进行与、或直接运算（可以对输入量进行取反后再进行运算），运算结果再进行与、
或、非运算得到结果。
	析取范式：对多个逻辑与的表达项求逻辑和。D=(A*B*`C)+(A*C`B)
	合取范式：对多个逻辑和的表达项求逻辑积。
	PLA：可编程逻辑阵列，是根据析取范式设计的一类结构化逻辑工具，具有二级中间逻辑结构，第一级是与门
阵列，第二级是或门阵列。
	ROM：只读存储器，ROM并不直接存储数据，它使用组合逻辑电路将输入的信号（地址）变换得到输出，这也是
ROM只能读取的原因。
	无关项：如果一部分输入已经确定了输出值，剩下的输入项就成了无关项，无关项可以用于优化逻辑设计。
	逻辑单元阵列：简单地重复逻辑单元就可以实现某些功能，例如32位输入选择器使用32个一位输入选择器来实现。
	
	硬件描述语言Verilog:
	Verilog和VHDL是两种主流的硬件描述语言，Verilog语言风格类似于C语言，它可以定义数字系统的行为功能和组成
结构。硬件合成工具可以根据Verilog程序描述生成逻辑电路设计图。
	Verilog的两种基本数据类型：
		wire：表示组合信号，比如一个输入；
		reg：表示一个变量（一个存储硬件，比如寄存器）。
	声明一个32位的存储硬件：reg[31:0] X; 声明一个32位的输入信号：wire[31:0] Y
	声明16个32位的存储硬件：reg[31:0] regs[0:15]
	常量的表示：4'b0100	表示4位的值为4的二进制常数
				-8'h4 表示值为-4的8位双补码常数
				|16|2'b01|| 表示创建32位的值，其模式是0101...01
				|A[31:16],B[15:0]| 表示创建32位的值，高16位是A的高16位，低16位是B的低16位
	Verilog提供类似C的运算符：+、-、*、/、&、|、~、==、!=、>、<、>>、<<、&A(对A的所有位进行&运算)
	Verilog程序由一组模块组成，模块可以表示一个简单的逻辑门电路，也可以是一个ALU逻辑单元，甚至是整个系统。
模块需要声明它的输入和输出，模块体包括：
		初始化语句，初始化reg变量；连续的赋值语句，仅用于定义组合逻辑；always指令；其它模块实例。
	一个半加器的Verilog描述：
		module half_adder (A,B,Sum,Carry);
			input A,B;
			output Sum,Carry;
			assign Sum=A^B; //异或
			assign Carry=A&B;
		endmodule
	
	1位ALU：
		进位输入(CarryIn)  操作数(0、1、2)
				  |			|
		a-->|-----------------|
			|	  &/|/+	      |--->和(Sum)
		b-->|_________________|
				  |
				进位输出(CarryOut)							   _ _______   _   _______   _ _
	布尔表达式：CarryOut=(b.CarryIn)+(a.CarryIn)+(a.b)	Sum=(a.b.CarryIn)+(a.b.CarryIn)+(a.b.CarryIn)+(a.b.CarryIn)
	将32个1位ALU串起来就可以得到一个32位行波进位加法器。
	为上面的1位ALU添加一个Binvert输入选择器对输入b取反，同时设置进位输入初试值为1就可以实现减法，这也是使用2进制补码
表示法的一个原因。
	实现或非：a或b后再取非		_____   _ _
		德.摩根定律：			(a+b) = a.b
		根据上面的德摩根定律，只需要再引入一个Ainvert选择器对a取反就可以实现或非操作了。
	实现小于置位(slt)指令：
		引入一个less输入，1~31位的ALU的less输入都为0，第0位的ALU的less输入第31位的ALU的运算结果的符号位，这样如果
a<b,a-b<0,slt输出就是1（a-b的结果符号位为1）
	因为第0位的进位输入只在做减法时需要设置为1，而Binvert也只在做减法时设置为1，所以这个两个输入可以合并为一个Binvert。
这样就可以使用一个4位的控制线来输入控制 |\信号：第0位和第1位是基础控制信号，第2位Binvert，第3位Ainvert
		0000	与						| \ALU操作数(控制信号)
		0001	或						|  \|
		0010	加						|   \
		0110	减				   a--->|ALU |
		0111	小于比较设置			 \	  |-->0
		1100	或非					  \  |
										  /  |-->结果									
										 /   |
								   b--->|    /-->溢出
										|   /
										|  /|
										| / |
	上面的32位MIPSALU的Verilog描述：	 |/ 进位输出
		module MIPSALU (ALUctl, A, B, ALUOut, Zero);
			input [3:0] ALUctl;
			input [31:0] A,B;
			output reg [31:0] ALUOut;
			output Zero;
			assign Zero=(ALUOut==0);
			always @(ALUctl, A, B) begin
				case (ALUctl)
					0: ALUOut <= A & B;
					1: ALUOut <= A | B;
					2: ALUOut <= A + B;
					6: ALUOut <= A - B;
					7: ALUOut <= A < B ? 1 : 0;
					12: ALUOut <= ~(A | B);
					default: ALUOut <= 0;
				endcase
			end
		endmodule
	产生上面的4位控制信号的控制器的Verilog描述：
		module ALUControl (ALUOp, FuncCode, ALUctl);
			input [1:0] ALUOp;
			input [5:0] FuncCode;
			output [3:0] reg ALUctl;
			always case (FuncCode)
				32: ALUctl <=2;
				34: ALUctl <=6;
				36: ALUctl <=0;
				37: ALUctl <=1;
				39: ALUctl <=12;
				42: ALUctl <=7;
				default: ALUctl <=15;
			endcase
		endmodule
	快速加法器：超前进位
	无限硬件：CarryIn2 = (a1.CarryIn1) + (b1.CarryIn1) + (a1.b1)
			  c2 = a1.c1+b1.c1+a1.b1
			  c1 = a0.c0+b0.c0+a0.b0
			  c2 = (a1.a0.c0)+(a1.b0.c0)+(a1.a0.b0)+(b1.a0.c0)+(b1.b0.c0)+(b1.a0.b0)+a1.b1
	根据上面的表达式可以知道，第n位的进位输入总是可以通过硬件直接得到而不用像行波进位加法器那样等待上一位计算的结果。
但是也可以看出，这种方式的复杂性会随着位数的增加而急剧增加。
	使用抽象来解决复杂性：ci+1 = ai.bi + (ai+bi).ci
	定义生成gi和传播pi逻辑单元:	gi = ai.bi		pi = ai+bi
	如此：ci+1 = gi +　pi.ci
		  c1 = g0 + p0.c0
		  c2 = g1 + p1.c1 = g1 + p1.g0 + p1.p0.c0
		  c4 = g3 + p3.g2 + p3.p2.g1 + p3.p2.p1.g0 + p3.p2.p1.p0.c0
		  可以看出ci 最多只需经过3层逻辑单元计算就可以得到结果
	带超前进位的4位加法器：
	定义逻辑单元：P0 = p3.p2.p1.p0
				  P1 = p7.p6.p5.p4
				  P2 = p11.p10.p9.p8
				  P3 = p15.p14.p13.p12
				  G0 = g3 + (p3.g2) + (p3.p2.g1) + (p3.p2.p1.g0)
				  G1 = g7 + (p7.g6) + (p7.p6.g5) + (p7.p6.p5.g4)
				  G2 = g11 + (p11.g10) + (p11.p10.g9) + (p11.p10.p9.g8)
				  G3 = g15 + (p15.g14) + (p15.p14.g13) + (p15.p14.p13.g12)
	每个四位加法器进位输出：
				  C1 = G0 + P0.c0
				  C2 = G1 + (P1.G0) + (P1.P0.c0)
				  C4 = G3 + (P3.G2) + (P3.P2.G1) + (P3.P2.P1.G0) + (P3.P2.P1.P0.c0)
	C4(16位加法器的最高位进位输出)最多只需要经过5层逻辑单元(5个门电路时延)就可以得到进位值，而16位的行波进位加法器需要16*2=32个门电
路时延。
	现代计算机使用CMOS晶体管作为基本电路，设计时要比传统的逻辑门电路更简洁(使用更少的多路复用器)。
	时钟信号：时钟信号是决定更新逻辑存储单元中的状态的信号，一般来说时钟信号有固定的周期。时钟周期由两部分组成：
高电平和低电平。边缘触发时钟是在时钟信号变化边缘更新存储单元状态的时钟方案，这种机制中只有上升沿(或下降沿)才是有效
信号，给定的设计方案中只能使用上升沿和下降沿中的一种。
	同步的含义：时钟控制系统保证在时钟信号上升沿或下降沿发生时待保存的数据信号是有效的信号的机制。
	S-R锁存器：images/S-R锁存器.jpg，S和R输入都为0时保存上次的输入信号，S和R不能同时为1，否则会产生不确定的信号。
	触发器和锁存器的区别：锁存器在时钟信号变化时就根据数据信号修改内部存储的值，而触发器只在时钟信号的上升沿(或下降
沿)根据数据信号更新存储信号。
	D锁存器：images/D锁存器.jpg，当时钟信号C打开，马上保存输入信号D的值:Q=D
	D触发器：images/D触发器.jpg，当时钟信号C关闭，才保存输入信号D的值：Q=D
	锁存器和触发器都可以在时钟信号的控制下保存一位数据信号，通过构建触发器阵列就可以实现存储字节、
字等多位数据。
	寄存器堆由许多寄存器组成，寄存器堆可以根据输入的寄存器号(通过n-2^n译码器)和读写信号对指定寄存器
进行读写。
	SRAM使用一对反向门电路(D触发器)保存数据，只要保持供电，内部数据会一直保留。DRAM的数据则是以电荷量的形式被保存
在电容中。
	对于大容量的SRAM，使用译码器或多路复用器是麻烦的，而且容量会受限，这种情况下可以使用二级译码器
减小硬件的难度，例如 4M x 8 SRAM的22位地址线可以分为两组，10-21用于第一级译码器，产生4096个阵列地址中的
阵列地址，0-9用于第二级译码器确定阵列内1024个阵内地址中的地址: 4M = 4k x 1k 
	DRAM的信号保存在电容中，需要不断的刷新来保持数值，这也是它被称为动态的原因。
	电容中的电荷量通常能维持几个毫秒，这相当于 n x 1000000个时钟周期，DRAM采用二级译码器，在读周期后
跟上一个写周期，实现整行刷新，这样可以将刷新工作占用的时间减少到总时间的2%以内。
	DRAM使用晶体管作为开关，字线用于写或读信号，位线用于控制信号。
	复用地址线：4M x 1 的DRAM使用11条地址线，先经第一级译码器产生2048个阵列地址中的地址，然后将阵列内的
数据都保存到列锁存器中，再由下一个信号脉冲后的11位地址信号产生2048个阵内地址，然后根据阵内地址从列
锁存器取出数据。
	SDRAM: 同步DRAM，将列地址和行地址同步输入，同时扩展列的带宽后的DRAM。DDRRAM：双倍数据传输率RAM，
在时钟信号的上升沿和下降沿都能传输数据的RAM，是SDRAM的一种。
	1位奇偶校验：存储器提供额外的一位保存数据中1的数量是否为奇数。能够检验数据是否发生奇数位错误。
	另外还有一种纠错码，使用2位或多位保存纠错码，能够检验并纠正数据中的多位错误。
	
	有限状态机：由一组输入和输出集组成的时序逻辑函数(系统)，下一状态和输出都由当前状态和输入决定。
有限状态机包括一组状态量、输入系统和一个输出函数、一个下一状态函数。
	摩尔机：输出函数仅仅依赖于当前状态。
	米利机：输出函数既依赖于当前状态，也依赖于输入数据。
	交通控制灯实例(这是一个摩尔机实例)：
		定义输入：南北向、东西向的车流：NSCar、EWCar；时钟信号：clock
		定义交通灯状态：state(0表示南北向绿灯，1表示东西向绿灯)
		定义输出：南北向通行信号：NSLite，东西向通行信号：EWLite
		定义规则：时钟信号到来后，检查交通灯状态，如果state为0，则输出南北向通行信号NSLite为1，如果state为1，
		则输出东西向通行信号EWLite为1；然后检查输入信号NSCar和EWCar，如果state为0，EWCar也为真，则state置为
		1，否则state仍然为0，如果state为1，NSCar为真，则state置为0，否则state仍为1
	Verilog描述：
		module TrafficLite (EWCar,NSCar,EWLite,NSLite,clock);
			input EWCar,NSCar,clock;
			output EWLite,NSLite;
			reg state;
			initial state=0;
			assign NSLite = -state;
			assign EWLite = state;
			always @(posedge clock)
				case (state)
					0: state = EWCar;
					1: state = NSCar;
				endcase
		endmodule
	时钟周期如果不够长，具体来说就是小于逻辑单元的信号建立时间、稳定时间和传播时间以及时钟偏移的和，
就会导致输入的信号被错误地处理。
	时钟边缘触发的缺点：增加了额外的逻辑电路和可能增加时延，电平触发机制在高电平或低电平段内录入信号，
本身就无法保证信号的录入严格同步，可以通过使用双相时钟控制逻辑实现同步录入。
	有些逻辑系统需要对异步输入的信号进行同步（不同频率的信号按照当前系统频率采样），可以使用D触发器
作为同步器。
	同步失败：同步时钟信号到来时输入信号处于亚稳态，导致输出信号无法保证正确性。如果输入频率比需要的
同步频率高，可以通过连接几个触发器来减小同步失败的概率。

								第五章 CPU设计和实现
	程序被编译成机器指令，由CPU执行，编译器和指令集决定了程序最终被编译成多少条机器指令，机器处理器的
实现决定了时钟周期的长度和每一条机器指令需要多少个时钟周期来执行（每条指令需要多个控制信号来分步进行，
每个时钟周期产生一个这样的控制信号）。
	MIPS的核心指令子集：存储访问指令lw、sw; 算术运算指令add、sub; 逻辑运算指令and、or; 小于则置1指令slt;
跳转指令beq、j
	MIPS子集实现的抽象视图：images/MIPS子集实现的抽象视图.jpg
	对于数据来源有多个的单元，系统使用多路复用器来选择数据来源；控制器根据指令类型产生控制信号，控制信号
用来控制多路复用器以及内存系统进行读还是写操作。
	包含多路复用器和控制器的MIPS子集实现：images/包含多路复用器和控制器的MIPS子集实现.jpg
	MIPS实现中的功能单元可以分为两类：组合单元和状态单元。ALU是组合单元，其输出只由输入决定，存储
器、寄存器等则是状态单元，可以保存状态。状态单元至少有两个输入和一个输出：两个输入是写入的数据和
写时钟信号，输出提供保存的状态值或状态值和输入信号的函数结果。
	时钟同步方法：是一种设计约定，保证在时钟信号到来时，读出或写入的数据信号是有效的。边沿触发就是
一种时钟同步方法，约定在时钟边沿（上升沿或下降沿）进行写入或读取。
	指令需要的数据通路部件（操作或保存数据的功能单元）：PC寄存器、指令存储器、计算下一条指令地址的
ALU（执行PC+4）；R型指令需要操作通用寄存器，所以还需要一个寄存器堆单元，还需要一个ALU执行算术逻辑
运输，寄存器堆需要4个输入（3个寄存器号和1个写信号）和2个输出；取数或存数指令需要从数据存储器读取
数据或向数据存储器写入数据，所以需要一个数据存储单元，还需要一个将16位偏移量扩展为32为的符号扩展
单元。
	通过组合单个数据通路部件和控制单元就可以得到一个完整的数据通路单元。
	ALU需要4个控制信号（或一个4位输出信号），使用其中的6种组合来控制基本的操作：与、或、加、减、
小于则置1、异或。可以使用一个小的控制单元来生成这个4位的输出信号，这个单元的输入为指令的功能字段
（函数码）和一个两位的ALUop信号，ALUop根据操作码译码得到。
		指令码		ALUop		功能字段		期望操作		输出信号
		lw			00			xxxxxx			加(计算内存地址) 0010
		sw			00			xxxxxx			加(计算内存地址) 0010
		beq			01			xxxxxx			减				 0110
		add			10			100000			加				 0010
		sub			10			100010			减				 0110
		and 		10			100100			与				 0000
		or 			10			100101			或				 0001
		slt 		10			101010			小于置1			 0111
	这是一种多层译码的方法，主控制单元根据操作码译码产生ALUop信号，ALU控制单元再根据ALUop信号和
功能字段产生ALU控制信号。
	具有控制器的单时钟周期MIPS数据通路：../images/具有控制器的单时钟周期MIPS数据通路.PNG
	主控制器输入为指令的操作码字段，输出为8个控制信号（包括2位的ALUop信号）：
RegDst:		作为一个多路复用器的选择信号，用于选择输入寄存器堆的待写寄存器编号（对于R型指令是指令
			的15:11位，对于lw指令则是指令的20:16位）
RegWrite:	寄存器堆的写控制信号（适用于R型指令和lw指令）
ALUsrc:		作为一个多路复用器的选择信号，用于选择ALU的第二个输入是来自于寄存器堆的输出还是经过
			符号扩展的指令低16位。
PCsrc:		作为一个多路复用器的选择信号，用于选择PC的输入信号是PC+4还是分支跳转地址。
MemRead:	数据存储器的读控制信号。
MemWrite:	数据存储器的写控制信号。
MemToReg:	作为一个多路复用器的选择信号，用于选择输入寄存器堆的数据信号来自于ALU计算输出还是数据
			存储器的输出。
ALUop:		ALU控制器的一个2位输入信号。
	R型指令的执行步骤：
	1、从指令存储器中取出指令，PC增值为PC+4
	2、寄存器$t2、$t3的内容从寄存器堆中读出，主控制单元计算产生各控制线上的信号状态。
	3、ALU根据指令的功能字段（指令的5:0位）对从寄存器堆中读出的数据进行操作。
	4、ALU计算的结果被写回到寄存器堆中。
	加上跳转指令的MIPS简单指令单时钟周期数据通路：../images/加上跳转指令的MIPS简单指令单时钟周期数据通路.PNG
	单时钟周期设计的效率是很低的，CPI始终为1，对于R型指令只需要使用4个数据通路部件，而lw指令需要
使用5个数据通路部件，这样单时钟周期就要求时钟周期的时间要大于lw指令的时间，但是其他指令其实是不需要
那么长的时间的。
	