							spring cloud 微服务开发手书
第一章 基础知识
	微服务是什么？
	微服务是对单体系统进行分布式改造的一种设计架构模式，通过分布式的多个独立运行的服务进程代替单进程的单体应用，
服务之间使用轻量级的HTTP消息进行通信，每一个服务都只关注一组耦合度较高、业务一致的功能，并且每个服务维护自己的数据
存储、测试以及部署发布。不同的服务可以采用不同的语言进行开发。
	
	单体系统出了问题？
	单体系统随着需求的扩展，变得越来越复杂和臃肿，部署发布也变得耗时麻烦，并且不利于团队协作。
	
	微服务不是万能的：
	多个服务进程的编排会给运维带来新的挑战；服务间调用时接口变动需要保证一致性；分布式系统固有的复杂性：如网络问题、
分布式事务等。
	
	Martin Fowler提出的微服务架构九大特性：
	服务组件化、按业务组织团队、做产品的态度、智能端点和粗粒度的通信、去中心化治理（解耦单一开发平台）、去中心化
管理数据、基础设施自动化（自动化测试、自动化部署）、容错设计、演进式设计。
	
	各种微服务框架都是为了充分利用微服务架构的优点，同时尽可能地解决微服务带来的问题。
	
	为什么是spring cloud？
	spring cloud提供了实施微服务架构的所有框架，spring cloud组合了一批经过充分测试的基础框架（组件），同时提供了
一些新的边缘组件。
	
	spring cloud简介：
	它是一个基于spring boot实现的微服务开发框架工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、
集群状态管理、分布式会话等操作提供了一种简单的开发方式。
	spring cloud包含多个子项目（框架组件）：spring cloud config、 spring cloud netflix等。
	spring cloud的版本：大版本使用伦敦的地铁站名（按字母排序），bug修复版为SRX。例如：Brixton.SR5

	
第二章 spring boot基础
	为什么是spring boot？
	spring cloud 的各个子项目都是使用spring boot进行开发的；同时由于spring boot的快速开发、自动化配置等优秀特性，
在我们自己的项目中，最好也使用它来开发自己的微服务。
	
	spring boot做了什么？
	spring boot提供了大量的自动化配置以代替老式spring工程的样板式配置；spring boot还提供了一系列starter poms
（起步依赖模块）以帮助我们手动维护项目中复杂的依赖关系；spring boot支持嵌入式的web容器，可以很方便的进行容器化部署
发布。
	spring boot工程搭建参考SpringBoot笔记，下面是springboot的配置介绍。
	配置文件存放目录：src/main/resources，默认配置文件是application.properties；除了properties文件外，也可以使用yml
格式文件。yml文件的一个好处是可以在一个yml文件中通过spring.profiles属性来指定多个不同的环境配置。
另外，yml中定义的属性是有顺序的。
	自定义参数：配置文件中添加自定义参数，应用组件Bean可以使用@Value("${att_name}")或者@Value("#{att_name}")
注入该参数。在配置文件中可以使用${att_name}引用配置文件中定义的参数。配置文件中还可以使用${random}生成随机值：
	${random.value} #随机字符串
	${random.int} #随机int
	${random.long} #随机long
	${random.int(10)} #10以内的随机整数
	${random.int[10,20]} #10到20的随机整数
	
	命令行运行jar包添加参数： java -jar xxx.jar --server.port=8088
	多环境配置：创建多个不同环境的配置文件，命名格式：application-{profile}.properties；在主配置文件application.properties
中使用属性：spring.profiles.active={profile}指定使用哪个环境的配置文件。
	springboot加载配置属性顺序问题：
	1.命令行参数->2.操作系统环境变量->3.当前应用jar包外部的application-{profile}文件->4.当前应用jar包内部的application-{profile}文件
->5.当前应用jar包外部的application文件->6.当前应用jar包内部的application文件->7.@Configuration注解修饰类中@propertySource
修饰的属性变量值->8.springboot默认属性值。（其中有一些不常用的配置方式没有列出）。
	第3项和第5项表明可以使用jar包外部的配置文件来取代jar包内部的配置。
	微服务架构下需要收集微服务应用的各项指标情况，根据这些指标信息制定监控和预警规则。所以每一个微服务应用都需要有一套
提供应用指标信息的接口，而使用springboot构建的微服务应用可以使用spring-boot-starter-actuator实现这一套接口。
	spring-boot-starter-actuator提供的原生端点可以分为三种类型：
	应用配置类：应用配置、环境变量、自动化配置等信息；
	/autoconfig: 获取应用的自动化配置信息
	/beans:	获取应用上下文创建的所有bean
	/configprops: 获取应用中配置的属性信息（看起来像是配置端点的）
	/env: 获取应用所有可用的环境属性：包括配置文件中配置的属性、环境变量、JVM属性、命令行参数等
	/mapping: 返回springMVC的控制器映射关系信息，包括处理器映射器和实际处理方法等
	/info: 返回配置文件中以info开头的自定义属性
	
	度量指标类：内存信息、线程池信息、http请求统计信息等；
	/metrics: 获取应用的运行时信息，包括内存使用情况、线程信息、处理器信息、http会话信息等，可以使用/metrics/{name}获取
具体某一方面的信息
	/health: 应用的健康指标，主要是磁盘空间占用、数据源是否可用等信息
	/dump: 返回运行中的线程信息
	/trace: 返回跟踪的最近100条http请求和响应信息
	
	操作控制类：关闭应用等操作接口
	操作控制类端点默认是不启用的，需要配置：endpoints.shutdown.enabled=true(原生端点只提供了shutdown端点来关闭应用)

第三章 Eureka
	spring社区基于Netflix Eureka进行了封装，负责spring cloud微服务架构中的服务治理工作（微服务实例的自动注册和发现）。
当微服务数量太多的时候，静态配置、手动维护变得非常困难和麻烦，服务治理框架的解决方案是使用服务端注册中心统一登记服务
实例，服务实例则使用服务治理客户端向注册中心登记自己，同时也使用客户端作为服务发现组件，实现服务间的调用。客户端以
心跳的方式向注册中心报告服务实例的状态，注册中心可以据此排除不可用的服务实例。
	使用客户端服务发现可以基于服务名进行，从而和服务提供者的具体位置解耦，还可以使用负载均衡（使用其他组件实现）。
	服务注册中心的搭建：
	新建springboot工程：eureka-server
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka-server</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-dependencies</artifactId>
					<version>Brixton.SR5</version>
					<type>pom</type>
					<scope>import</scope>
				</dependency>
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableEurekaServer
	修改配置文件application.properties:
		server.port=1111
		eureka.instance.hostname=localhost
		#下面两行配置目的是不向自己注册自己
		eureka.client.register-with-eureka=false  
		eureka.client.fetch-registry=false
		#配置注册中心的地址（客户端配置）
		eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/
	
	启动eureka-server就可以通过http://localhost:1111/查看注册中心了。
	
	服务实例的注册和发现：
	新建springboot工程：hello-sevice
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-test</artifactId>
				<scope>test</scope>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<!-- 同上-->
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableDiscoveryClient
	Controller中注入DiscovertyClient:
		@Autowired
		private DiscoverryClient discovertyClient;
	使用DiscoverryClient：
		@RequestMapping(value="/hello", method=RequestMethod.GET)
		public String hello(){
			ServiceInstance instance = discovertyClient.getLocalServiceInstance();
			String host = instance.getHost();
			String id = instance.getServiceId();
			return "hello";
		}		
	修改配置文件application.properties:
		spring.application.name=hello-sevice
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
	
	高可用注册中心：服务注册中心非常重要，因此需要考虑故障的应对方法，Eureka server的设计考虑到了这一点，提供了服务
注册中心互相注册的机制，通过这种互相注册实现服务清单的互相同步。
	构建一个双节点的服务注册中心集群：
	为前面的服务注册中心工程 eureka-server 添加两个配置文件：application-peer1.properties和application-peer2.properties:
	application-peer1.properties
		spring.application.name=eureka-server
		server.port=1111
		eureka.instance.hostname=peer1
		eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/
	application-peer2.properties
		spring.application.name=eureka-server
		server.port=1112
		eureka.instance.hostname=peer2
		eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/
	修改host文件：
		127.0.0.1 peer1
		127.0.0.1 peer2
	分别启动两个eureka-server：
		java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1
		java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2
	注册hello-service到eureka-server集群上：修改hello-service配置文件：application.properties
		spring.application.name=hello-sevice
		eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/
	使用IP地址而不是主机名作为eureka服务注册中心的地址：添加配置项：
		eureka.instance.prefer-ip-address=true  //需要验证该配置项的位置是注册中心配置文件还是客户端配置文件  
												//也许是指服务注册中心登记的服务实例的登记名是IP还是主机名
	
	使用Ribbon进行客户端负载均衡消费服务：
	将hello-service在两个端口启动，向注册中心注册两个hello-service服务：
		java -jar hello-sevice-0.0.1-SNAPSHOT.jar --server.port=8081
		java -jar hello-sevice-0.0.1-SNAPSHOT.jar --server.port=8082
	新建一个服务消费者项目：ribbon-consumer：
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-cloud-starter-ribbon</artifactId>
				<scope>test</scope>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<!-- 同上-->
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：@EnableDiscoveryClient
	声明RestTemplate类型的bean,使用@LoadBalanced注解开启客户端负载均衡：
		@Bean
		@LoadBalanced
		RestTemplate restTemplate(){
			return new RestTemplate();
		}
	服务消费，使用hello-service服务：
		String hello = restTemplate.getForEntity("http://HELLO-SERVICE/hello");
	修改配置文件application：
		spring.application.name=ribbon-consumer
		server.port=9000
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
	Ribbon使用轮询的方式交替访问可用的服务，实现负载均衡
	
	Eureka服务治理基础架构的三个核心要素：服务注册中心、服务提供者、服务消费者
	服务治理机制：
	服务注册：服务提供者在启动时就会将自己的信心通过请求发送给服务注册中心，服务注册中心使用一个双层Map结构保存
服务实例信息，第一层key值是服务名，第二层key值是服务实例名。如果在启动时不希望注册服务到注册中心，可以使用如下配置：
		eureka.client.register-with-eureka=false  //该值默认为true
	服务同步：在高可用注册中心集群中，当服务提供者发送注册请求到一个注册中心时，该注册中心将会把这个注册请求转发给
集群内与之相连的其他注册中心，从而实现服务注册中心间服务清单的同步。
	服务续约：注册服务后，服务提供者会维护一个心跳向注册中心持续地报告自身状态。注册中心使用两个属性来确定客户端发送
心跳的间隔时间和服务失效时间：
		eureka.instance.lease-renewal-interval-in-seconds=30
		eureka.instance.lease-expiration-duration-in-seconds=90
	服务消费者：服务消费者启动的时候会向注册中心发送一个请求以获取注册中心注册的服务清单，注册中心（Eureka Server）会
维护一份只读的服务清单返回给客户端，并且30秒更新一次该清单。要从注册中心获取服务清单必须确保:
		eureka.client.fetch-registry=true
	客户端使用属性：
		eureka.client.registry-fetch-interval-seconds
	的值（默认为30秒）更新缓存的服务清单。
	服务调用：Eureka使用Region和Zone的概念划分服务分组，一个Region中可以包含多个Zone，每个客户端被注册到一个zone，因此
一个客户端对应一个Zone和一个Region，服务调用时优先访问同一个zone的服务提供者，找不到再访问同一个Region的服务提供者。
	服务下线：当服务实例正常关闭时，会想注册中心发送一个请求告知下线，注册中心将该服务设置为下线，并传播该事件。
	失效剔除：注册中心(Eureka Server)在启动时会创建一个定时任务，每隔一段时间（默认60秒）检测服务清单，将超时（默认90秒）
没有续约的服务剔除。通常是服务实例非正常结束（内存溢出等）导致注册中心进行失效剔除。
	自我保护：注册中心运行时统计每个服务实例在15分钟内心跳失败的比例，如果高于85%，注册中心就保护当前实例，这样这个服务
实例就不会过期被剔除，但是这样可能会造成客户端拿到的服务实例是不可用的，这需要服务消费者自己去实现容错处理。通常本地调试
容易触发自我保护，实际环境通常是网络不稳定触发自我保护。注册中心使用属性
		eureka.server.enable-self-preservation=false
关闭自我保护机制。
	设置Region属性：eureka.client.region=?
	设置zone属性：  eureka.client.availability-zones=?,?
	Region默认值为default，Zone默认值为defaultZone
	@EnableDiscoveryClient注解用于开启DiscoveryClient的实例，使用eureka客户端就是创建DiscoveryClient的实现类EurekaDiscoveryClient
的实例对象，该对象使用netflix的DiscoveryClient对象完成服务注册和发现。
	
	
	