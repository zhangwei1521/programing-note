							spring cloud 微服务开发手书
第一章 基础知识
	微服务是什么？
	微服务是对单体系统进行分布式改造的一种设计架构模式，通过分布式的多个独立运行的服务进程代替单进程的单体应用，
服务之间使用轻量级的HTTP消息进行通信，每一个服务都只关注一组耦合度较高、业务一致的功能，并且每个服务维护自己的数据
存储、测试以及部署发布。不同的服务可以采用不同的语言进行开发。
	
	单体系统出了问题？
	单体系统随着需求的扩展，变得越来越复杂和臃肿，部署发布也变得耗时麻烦，并且不利于团队协作。
	
	微服务不是万能的：
	多个服务进程的编排会给运维带来新的挑战；服务间调用时接口变动需要保证一致性；分布式系统固有的复杂性：如网络问题、
分布式事务等。
	
	Martin Fowler提出的微服务架构九大特性：
	服务组件化、按业务组织团队、做产品的态度、智能端点和粗粒度的通信、去中心化治理（解耦单一开发平台）、去中心化
管理数据、基础设施自动化（自动化测试、自动化部署）、容错设计、演进式设计。
	
	各种微服务框架都是为了充分利用微服务架构的优点，同时尽可能地解决微服务带来的问题。
	
	为什么是spring cloud？
	spring cloud提供了实施微服务架构的所有框架，spring cloud组合了一批经过充分测试的基础框架（组件），同时提供了
一些新的边缘组件。
	
	spring cloud简介：
	它是一个基于spring boot实现的微服务开发框架工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、
集群状态管理、分布式会话等操作提供了一种简单的开发方式。
	spring cloud包含多个子项目（框架组件）：spring cloud config、 spring cloud netflix等。
	spring cloud的版本：大版本使用伦敦的地铁站名（按字母排序），bug修复版为SRX。例如：Brixton.SR5

	
第二章 spring boot基础
	为什么是spring boot？
	spring cloud 的各个子项目都是使用spring boot进行开发的；同时由于spring boot的快速开发、自动化配置等优秀特性，
在我们自己的项目中，最好也使用它来开发自己的微服务。
	
	spring boot做了什么？
	spring boot提供了大量的自动化配置以代替老式spring工程的样板式配置；spring boot还提供了一系列starter poms
（起步依赖模块）以帮助我们手动维护项目中复杂的依赖关系；spring boot支持嵌入式的web容器，可以很方便的进行容器化部署
发布。
	spring boot工程搭建参考SpringBoot笔记，下面是springboot的配置介绍。
	配置文件存放目录：src/main/resources，默认配置文件是application.properties；除了properties文件外，也可以使用yml
格式文件。yml文件的一个好处是可以在一个yml文件中通过spring.profiles属性来指定多个不同的环境配置。
另外，yml中定义的属性是有顺序的。
	自定义参数：配置文件中添加自定义参数，应用组件Bean可以使用@Value("${att_name}")或者@Value("#{att_name}")
注入该参数。在配置文件中可以使用${att_name}引用配置文件中定义的参数。配置文件中还可以使用${random}生成随机值：
	${random.value} #随机字符串
	${random.int} #随机int
	${random.long} #随机long
	${random.int(10)} #10以内的随机整数
	${random.int[10,20]} #10到20的随机整数
	
	命令行运行jar包添加参数： java -jar xxx.jar --server.port=8088
	多环境配置：创建多个不同环境的配置文件，命名格式：application-{profile}.properties；在主配置文件application.properties
中使用属性：spring.profiles.active={profile}指定使用哪个环境的配置文件。
	springboot加载配置属性顺序问题：
	1.命令行参数->2.操作系统环境变量->3.当前应用jar包外部的application-{profile}文件->4.当前应用jar包内部的application-{profile}文件
->5.当前应用jar包外部的application文件->6.当前应用jar包内部的application文件->7.@Configuration注解修饰类中@propertySource
修饰的属性变量值->8.springboot默认属性值。（其中有一些不常用的配置方式没有列出）。
	第3项和第5项表明可以使用jar包外部的配置文件来取代jar包内部的配置。
	微服务架构下需要收集微服务应用的各项指标情况，根据这些指标信息制定监控和预警规则。所以每一个微服务应用都需要有一套
提供应用指标信息的接口，而使用springboot构建的微服务应用可以使用spring-boot-starter-actuator实现这一套接口。
	spring-boot-starter-actuator提供的原生端点可以分为三种类型：
	应用配置类：应用配置、环境变量、自动化配置等信息；
	/autoconfig: 获取应用的自动化配置信息
	/beans:	获取应用上下文创建的所有bean
	/configprops: 获取应用中配置的属性信息（看起来像是配置端点的）
	/env: 获取应用所有可用的环境属性：包括配置文件中配置的属性、环境变量、JVM属性、命令行参数等
	/mapping: 返回springMVC的控制器映射关系信息，包括处理器映射器和实际处理方法等
	/info: 返回配置文件中以info开头的自定义属性
	
	度量指标类：内存信息、线程池信息、http请求统计信息等；
	/metrics: 获取应用的运行时信息，包括内存使用情况、线程信息、处理器信息、http会话信息等，可以使用/metrics/{name}获取
具体某一方面的信息
	/health: 应用的健康指标，主要是磁盘空间占用、数据源是否可用等信息
	/dump: 返回运行中的线程信息
	/trace: 返回跟踪的最近100条http请求和响应信息
	
	操作控制类：关闭应用等操作接口
	操作控制类端点默认是不启用的，需要配置：endpoints.shutdown.enabled=true(原生端点只提供了shutdown端点来关闭应用)

第三章 Eureka
	spring社区基于Netflix Eureka进行了封装，负责spring cloud微服务架构中的服务治理工作（微服务实例的自动注册和发现）。
当微服务数量太多的时候，静态配置、手动维护变得非常困难和麻烦，服务治理框架的解决方案是使用服务端注册中心统一登记服务
实例，服务实例则使用服务治理客户端向注册中心登记自己，同时也使用客户端作为服务发现组件，实现服务间的调用。客户端以
心跳的方式向注册中心报告服务实例的状态，注册中心可以据此排除不可用的服务实例。
	使用客户端服务发现可以基于服务名进行，从而和服务提供者的具体位置解耦，还可以使用负载均衡（使用其他组件实现）。
	服务注册中心的搭建：
	新建springboot工程：eureka-server
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka-server</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-dependencies</artifactId>
					<version>Brixton.SR5</version>
					<type>pom</type>
					<scope>import</scope>
				</dependency>
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableEurekaServer
	修改配置文件application.properties:
		server.port=1111
		eureka.instance.hostname=localhost
		#下面两行配置目的是不向自己注册自己
		eureka.client.register-with-eureka=false  
		eureka.client.fetch-registry=false
		#配置注册中心的地址（客户端配置）
		eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/
	
	启动eureka-server就可以通过http://localhost:1111/查看注册中心了。
	
	服务实例的注册和发现：
	新建springboot工程：hello-sevice
	pom依赖：
		<parent>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-parent</artifactId>
			<version>1.3.7.RELEASE</version>
			<relativePath/>
		</parent>
		<dependencies>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-web</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-test</artifactId>
				<scope>test</scope>
			</dependency>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-starter-eureka</artifactId>
			</dependency>
		</dependencies>
		</dependencyManagement>
			<dependencies>
				<!-- 同上-->
			</dependencies>
		</dependencyManagement>
	启动类上添加注解：
		@EnableDiscoveryClient
	Controller中注入DiscovertyClient:
		@Autowired
		private DiscoverryClient discovertyClient;
	使用DiscoverryClient：
		ServiceInstance instance = discovertyClient.getLocalServiceInstance();
		String host = instance.getHost();
		String id = instance.getServiceId();
	修改配置文件application.properties:
		spring.application.name=hello-sevice
		eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/