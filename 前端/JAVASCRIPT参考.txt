					++++++++++++++++++++++	JAVASCRIPT参考	++++++++++++++++++++++++++
							参考链接地址：https://wangdoc.com/javascript/
------基本语法-------

语句（statement）：是为了完成某种任务而进行的操作。
表达式（expression）：指一个为了得到返回值的计算式。
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

变量：是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。
var：是变量声明命令。它表示通知解释引擎，要创建一个变量。var a = 1;
注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个 JavaScript 关键字，表示“无定义”。
不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量。
如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。(Uncaught ReferenceError: xxx is not defined)
可以在同一条var命令中声明多个变量。var a, b;
变量的类型没有限制，变量可以随时更改类型。
如果使用var重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。
JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。
这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。
console.log(a);
var a = 1;
输出：undefined

标识符（identifier）：指的是用来识别各种值的合法名称。
JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。
标识符规则：
第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。
第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。
中文是合法的标识符，可以用作变量名。
JavaScript有一些保留字，不能用作标识符：arguments、break、case等。

单行注释，用//起头；多行注释，放在/*和*/之间。<!--和-->也被视为合法的单行注释。但是-->只有在行首，才会被当成单行注释，否则会当作正常的运算。
对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。与不使用区块的情况没有任何区别。
if (2 = x) { ...}：将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。
优先采用“严格相等运算符”（===）。
else代码块总是与离自己最近的那个if语句配对。
switch语句部分和case语句部分，都可以使用表达式。
需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），
而不是相等运算符（==），这意味着比较时不会发生类型转换。

利用三元运算符，在字符串之中插入不同的值：
var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数');
for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。
不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。
如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。
标签（label），相当于定位符，用于跳转到程序的任意位置。
标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。
标签通常与break语句和continue语句配合使用，跳出特定的循环。
top:
	for (var i = 0; i < 3; i++){
		for (var j = 0; j < 3; j++){
		  if (i === 1 && j === 1) break top;
		  console.log('i=' + i + ', j=' + j);
		}
	}
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) continue top;
      console.log('i=' + i + ', j=' + j);
    }
  }
括号表达式：
(exp1,exp2)返回exp2

------数据类型------

JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂时不涉及。）
数值（number）：整数和小数；
字符串（string）：文本；
布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）；
undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；
null：表示空值，即此处的值为空；
对象（object）：各种值组成的集合。
数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）
对象的类型：
狭义的对象（object）
数组（array）
函数（function）
确定一个值到底是什么类型：
①typeof运算符：返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean。
	函数返回function。undefined返回undefined。对象返回object。null返回object。
②instanceof运算符：预留...
③Object.prototype.toString方法：预留...

在if语句中，null与undefined都会被自动转为false，相等运算符（==）直接报告两者相等。
根据 C 语言的传统，null可以自动转为0。	5 + null // 5
undefined是一个表示"此处无定义"的原始值，转为数值时为NaN。Number(undefined) // NaN		5 + undefined // NaN
undefined的应用场景：
// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。
将转为false的六个值（表达式计算结果）：undefined、null、false、0、NaN、""或''（空字符串）
注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 	1 === 1.0 // true
某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算 		预留...
使用浮点数表示小数是不精确的：
0.1 + 0.2 === 0.3				// false  
0.3 / 0.1						// 2.9999999999999996
(0.3 - 0.2) === (0.2 - 0.1)		// false

IEEE 754标准
64位浮点数格式：
第1位：符号位，0表示正数，1表示负数；
第2位到第12位（共11位）：指数部分；
第13位到第64位（共52位）：小数部分（即有效数字）

在IEEE-754 标准下，浮点数一共分为：

无穷数：指数位全部为1 同时尾数位全为0。
规格化数：指数位不全为1 同时不全为0。此时浮点数的隐含位有效，其值为1。
0 ：指数位与尾数位都全为0，根据符号位决定正负。
NaN：即Not a Number。非数的指数位全部为1 同时尾数位不全为0。在此前提下，根据尾数位首位是否为1，NaN 还可以分为SNaN 和QNaN 两类。
	前者参与运算时将会发生异常。
非规格化数：指数位全为0 且尾数位不全为0。此时隐含位有效，值为0。另外需要注意，以单精度时为例，真实(32位单精度)指数E 并非0-127=-127，
	而是-126，这样一来就与规格化下最小真实指数E=1-127=-126 达成统一，形成过度。

64位双精度浮点数，精度最多只能到53个二进制位，这意味着，绝对值小于等于2的53次方的整数，都可以精确表示。
如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，
即 JavaScript 无法表示这么小的数，这时会直接返回0。

NaN不等于任何值，包括它本身。
NaN与任何数（包括它自己）的运算，得到的都是NaN。

十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。
0888 // 888
0777 // 511
前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。
唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。
除以正零得到+Infinity，除以负零得到-Infinity
需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。
typeof NaN // 'number'

由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。但是0除以0会得到NaN。
0 / 0 // NaN
0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。
Infinity加上或乘以Infinity，返回的还是Infinity。、
nfinity减去或除以Infinity，得到NaN。
Infinity与undefined计算，返回的都是NaN。
Infinity与null计算时，null会转成0，等同于与0的计算。

=====================================================
parseInt
	parseInt('123') // 123
	parseInt('   81') // 81
	parseInt(1.23) // 1
	// 等同于
	parseInt('1.23') // 1
	parseInt('8a') // 8
	parseInt('12**') // 12
	parseInt('abc') // NaN
	parseInt('.3') // NaN
	parseInt('+1') // 1
	parseInt('0x10') // 16
	parseInt('011') // 11
对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。
	parseInt(1000000000000000000000.5) // 1
	// 等同于
	parseInt('1e+21') // 1
	parseInt(0.0000008) // 8
	// 等同于
	parseInt('8e-7') // 8
parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制：
	parseInt('1000', 2) // 8
	parseInt('1000', 8) // 512
	parseInt('10', 37) // NaN
	parseInt('10', 1) // NaN
	parseInt('10', 0) // 10
	parseInt('10', null) // 10
	parseInt('10', undefined) // 10
	parseInt('1546', 2) // 1
	parseInt('546', 2) // NaN
==========================================================
parseFloat
	parseFloat('3.14') // 3.14
	parseFloat('314e-2') // 3.14
	parseFloat('0.0314E+2') // 3.14
	parseFloat('3.14more non-digit characters') // 3.14
	parseFloat('\t\v\r12.34\n ') // 12.34
	parseFloat([]) // NaN
	parseFloat('FF2') // NaN
	parseFloat('') // NaN
parseFloat和Number比较：
	parseFloat(true)  // NaN
	Number(true) // 1

	parseFloat(null) // NaN
	Number(null) // 0

	parseFloat('') // NaN
	Number('') // 0

	parseFloat('123.45#') // 123.45
	Number('123.45#') // NaN
===========================================================
isNaN
	isNaN(NaN) // true
	isNaN(123) // false
	isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true。
	也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。
	isNaN('Hello') // true
	isNaN({}) // true
	isNaN(['xzy']) // true
	对于空数组和只有一个数值成员的数组，isNaN返回false。原因是这些数组能被Number函数转成数值
	isNaN([]) // false
	isNaN([123]) // false
	isNaN(['123']) // false
判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。
function myIsNaN(value) {
  return value !== value;
}
============================================================
isFinite方法返回一个布尔值，表示某个值是否为正常的数值
	isFinite(Infinity) // false
	isFinite(-Infinity) // false
	isFinite(NaN) // false
	isFinite(undefined) // false
	isFinite(null) // true
	isFinite(-1) // true

//////////////////////////////////////////////////////////////////
字符串
字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。
字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。
连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。
反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。
三种码点表示法：
（1）\HHH
反斜杠后面紧跟三个八进制数（000到377），代表一个字符。只能输出256种字符。
（2）\xHH
\x后面紧跟两个十六进制数（00到FF），代表一个字符。只能输出256种字符。
（3）\uXXXX
\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。
如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。'\a'	// "a"
var s = 'hello';
s[0] // "h"
s[1] // "e"
s[4] // "o"
// 直接对字符串使用方括号运算符
'hello'[1] // "e"
如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。
无法改变字符串之中的单个字符。
	var s = 'hello';
	delete s[0];
	s // "hello"
	s[1] = 'a';
	s // "hello"
length属性返回字符串的长度，该属性也是无法改变的。

JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。

JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。
每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。
但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，
长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。
举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。
JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。
对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。也就是说，JavaScript 返回的字符串长度可能是不正确的。

Base64 编码可以将无法打印出来的字符（如ASCII 码0到31）转成可以打印的字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。
JavaScript 原生提供两个 Base64 相关的方法：
btoa()：任意值转为 Base64 编码
atob()：Base64 编码转为原来的值
这两个方法不适合非 ASCII 码的字符，会报错。
要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
对象
对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。
对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。
如果键名是数值，会被自动转为字符串。
如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
	// 报错
	var obj = {
	  1p: 'Hello World'
	};
属性可以动态创建，不必在对象声明时就指定。
{ foo: 123 }，行首是一个大括号，它到底是表达式还是语句？
	V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。(ie把它解释为表达式)
eval('{foo: 123}') // 123 //如果没有圆括号，eval将其理解为一个代码块
eval('({foo: 123})') // {foo: 123}
读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。
方括号运算符内部还可以使用表达式。方括号运算符内部使用数字键可以不加引号，因为会自动转成字符串。
查看一个对象本身的所有属性，可以使用Object.keys方法。
	var obj = {
	  key1: 1,
	  key2: 2
	};

	Object.keys(obj);
	// ['key1', 'key2']
delete命令用于删除对象的属性，删除成功后返回true。
	var obj = { p: 1 };
	Object.keys(obj) // ["p"]

	delete obj.p // true
	obj.p // undefined
	Object.keys(obj) // []
删除一个不存在的属性，delete不报错，而且返回true。
只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。delete命令只能删除对象本身的属性，无法删除继承的属性
	var obj = Object.defineProperty({}, 'p', {
	  value: 123,
	  configurable: false
	});

	obj.p // 123
	delete obj.p // false
in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。
它的左边是一个字符串，表示属性名，右边是一个对象。
使用对象的hasOwnProperty方法判断，属性是否为对象自身的属性。
	var obj = {};
	if ('toString' in obj) {
	  console.log(obj.hasOwnProperty('toString')) // false
	}
for...in循环用来遍历一个对象的全部属性。它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
toString属性默认是“不可遍历”的。

with语句的作用是操作同一个对象的多个属性时，提供一些书写的方便。
如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。
这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。
因此，建议不要使用with语句，可以考虑用一个临时变量代替with。
	var obj = {};
	with (obj) {
	  p1 = 4;
	  p2 = 5;
	}

	obj.p1 // undefined
	p1 // 4

//////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
函数
三种声明函数的方法：
function 命令
	function print(s) {
	  console.log(s);
	}
函数表达式
	var print = function(s) {
	  console.log(s);
	};
采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
	var print = function x(){
	  console.log(typeof x);
	};

	x
	// ReferenceError: x is not defined

	print()
	// function
这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
Function 构造函数
	var add = new Function(
	  'x',
	  'y',
	  'return x + y'
	);

	// 等同于
	function add(x, y) {
	  return x + y;
	}

Function构造函数可以不使用new命令，返回结果完全一样。总的来说，这种声明函数的方式非常不直观，几乎无人使用。
如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。
JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。
	f();
	function f() {}
但是，如果采用赋值语句定义函数，JavaScript 就会报错。
	f();
	var f = function (){};
	// TypeError: undefined is not a function
对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。
与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。
传递参数时如果有同名的参数，则取最后出现的那个值。
arguments对象包含了函数运行时的所有参数
正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。
通过arguments对象的length属性，可以判断函数调用时到底带几个参数。

闭包：
函数外部无法读取函数内部声明的变量。如果出于种种原因，需要得到函数内的局部变量。
正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数，并返回该函数，通过该内部函数访问原函数的内部变量。
闭包就是上面定义的内部函数。
闭包最大的特点，就是它可以“记住”诞生的环境。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。
	function createIncrementor(start) {
	  return function () {
		return start++;
	  };
	}

	var inc = createIncrementor(5);

	inc() // 5
	inc() // 6
	inc() // 7
闭包可以看作是函数内部作用域的一个接口。
闭包始终在内存中，而闭包的存在依赖于其外部函数，因此其外部函数也始终在内存中，不会在调用结束后，被垃圾回收机制回收。
闭包的另一个用处，是封装对象的私有属性和私有方法。
	function Person(name) {
	  var _age;
	  function setAge(n) {
		_age = n;
	  }
	  function getAge() {
		return _age;
	  }

	  return {
		name: name,
		getAge: getAge,
		setAge: setAge
	  };
	}

	var p1 = Person('张三');
	p1.setAge(25);
	p1.getAge() // 25
注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。
	function(){ /* code */ }();
	// SyntaxError: Unexpected token (
function这个关键字即可以当作语句，也可以当作表达式。
为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。
因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。
解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。
	(function(){ /* code */ }());
	// 或者
	(function(){ /* code */ })();
这就叫做“立即调用的函数表达式”（ IIFE）
通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：
一是不必为函数命名，避免了污染全局变量；
二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。

eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。
为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。
	(function f() {
	  'use strict';
	  eval('var foo = 123');
	  console.log(foo);  // ReferenceError: foo is not defined
	})()
即使在严格模式下，eval依然可以读写当前作用域的变量。
	(function f() {
	  'use strict';
	  var foo = 1;
	  eval('foo = 2');
	  console.log(foo);  // 2
	})()	
为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
数组
任何类型的数据，都可以放入数组。
本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 
数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。
	var arr = ['a', 'b', 'c'];
	Object.keys(arr)
	// ["0", "1", "2"]
JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。
数组的健名是数字，所以不能使用点结构访问。数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。
JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个
只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。
	var arr = ['a', 'b'];
	arr.length // 2
	arr[1000] = 'e';
	arr.length // 1001
数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。
length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。
	var arr = [ 'a', 'b', 'c' ];
	arr.length = 0;
	arr // []
如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。
可以为数组添加属性，但是这不影响length属性的值。
	var a = [];
	a['p'] = 'abc';
	a.length // 0
	a[2.1] = 'abc';
	a.length // 0
如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。arr[-1] = 'a';

in运算符检查某个健名是否存在于对象中，所以也适用于数组。如果数组的某个位置是空位，in运算符返回false。
for...in不仅会遍历数组所有的数字键，还会遍历非数字键。所以，不推荐使用for...in遍历数组。
forEach方法：
	var colors = ['red', 'green', 'blue'];
	colors.forEach(function (color) {
	  console.log(color);
	});
当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。var a = [1, , 1]; a.length // 3
数组的空位是可以读取的，返回undefined。使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。
数组的某个位置是空位，与某个位置是undefined，是不一样的。
如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。
如果某个位置是undefined，遍历的时候就不会被跳过。

如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。
典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。
数组的slice方法可以将“类似数组的对象”变成真正的数组。
var arr = Array.prototype.slice.call('arrayLike');
通过call()也可以把数组的方法放到“类似数组的对象”上面。
	function logArgs() {
	  Array.prototype.forEach.call(arguments, function (elem, i) {
		console.log(i + '. ' + elem);
	  });
	}
但是这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。
	var arr = Array.prototype.slice.call('abc');
	arr.forEach(function (chr) {
	  console.log(chr);
	});

===========================================================================================
运算符
加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。
由于加法运算符存在重载，可能执行两种运算
如果运算子是对象，必须先转成原始类型的值，然后再相加。
对象转成原始类型的值，规则如下：
首先，自动调用对象的valueOf方法。
	var obj = { p: 1 };
	obj.valueOf() // { p: 1 }
一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。
对象的toString方法默认返回[object Object]。可以自己定义valueOf方法或toString方法，得到想要的结果。
这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。
+数值运算符
作用在于可以将任何值转为数值（与Number函数的作用相同）。
指数运算符（**）
完成指数运算，前一个运算子是底数，后一个运算子是指数。

相等比较和非相等比较。两者的规则是不一样的。
对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；
否则，将两个运算子都转成数值，再比较数值的大小。
任何值（包括NaN本身）与NaN比较，返回的都是false。
如果运算子是对象，会转为原始类型的值，再进行比较。
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
undefined和null与自身严格相等。
建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。
0 == ''             // true
0 == '0'            // true
2 == true           // false
2 == false          // false

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。
!undefined // true
!null // true
!0 // true
!false //true
!NaN // true
!"" // true

!!x
// 等同于
Boolean(x)
且运算符（&&）往往用于多个表达式的求值:
如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
	't' && 'f' // "f"
	'' && 'f' // ""
短路机制：	
	if (i) {
	  doSomething();
	}
	// 等价于
	i && doSomething();
&&运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。
	true && 'foo' && '' && 4 && 'foo' && true
	// ''
或运算符（||）
如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。
	't' || 'f' // "t"
	'' || 'f' // "f"
||或运算符常用于为一个变量设置默认值。
saveText(this.text || '')
三元运算符：
	't' ? 'hello' : 'world' // "hello"
	0 ? 'hello' : 'world' // "world"
void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。
逗号运算符用于对两个表达式求值，并返回后一个表达式的值。
===============================================================================================================
数据类型的转换
JS中虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。
强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。
Number()转换原始类型：
Number(324) // 324
Number('324') // 324
Number('324abc') // NaN
Number('') // 0
Number(true) // 1
Number(false) // 0
Number(undefined) // NaN
Number(null) // 0
Number函数和parseInt一样也会自动过滤一个字符串前导和后缀的空格。Number('\t\v\r12.34\n') // 12.34
Number()转换对象：
Number方法的参数是对象时，将返回NaN，除非是包含单个值的数组。Number([]) // 0
转换规则：
第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。
第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。
	如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。
第三步，如果toString方法返回的是对象，就报错。
默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，
而toString方法返回对象的类型字符串（比如[object Object]）。所以，Number({}) // NaN
如果toString方法返回的不是原始类型的值，结果就会报错。

String() 可以将任意类型的值转化成字符串：
转换原始类型：
String(123) // "123"
String('abc') // "abc"
String(true) // "true"
String(undefined) // "undefined"
String(null) // "null"
转换对象：
如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。
	String({a: 1}) // "[object Object]"
	String([1, 2, 3]) // "1,2,3"
	String([]) // ""
String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。
先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。
如果valueOf方法返回的是对象，就报错。
String({a: 1})
// "[object Object]"
// 等同于
String({a: 1}.toString())
// "[object Object]"

Boolean函数可以将任意类型的值转为布尔值。
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true，// new Boolean(new Boolean(false))//true

自动转换数据类型的三种场景：
第一种情况，不同类型的数据互相运算。123 + 'abc' // "123abc"
第二种情况，对非布尔值类型的数据求布尔值。
	if ('abc') {
	  console.log('hello')
	}  // "hello"
第三种情况，对非数值类型的值使用一元运算符（即+和-）。
	+ {foo: 'bar'} // NaN
	- [1, 2, 3] // NaN
自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。
比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。
通常不建议使用自动转换。

-----------------------------------------------------------------------------------------------------------
错误处理
JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。
	var err = new Error('出错了');
	err.message // "出错了"
JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。
大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
存在Error的6个派生对象：
1、SyntaxError 对象；
	// 变量名错误
	var 1a;
	// Uncaught SyntaxError: Invalid or unexpected token
2、ReferenceError 对象 
	ReferenceError对象是引用一个不存在的变量时发生的错误。另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。
	// 使用一个不存在的变量
	unknownVariable
	// Uncaught ReferenceError: unknownVariable is not defined
3、RangeError 对象 
	RangeError对象是一个值超出有效范围时发生的错误。
4、TypeError 对象
	TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令
5、URIError 对象
	URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()等
6、EvalError 对象
	eval函数没有被正确执行时，会抛出EvalError错误
自定义错误
	function UserError(message) {
	  this.message = message || '默认信息';
	  this.name = 'UserError';
	}

	UserError.prototype = new Error();
	UserError.prototype.constructor = UserError;
throw语句的作用是手动中断程序执行，抛出一个错误。实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。
JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。
try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。
	function cleansUp() {
	  try {
		throw new Error('出错了……');
		console.log('此行不会执行');
	  } finally {
		console.log('完成清理工作');
	  }
	}
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
Object 对象
JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。
Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。
所谓”本身的方法“就是直接定义在Object对象的方法。
所谓实例方法就是定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用。
Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。
如果参数为空（或者为undefined和null），Object()返回一个空对象。
var obj = Object(undefined);
var obj = Object(null);
obj instanceof Object // true
如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例
如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。
Object作为构造函数
用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，
如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象
Object本身的方法：
	Object.keys()，Object.getOwnPropertyNames()遍历对象的属性。
	Object.keys方法只返回可枚举的属性，Object.getOwnPropertyNames方法还返回不可枚举的属性名。
	Object.getPrototypeOf()：获取对象的Prototype对象。
Object实例对象的方法：
	Object.prototype.valueOf()：返回当前对象对应的值。
	Object.prototype.toString()：返回当前对象对应的字符串形式。
	Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
	Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
	Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
	Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
Object.prototype.toString可以看出一个值到底是什么类型：
	Object.prototype.toString.call(2) // "[object Number]"
	Object.prototype.toString.call('') // "[object String]"
	Object.prototype.toString.call(true) // "[object Boolean]"
	Object.prototype.toString.call(undefined) // "[object Undefined]"
	Object.prototype.toString.call(null) // "[object Null]"
	Object.prototype.toString.call(Math) // "[object Math]"
	Object.prototype.toString.call({}) // "[object Object]"
	Object.prototype.toString.call([]) // "[object Array]"
===========================================================================================================
属性描述对象
作为JavaScript提供的一种内部数据结构，属性描述对象用来描述对象的属性，控制对象属性的行为，比如该属性是否可写、可遍历等等。
每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。
属性描述对象提供6个元属性：
{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
Object.getOwnPropertyDescriptor方法可以获取属性描述对象。它接受两个参数，第一个参数是一个对象，第二个参数是对象的某个属性名。
	var obj = { p: 'a' };
	Object.getOwnPropertyDescriptor(obj, 'p')
	// Object { value: "a",
	//   writable: true,
	//   enumerable: true,
	//   configurable: true
	// }
Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性。
	Object.getOwnPropertyDescriptor(obj, 'toString')
	// undefined
Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。
	var obj = Object.defineProperties({}, {
	  p1: { value: 1, enumerable: true },
	  p2: { value: 2, enumerable: false }
	});
	Object.getOwnPropertyNames(obj);
	// ["p1","p2"]
Object.keys只返回对象自身的可遍历属性的全部属性名。

Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它接受三个参数，
	第一个是对象，第二个是要定义或修改的属性名，第三个是属性描述对象。
	var obj = Object.defineProperty({}, 'p', {
	  value: 123,
	  writable: false,
	  enumerable: true,
	  configurable: false
	});
var obj = {};这种普通方式创建的对象的属性的属性描述对象的默认值如下：value、get和set都是undefined，writable、enumerable和configurable都是true;
Object.defineProperty方法的第三个参数即属性描述对象writable、enumerable、configurable默认值都是false。
可以使用Object.defineProperties方法一次性定义或修改多个属性。
	var obj = Object.defineProperties({}, {
	  p1: { value: 123, enumerable: true },
	  p2: { value: 'abc', enumerable: true },
	  p3: { get: function () { return this.p1 + this.p2 },
		enumerable:true,
		configurable:true
	  }
	});
一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。

Object.prototype.propertyIsEnumerable() 
实例对象的propertyIsEnumerable方法返回一个布尔值，用来判断某个属性是否可遍历。
	var obj = {};
	obj.p = 123;

	obj.propertyIsEnumerable('p') // true
	obj.propertyIsEnumerable('toString') // false
属性描述对象的属性称为元属性：
value、writable、enumerable、configurable、set、get

正常模式下，对writable为false的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使对a属性重新赋予一个同样的值。
如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。
	var proto = Object.defineProperty({}, 'foo', {
	  value: 'a',
	  writable: false
	});

	var obj = Object.create(proto);

	obj.foo = 'b';
	obj.foo // 'a'
in运算符不管某个属性是对象自身的还是继承的，都会返回true。
如果一个属性的enumerable为false，下面三个操作不会取到该属性：
for..in循环
Object.keys方法
JSON.stringify方法

configurable和writable都为false，则value不允许修改；
configurable为false，writable不允许从false改为true，enumerable和configurable都不能再被修改。
configurable决定了目标属性是否可以被删除（delete）。

set和get是函数：
	var obj = Object.defineProperty({}, 'p', {
	  get: function () {
		return 'getter';
	  },
	  set: function (value) {
		console.log('setter: ' + value);
	  }
	});
另一种写法：
	var obj = {
	  get p() {
		return 'getter';
	  },
	  set p(value) {
		console.log('setter: ' + value);
	  }
	};
	obj.p();	//"getter"
get和set使得属性可以作为函数调用，被称为存取器，往往用于属性的值依赖对象内部数据的场合。

Object.preventExtensions方法可以使得一个对象无法再添加新的属性。
	var obj = new Object();
	Object.preventExtensions(obj);

	Object.defineProperty(obj, 'p', {
	  value: 'hello'
	});
	// TypeError: Cannot define property:p, object is not extensible.

	obj.p = 1;
	obj.p // undefined
Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。
Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。Object.seal只是禁止新增或删除属性，并不影响修改某个属性的值。
Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。
Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。
Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。
上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。
另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性所在的对象，而不能冻结属性指向的对象。
===================================================================================================
Array
	var arr = new Array(2);
	arr.length // 2
	arr // [ empty x 2 ]
	arr[0] // undefined
	0 in arr //false
Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。
如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。
静态方法Array.isArray方法可以识别数组。
数组的valueOf方法返回数组本身。	var arr = [1, 2, 3];  arr.valueOf() // [1, 2, 3]
数组的toString方法返回数组的字符串形式。var arr = [1, 2, 3];	arr.toString() // "1,2,3"
push和pop方法使得数组可以作为栈使用，对空数组使用pop方法，不会报错，而是返回undefined。
shift方法用于删除数组的第一个元素，并返回该元素。shift：移位；
push和shift结合使用，就构成了“先进先出”的队列结构（queue）。
unshift方法可以接受多个参数，这些参数都会添加到目标数组头部。
	var arr = [ 'c', 'd' ];
	arr.unshift('a', 'b') // 4
	arr // [ 'a', 'b', 'c', 'd' ]
join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。如果数组成员是undefined或null或空位，会被转成空字符串。
var a = [1, 2, 3, 4];	a.join(' | ') // "1 | 2 | 3 | 4"
通过call方法，这个方法也可以用于字符串或类似数组的对象。
	var obj = { 0: 'a', 1: 'b', length: 2 };
	Array.prototype.join.call(obj, '-')
	// 'a-b'
concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。
	['hello'].concat(['world'], ['!'])
	// ["hello", "world", "!"]
	[1, 2, 3].concat(4, 5, 6)
	// [1, 2, 3, 4, 5, 6]
如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。
reverse方法用于颠倒排列数组元素，返回改变后的数组。
slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。slice:切片
slice方法的一个重要应用，是将类似数组的对象转为真正的数组。
	Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
	// ['a', 'b']
splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。splice:铰接
sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。
	['d', 'c', 'b', 'a'].sort()
	// ['a', 'b', 'c', 'd']
传入函数自定义排序规则：
	[10111, 1101, 111].sort(function (a, b) {
	  return a - b;
	})
	// [111, 1101, 10111]
map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。
	[1, 2, 3].map(function(elem, index, arr) {
	  return elem * index;
	});
	// [0, 2, 6]
map方法还可以接受第二个参数，用来绑定回调函数内部的this变量
	var arr = ['a', 'b', 'c'];

	[1, 2].map(function (e) {
	  return this[e];
	}, arr)
	// ['b', 'c']
如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。
forEach方法不返回值，只用来操作数据。ie9才开始实现这个方法
	function log(element, index, array) {
	  console.log('[' + index + '] = ' + element);
	}

	[2, 5, 9].forEach(log);
filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。
	[1, 2, 3, 4, 5].filter(function (elem) {
	  return (elem > 3);
	})
	// [4, 5]
some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。
	var arr = [1, 2, 3, 4, 5];
	arr.some(function (elem, index, arr) {
	  return elem >= 3;
	});
	// true
	arr.every(function (elem, index, arr) {
	  return elem >= 3;
	});
	// false
注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。

reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。
	[1, 2, 3, 4, 5].reduce(function (a, b) {
	  console.log(a, b);
	  return a + b;
	})
	// 1 2
	// 3 3
	// 6 4
	// 10 5
	//最后结果：15

	[1, 2, 3, 4, 5].reduce(function (a, b) {
	  return a + b;
	}, 10);
	// 25

	function substract(prev, cur) {
	  return prev - cur;
	}
	[3, 2, 1].reduce(substract) // 0
	[3, 2, 1].reduceRight(substract) // -4
indexOf和lastIndexOf:	
var a = ['a', 'b', 'c'];
a.indexOf('b') // 1
['a', 'b', 'c'].indexOf('a', 1) // -1
 [2, 5, 9, 2].lastIndexOf(2) // 3
链式使用：
	var users = [
	  {name: 'tom', email: 'tom@example.com'},
	  {name: 'peter', email: 'peter@example.com'}
	];

	users
	.map(function (user) {
	  return user.email;
	})
	.filter(function (email) {
	  return /^t/.test(email);
	})
	.forEach(console.log);
	// "tom@example.com"
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
包装对象
Number、String、Boolean
这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；
作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。
原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。
'abc'.length // 3
自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。
var s = 'Hello World';
s.x = 123;
s.x // undefined
给包装对象添加方法和属性：
	String.prototype.double = function () {
	  return this.valueOf() + this.valueOf();
	};

	'abc'.double()
	// abcabc

	Number.prototype.double = function () {
	  return this.valueOf() + this.valueOf();
	};

	(123).double()  //括号不能少
	// 246
false对应的包装对象实例，布尔运算结果也是true。因为所有对象对应的布尔值都是true
	//作为工具方法使用：
	if (Boolean(false)) {
	  console.log('true');
	} // 无输出

	//作为构造函数使用
	if (new Boolean(false)) {
	  console.log('true');
	} // true
Number静态属性：
	POSITIVE_INFINITY	正无穷
	NEGATIVE_INFINITY	负无穷
	NaN					非数
	MAX_VALUE
	MIN_VALUE
	MAX_SAFE_INTEGER
	MIN_SAFE_INTEGER
实例方法：
	(10).toString() // "10"
	(10).toString(2) // "1010" 或
	10..toString(2)  // "1010" 或
	10 .toString(2)  // "1010" 或
	10.0.toString(2) // "1010" 或
	10['toString'](2) // "1010"
	toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误。
	10.005.toFixed(2) // "10.01"
	toExponential方法用于将一个数转为科学计数法形式。参数范围为0到20，超出这个范围，会抛出一个 RangeError 错误。
	(1234).toExponential()  // "1.234e+3"
	toPrecision方法用于将一个数转为指定位数的有效数字。用于四舍五入时不太可靠，跟浮点数不是精确储存有关。
	(12.34).toPrecision(3) // "12.3"
自定义方法：
	Number.prototype.add = function (x) {
	  return this + x;
	};

	8['add'](2) // 10

字符串对象：
字符串对象是一个类似数组的对象（很像数组，但不是数组）。
	new String('abc');			// String {0: "a", 1: "b", 2: "c", length: 3}
	(new String('abc'))[1] 		// "b"
作为工具函数使用：String(true)  // "true"
静态方法：
	String.fromCharCode() 	//该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）;对于大于65535的字符需要使用四个字节的UTF-16编码
		String.fromCharCode(97) // "a"
		String.fromCharCode(104, 101, 108, 108, 111)	// "hello"
		String.fromCharCode(0xD842, 0xDFB7)				// "𠮷"
实例属性：
	String.prototype.length
实例方法：
	String.prototype.charAt() 		'abcd'.charAt(1)或'abcd'[1]		//b返回的是字符串
	charCodeAt						'abc'.charCodeAt(1)     // 98	'abc'.charCodeAt(-1) // NaN
	concat							'abc'.concat('def')		//'abcdef'
	slice							'JavaScript'.slice(0, -6) // "Java"
	substring						'JavaScript'.substring(10, 4) // "Script"	// 等同于 'JavaScript'.substring(4, 10) // "Script"		'JavaScript'.substring(4, -3) // "Java" 
	substr							'JavaScript'.substr(4, 6) // "Script"
	indexOf和lastIndexOf
	trim
	toLowerCase和toUpperCase		它们都返回一个新字符串，不改变原字符串。
	match							'cat, bat, sat, fat'.match('at') // ["at"]		返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。
	search							返回匹配的第一个位置
	replace							'aaa'.replace('a', 'b') // "baa"
	split(分裂)							'a|b|c'.split('|') // ["a", "b", "c"]			'a|b|c'.split() // ["a|b|c"]
									如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符	'a|b|c'.split('') // ["a", "|", "b", "|", "c"]
	localeCompare					按自然语言的顺序比较，返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
									'B'.localeCompare('a') // 1

、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
Math对象
	静态属性：						Math.E	Math.PI等
	静态方法：						abs();sqrt();ceil();random()
	Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
		function getRandomArbitrary(min, max) {
			return Math.random() * (max - min) + min;
		}

		getRandomArbitrary(1.5, 6.5)
		// 2.4942810038223864

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
Date对象
Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。
Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。即使带有参数，Date作为普通函数使用时，返回的还是当前时间。
	Date(2000, 1, 1)返回当前时间
作为构造函数使用：
	var today = new Date();
	返回的是本地时间
	对Date对象求值时总是调用toString方法。
	参数可以是毫秒数（可为负值）、字符串、多个整数
		new Date(-1378218728000)	// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)
		new Date('January 6, 2013');
		new Date(2013, 0, 1, 0, 0, 0, 0)
	只要是能被Date.parse()方法解析的字符串，都可以当作参数。参数会被解释为当前时区的时间
	使用多个整数作参数时，至少需要两个参数，因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。月份从0开始计算
Date.parse
	日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析
Date.UTC 接受年、月、日等变量作为参数，返回毫秒值
	Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。
	Date实例对象的valueOf方法和getTime方法返回的都是本地时间对应的UTC时间和时间零点的毫秒差值：
	Date o = new Date(1970,0,1,0,0,0);
	o.valueOf();	//-28800000
	get*方法返回的都是当前时区的时间，getUTC*方法返回UTC时间
	o.getDate();	//1						o.getUTCDate();	//31
	o.getFullYear()	//1970						o.getUTCFullYear()	//1969
	toString返回本地时间，toUTCString和toISOString都返回UTC时间， toISOString返回ISO8601 写法：// "2012-12-31T16:00:00.000Z"
	toJSON和toISOString返回完全相同
显示本地时间格式：
Date.prototype.toLocaleString()：完整的本地时间。
Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。
Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。
可选项使用：dateObj.toLocaleString([locales[, options]])
d.toLocaleString('en-US') 

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
正则表达式对象
RegExp对象提供正则表示式的功能。JavaScript 的正则表达式体系是参照 Perl 5 建立的。
两种构造方式：
	var regex = /xyz/;					//引擎编译代码时，就会新建正则表达式
	var regex = new RegExp('xyz'); 		//运行时新建正则表达式
带修饰符：
	var regex = new RegExp('xyz', 'i');
	// 等价于
	var regex = /xyz/i;
实例属性：
	ignoreCase、global、multiline	返回布尔值，表示是否设置了对应修饰符
	lastIndex  返回一个整数，表示下一次开始搜索的位置。该属性可读写
	source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
实例方法：
	test：返回一个布尔值，表示当前模式是否能匹配参数字符串。	/cat/.test('cats and dogs') // true
如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。
注意，带有g修饰符时，正则表达式内部会记住上一次的lastIndex属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。
	var r = /bb/g;
	r.test('bb') // true
	r.test('-bb-') // false 
如果正则模式是一个空字符串，则匹配所有字符串。
	exec：返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。 /x/.exec('_x_x')	  //["x"]
	var s = '_x_x';
	var r = /_(x)/;
	r.exec(s) // ["_x", "x"]
exec方法的返回数组还包含以下两个属性：input、index
	var reg = /a/g;
	var str = 'abc_abc_abc'

	while(true) {
	  var match = reg.exec(str);
	  if (!match) break;
	  console.log('#' + match.index + ':' + match[0]);
	}
	// #0:a
	// #4:a
	// #8:a
字符串实例对象与正则表达式相关的四个方法：
match：正则匹配，返回匹配结果。		
	'_x_x'.match(/x/);		//["x"]
	'_x_x'.match(/x/g);		//["x","x"]
设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。	
search：返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。
	'_x_x'.search(/x/)		// 1
replace：替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。返回替换后的字符串，不修改原字符串
	'aaa'.replace(/a/g, 'b') // "bbb"
replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。
	'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
	// "world hello"
	'abc'.replace('b', '[$`-$&-$\']')
	//"a[a-b-c]c"
$&：匹配的子字符串。
$`：匹配结果前面的文本。
$'：匹配结果后面的文本。
$n：匹配成功的第n组内容，n是从1开始的自然数。
：指代美元符号`$`。	
	replace方法的第二个参数还可以是函数：
	var prices = {
	  'p1': '$1.99',
	  'p2': '$9.99',
	  'p3': '$5.00'
	};

	var template = '<span id="p1"></span>'
	  + '<span id="p2"></span>'
	  + '<span id="p3"></span>';

	template.replace(
	  /(<span id=")(.*?)(">)(<\/span>)/g,
	  function(match, $1, $2, $3, $4){
		return $1 + $2 + $3 + prices[$2] + $4;
	  }
	);
	// "<span id="p1">$1.99</span><span id="p2">$9.99</span><span id="p3">$5.00</span>"	
split：按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。
	'a,  b,c, d'.split(/, */, 2)
	[ 'a', 'b' ]
字面量字符和元字符
元字符：
点号（.）：	匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
^ 			表示字符串的开始位置
$ 			表示字符串的结束位置
竖线符号（|）：	在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。
脱字符^:	[^xyz]表示除了x、y、z之外都可以匹配。
连字符-：	[A-Z]表示26个大写字母。
预定义模式：
	\d 匹配0-9之间的任一数字，相当于[0-9]
	\D 匹配所有0-9以外的字符，相当于[^0-9]。
	\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
	\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
	\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。
	\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。
	\b 匹配词的边界。
	\B 匹配非词边界，即在词的内部。
	[\S\s]可以用来指代一切字符
量词符：
	? 问号表示某个模式出现0次或1次，等同于{0, 1}。
	* 星号表示某个模式出现0次或多次，等同于{0,}。
	+ 加号表示某个模式出现1次或多次，等同于{1,}。
贪婪模式：
	var s = 'aaa';
	s.match(/a+/) // ["aaa"]
非贪婪模式：
	var s = 'aaa';
	s.match(/a+?/) // ["a"]
m修饰符：
	m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，
	加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。
	/world$/.test('hello world\n') // false
	/world$/m.test('hello world\n') // true
	/^b/m.test('a\nb') // true
组匹配：
	var m = 'abcabc'.match(/(.)b(.)/);
	m
	// ['abc', 'a', 'c']
使用/i代表匹配组：
	/(.)b(.)\1b\2/.test("abcabc")
	// true
(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。
	var m = 'abc'.match(/(?:.)b(.)/);
	m // ["abc", "c"]
x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。
	var m = 'abc'.match(/b(?=c)/);
	m // ["b"]																
x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。
	/\d+(?!\.)/.exec('3.14')
	// ["14"]  小数点前的都不匹配，小数点不返回
---------------------------------------------------------------------------------------------------------
JSON
JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式
每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值
JSON的格式要求：
	复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。

	原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。

	字符串必须使用双引号表示，不能使用单引号。

	对象的键名必须放在双引号里面。

	数组或对象最后一个成员的后面，不能加逗号。
	
	属性值不能使用函数和日期对象
JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。
静态方法：
stringify：将一个值转为 JSON 格式的值（JSON字符串）：
	JSON.stringify('abc') // ""abc""
	JSON.stringify([1, "false", false])	// '[1,"false",false]'
	JSON.stringify({ name: "张三" })	// '{"name":"张三"}'
	JSON.stringify('foo') === "\"foo\"" // true
如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。
如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。
正则对象会被转成空对象。
JSON.stringify方法会忽略对象的不可遍历的属性。
JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。
JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；
	如果是字符串（不超过10个字符），则该字符串会添加在每行前面。
如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。

JSON.parse方法用于将 JSON 字符串转换成对应的值。
JSON.parse('[1, 5, "false"]') // [1, 5, "false"]
var o = JSON.parse('{"name": "张三"}');
传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。
JSON.parse("'String'") // illegal single quotes

++++++++++++++++++++++++++++++++++++==++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

JavaScript面向对象编程模型

对象是单个实物的抽象。对象是一个容器，封装了属性（property）和方法（method）。

典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。
但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。
JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。
构造函数的特点有两个：
	函数体内部使用了this关键字，代表了所要生成的对象实例。
	生成对象的时候，必须使用new命令。
如果不使用new命令调用构造函数，构造函数就变成了普通函数，并不会生成实例对象。
而且，this这时代表全局对象，将造成一些意想不到的结果。
构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。
严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript 不允许对undefined添加属性）。

使用new命令时，它后面的函数依次执行下面的步骤:
	创建一个空对象，作为将要返回的对象实例。
	将这个空对象的原型，指向构造函数的prototype属性。
	将这个空对象赋值给函数内部的this关键字。
	开始执行构造函数内部的代码。
如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。
如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。
如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。
函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。
以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。

-----------------------------======----------------------------------=========---------------------------------------

this
简单说，this就是属性或方法“当前”所在的对象。
由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。
	var A = {
	  name: '张三',
	  describe: function () {
		return '姓名：'+ this.name;
	  }
	};

	var B = {
	  name: '李四'
	};

	B.describe = A.describe;
	B.describe()
	// "姓名：李四"
原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。
当属性值是一个函数时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给对象属性的value属性。
由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。
this的设计目的就是在函数体内部，指代函数当前的运行环境。
this的使用场景：
1、全局环境使用this，它指的就是顶层对象window。
2、构造函数中的this，指的是实例对象。
3、如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。
	var obj ={
	  foo: function () {
		console.log(this);
	  }
	};

	obj.foo() // obj
	// 情况一
	(obj.foo = obj.foo)() // window
	// 情况二
	(false || obj.foo)() // window
	// 情况三
	(1, obj.foo)() // window
以上三种情况都返回foo函数，然后在全局环境中调用。
严格模式下，如果函数内部的this指向顶层对象，就会报错。
使用变量固定this指向：
	var o = {
	  f1: function() {
		console.log(this);
		var that = this;
		var f2 = function() {
		  console.log(that);
		}();
	  }
	}

	o.f1()
	// Object
	// Object
数组处理方法中this的误用：
	var o = {
	  v: 'hello',
	  p: [ 'a1', 'a2' ],
	  f: function f() {
		this.p.forEach(function (item) {
		  console.log(this.v + ' ' + item);
		});
	  }
	}

	o.f()
	// undefined a1
	// undefined a2
两种正确的处理方式是：使用变量固定this指向或将this作为第二个参数传入数组处理方法（forEach、map）
回调函数中this的误用：
	var o = new Object();
	o.f = function () {
	  console.log(this === o);
	}

	// jQuery 的写法
	$('#button').on('click', o.f);
上面只是将f函数绑定到了click事件，点击将打印false
绑定this到指定对象：
1、函数实例的call方法：
	var obj = {};

	var f = function () {
	  return this;
	};

	f() === window // true
	f.call(obj) === obj // true
call方法将函数体中的this固定为传入的参数对象，然后执行该函数；
call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。
如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。
call方法还可以接受多个参数。call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。
使用call调用原生方法：
	var obj = {};
	obj.hasOwnProperty('toString') // false

	// 覆盖掉继承的 hasOwnProperty 方法
	obj.hasOwnProperty = function () {
	  return true;
	};
	obj.hasOwnProperty('toString') // true

	Object.prototype.hasOwnProperty.call(obj, 'toString') // false
2、函数实例的apply方法，与call方法类似，区别是apply方法接收一个数组作为函数执行时的参数，和call方法一样，apply也是立即执行的方法。
	function f(x, y){
	  console.log(x + y);
	}

	f.call(null, 1, 1) // 2
	f.apply(null, [1, 1]) // 2
调用数组构造函数：
	Array.apply(null, ['a', ,'b'])
	// [ 'a', undefined, 'b' ]
使用数组的slice方法转换对象为数组：被处理的对象必须有length属性，以及相对应的数字键。
	Array.prototype.slice.apply({0: 1, length: 1}) // [1]
3、bind方法：
bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。
	var d = new Date();
	d.getTime() // 1481869925657

	var print = d.getTime;
	print() // Uncaught TypeError: this is not a Date object.
将日期对象的getTime方法单独拿出来后，调用它就找不到上下文导致报错。
使用bind解决这个问题：
	var print = d.getTime.bind(d);
	print() // 1481869925657
this绑定到其他对象也是可以的：
	var counter = {
	  count: 0,
	  inc: function () {
		this.count++;
	  }
	};

	var obj = {
	  count: 100
	};
	var func = counter.inc.bind(obj);
	func();
	obj.count // 101
bind还可以接受更多的参数，将这些参数绑定原函数的参数。
	var add = function (x, y) {
	  return x * this.m + y * this.n;
	}

	var obj = {
	  m: 2,
	  n: 2
	};

	var newAdd = add.bind(obj, 5);
	newAdd(5) // 20
bind方法每运行一次，就返回一个新函数，这会产生一些问题：
	element.addEventListener('click', o.m.bind(o));
	element.removeEventListener('click', o.m.bind(o));//无效
click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定
bind和call的结合使用（麻烦）：
	Array.prototype.slice.call([1, 2, 3], 0, 1) // [1]
	//解释1：对[1,2,3]应用slice方法，参数是0,1
	//解释2：将slice的上下文替换为[1,2,3]并立即调用
call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。
	var slice = Function.prototype.call.bind(Array.prototype.slice);
	slice([1, 2, 3], 0, 1) // [1]
	//返回一个call方法的拷贝，其上下文是slice，对该方法（call）的调用，实际是对call所属函数实例的调用
	var push = Function.prototype.call.bind(Array.prototype.push);
	var pop = Function.prototype.call.bind(Array.prototype.pop);

	var a = [1 ,2 ,3];
	push(a, 4)
	a // [1, 2, 3, 4]

	pop(a)
	a // [1, 2, 3]
将call的上下文修改为bind
	function f() {
	  console.log(this.v);
	}

	var o = { v: 123 };
	var bind = Function.prototype.call.bind(Function.prototype.bind);
	bind(f, o)() // 123
1、call的上下文（函数体中的this）是一个函数实例，
2、xxx.call(obj,arg1...);
	将xxx的上下文替换为obj，arg1...是参数列表；xxx是函数实例；call的上下文是xxx；对 call 的调用实际是对xxx的调用；
3、var callx = Function.prototype.call.bind(xxx);
   callx(obj,arg1...);
    callx的上下文是xxx；调用callx实际是调用callx的上下文xxx，且xxx的上下文被设置为obj，arg1...是参数；
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
原型和原型链
	function Cat(name, color) {
	  this.name = name;
	  this.color = color;
	  this.meow = function () {
		console.log('喵喵');
	  };
	}

	var cat1 = new Cat('大毛', '白色');
	var cat2 = new Cat('二毛', '黑色');

	cat1.meow === cat2.meow
	// false
上面的代码，两个对象实例的meow方法互相独立，但方法实际是一样的，完全不需要产生两个，这样的重复方法浪费了系统资源。这和js的解释执行模型有关。
JavaScript设计了原型对象，其所有属性和方法，都能被实例对象共享
JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。
对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。
（实例对象会获得原型对象上的属性，但是获得的属性不是直接属于实例对象）
原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。
	Animal.prototype.color = 'yellow';
	cat1.color // "yellow"
	cat2.color // "yellow"

JavaScript 规定，所有对象都有自己的原型对象（prototype），但是实例对象不能通过obj.prototype访问自己的原型对象。
Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。
读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。
如果直到最顶层的Object.prototype还是找不到，则返回undefined。
	var MyArray = function () {};

	MyArray.prototype = new Array();
	MyArray.prototype.constructor = MyArray;

	var mine = new MyArray();
	mine.push(1, 2, 3);
	mine.length // 3
	mine instanceof Array // true
实例对象应该是获得了它的原型对象（原型链上的所有对象）的属性和方法的地址引用。
prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。
constructor的用法：
	function Constr() {}
	var x = new Constr();

	var y = new x.constructor();
	y instanceof Constr // true
instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。
	v instanceof Vehicle
	// 等同于
	Vehicle.prototype.isPrototypeOf(v)
	
	var d = new Date();
	d instanceof Date // true
	d instanceof Object // true
//d的原型链上含有Date和Object的原型对象
	Object.create(null) instanceof Object // false
//Object.create(null)返回的对象的原型链上只有null，没有Object的原型对象
对于undefined和null，instanceOf运算符总是返回false。instanceof运算符只能用于对象，不适用原始类型的值。

继承构造函数：
	function Super() {
	  this.x = 0;
	  this.y = 0;
	}
	function Sub(value) {
	  Super.call(this);
	  this.prop = value;
	}
	Sub.prototype = Object.create(Super.prototype);
	Sub.prototype.constructor = Sub;
Super.call(this);将Super构造函数中的this修改为当前的子类实例对象。
这种写法子类对象实例将直接获得父类构造函数中定义的属性，而不是出现在其原型上，其原型上的属性和方法只有父类构造方法的原型链上的属性和方法。
另一种写法：
	Sub.prototype = new Super();
这种写法子类对象实例继承父类的属性出现在其原型对象上，不直接属于子类实例。
子类方法中使用父类方法：
	ClassB.prototype.print = function() {
	  ClassA.prototype.print.call(this);
	  // some code
	}
完全多重继承：
function M1() {
  this.hello = 'hello';
}

function M2() {
  this.world = 'world';
}

function S() {
  M1.call(this);
  M2.call(this);
}
// 继承 M1
S.prototype = Object.create(M1.prototype);
// 继承链上加入 M2
Object.assign(S.prototype, M2.prototype);  //Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

// 指定构造函数
S.prototype.constructor = S;

var s = new S();
s.hello // 'hello'
s.world // 'world'
-------------------------------
function StringBuilder() {
  var buffer = [];
}
//这种方式定义的变量不属于实例对象，无法通过实例变量访问，实际上，构造函数外部无法访问该变量。
这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。
这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则
（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。

使用立即执行函数实现模块化：
	var module1 = (function () {
	　var _count = 0;
	　var m1 = function () {
	　  //...
	　};
	　var m2 = function () {
	　　//...
	　};
	　return {
	　　m1 : m1,
	　　m2 : m2
	　};
	})();
放大模式：
	var module1 = (function (mod){
	　mod.m3 = function () {
	　　//...
	　};
	　return mod;
	})(module1);
宽放大模式：可以避免加载了空对象报错
	var module1 = (function (mod) {
	　//...
	　return mod;
	})(window.module1 || {});
独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
为了在模块内部调用全局变量，必须显式地将其他变量输入模块。
var module1 = (function ($, YAHOO) {
　//...
})(jQuery, YAHOO);

立即执行函数还可以起到命名空间的作用，对外暴露接口：
	(function($, window, document) {

	  function go(num) {
	  }

	  function handleEvents() {
	  }

	  function initialize() {
	  }

	  function dieCarouselDie() {
	  }

	  //attach to the global scope
	  window.finalCarousel = {
		init : initialize,
		destroy : dieCouraselDie
	  }

	})( jQuery, window, document );
构造函数本身也是一个对象，可以有自己的属性（如prototype）和方法（静态方法）。

构造函数可以直接获得自己的原型对象（如Array.prototype），实例对象需要使用Object的静态方法获取自己的原型对象：Object.getPrototypeOf(obj);
构造函数不能直接调用自己原型对象上的实例方法。
对象的属性方法分类：
	1、构造函数中定义的属于对象实例的属性方法，
	2、构造函数的原型对象自己定义的属性方法，（这两类属性方法都只能通过构造函数创建的实例对象使用）
	3、构造函数定义在自己上面的静态属性方法，
	4、构造函数的原型对象继承的属性方法，（这两类属性方法都是构造函数作为对象可以使用的属性方法）

=======================================================================================================================
Object的静态方法
Object.getPrototypeOf(obj)用于获取一个对象的原型对象
Object.setPrototypeOf(obj,proto)用于为一个对象设置原型对象
	var f = new F();
	// 等同于
	var f = Object.setPrototypeOf({}, F.prototype);
	F.call(f);
Object.create(proto)用于使用一个给定对象作为原型构造一个对象；
	var obj = Object.create(null);obj不具有任何属性和方法
Object.create方法生成的对象，继承了它的原型对象的构造函数。
	function A() {}
	var a = new A();
	var b = Object.create(a);

	b.constructor === A // true
	b instanceof A // true
Object.getOwnPropertyNames()返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。
Object.keys(keys)获取对象可以遍历的属性数组
	
Object的原型对象上的方法：（任何对象都具有改类方法）
Object.prototype.isPrototypeOf()用来判断该对象是否为参数对象的原型。
Object.prototype.__proto__（属性）返回该对象的原型。
该属性可读写。根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。
获取实例对象obj的原型对象，有三种方法：
	obj.__proto__
	obj.constructor.prototype
	Object.getPrototypeOf(obj)
前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。
Object.prototype.hasOwnProperty()用于判断某个属性定义在对象自身，还是定义在原型链上。
与之相对应的in运算符则只判断对象是否具有某个属性。
获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for...in循环。
如果要拷贝一个对象，需要做到下面两件事情：

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
严格模式
早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。
明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。
增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
提高编译器效率，增加运行速度。
为未来新版本的 JavaScript 语法做好铺垫。
进入严格模式的标志，是一行字符串use strict。 
'use strict';需要放在脚本第一行或者函数内第一行。严格地说，只要前面不是产生实际运行结果的语句，use strict可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。
严格模式提供了更多的显示报错；比如写只读属性、写只设置了取值器的属性、扩展禁止扩展的对象
严格模式下，使用eval或者arguments作为标识名，将会报错；函数不能有重名的参数；禁止八进制的前缀0表示法
安全性增强：
正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。
正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。
严格模式下，函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。
严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。
严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。
严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了
严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。
为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。
严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。

=======================================================================================================================
异步编程
单线程模型：JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。事实上，JavaScript 引擎有多个线程，
单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合（不运行脚本）。单线程的优势是简单，问题在于耗时任务会阻塞后续任务，JavaScript设计时
考虑到这一点，采用了“事件循环”机制来应对，具体来说就是将耗时的CPU等待任务挂起（通常是IO操作），直接执行后续任务，当IO操作完成后再继续执行原来的任务。
HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。
同步执行：同步执行是指一个任务必须执行完成才会进入下一个任务，例如一个以同步方式获取网络数据的任务，必须等待网络请求返回后才继续执行下一个任务，等待网络
响应请求期间CPU实际没有使用。
异步执行：当启动（调用）一个异步任务后，该任务就进入一个异步任务队列，这些异步任务不需要CPU操作直到相应其他操作完成，主线程将直接进入下一个任务。主线程执行完所有
同步任务后，当任务队列有任务需要再次执行CPU操作时该任务就会再次进入主线程。
任务队列：实际上，根据异步任务的类型，存在多个任务队列。异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。
事件循环：JavaScript引擎（子线程）不停地检查（标记）任务队列，当同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。
回调函数模式：
	function f1(callback) {
	  // ...
	  callback();
	}

	function f2() {
	  // ...
	}

	f1(f2);
回调函数的缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪
事件监听模式：
	f1.on('done', f2);
	function f1() {
		// ...
		f1.trigger('done');
	}
事件监听的缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。
发布/订阅（观察者模式）
	jQuery.subscribe('done', f2);
	function f1() {
		// ...
		jQuery.publish('done');
	}
	f2(){
		//...
		jQuery.unsubscribe('done', f2);
	}
这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。
异步操作流程控制：
1、使用流程控制函数串行执行异步任务
2、使用流程控制函数并行执行异步任务
3、串行与并行结合
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
定时器
setTimeout(): 指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。
var timerId = setTimeout(func|code, delay);
除了前两个参数，setTimeout还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。
	setTimeout(function (a,b) {
	  console.log(a + b);
	}, 1000, 1, 1);
如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象
setInterval(): 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。
setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。
比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，
比如需要105毫秒，那么它结束后，下一次执行就会立即开始。
setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。
setTimeout和setInterval返回的整数值是连续的，也就是说，第二个setTimeout方法返回的整数值，将比第一个的整数值大1。
setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。
	setTimeout(someTask, 100);
	veryLongTask();
上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面的veryLongTask函数（同步任务）运行时间非常长，过了100毫秒还无法结束，
那么被推迟运行的someTask就只有等着，等到veryLongTask运行结束，才轮到它执行。生效后setInterval不会产生累积效应，只会执行一次
setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f，而是在下一轮事件循环一开始就执行
用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。
setTimeout(f, 0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被分为几个小部分，分别放到setTimeout(f, 0)里面执行。
-------------------------------------------------------------------------------------------------------------------------
Promise 对象
Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。
首先，Promise 是一个对象，也是一个构造函数
	function f1(resolve, reject) {
	  // 异步代码...
	}

	var p1 = new Promise(f1);  //返回Promise实例时就开始执行f1函数
Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。Promise实例可以看成参数函数的代理。
Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态：异步操作未完成（pending）、异步操作成功（fulfilled）、异步操作失败（rejected）。
fulfilled和rejected合在一起称为resolved（已定型）。状态变化：从“未完成”到“成功”、从“未完成”到“失败”
异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。
异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。
Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。
函数内自己处理执行结果：(使用resolve和reject将执行结果通知给promise的回调函数)
	var promise = new Promise(function (resolve, reject) {
	  // ...

	  if (/* 异步操作成功 */){
		resolve(value);
	  } else { /* 异步操作失败 */
		reject(new Error());
	  }
	});
Promise 实例的then方法，用来添加回调函数。
then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。
var p1 = new Promise(function (resolve, reject) {
  resolve('成功');
});
p1.then(console.log, console.error);或
p1.then(function(resp){
	...
}).catch(function(e){
	...
});
返回P1实例时异步函数已经开始执行了，执行结果将被传递给then方法的参数
Promise 的回调函数属于异步任务，会在同步任务之后执行。
但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。
这意味着，微任务的执行时间一定早于正常任务。

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
DOM
DOM：文档对象模型，是一个接口规范，规定了将结构化文档构造(抽象)成一个什么样的对象，提供什么样的对外接口。浏览器会根据 DOM 模型，
将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。
DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务。
DOM定义的最小对象单元是节点，一个文档的所有节点联系在一起的总体叫DOM树。节点的类型有7种：
Document、DocumentType(比如<!DOCTYPE html>)、Element、Attribute、Text、Comment、DocumentFragment
浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法
浏览器原生提供document节点，代表整个文档。文档的第一层只有一个节点，就是 HTML 网页的第一个标签<html>，它构成了树结构的根节点（root node），
其他 HTML 标签节点都是它的下级节点。
除了根节点，其他节点都有三种层级关系：父节点关系、子节点关系、同级节点关系
DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括firstChild（第一个子节点）和lastChild（最后一个子节点）等属性，
同级节点接口包括nextSibling（紧邻在后的那个同级节点）和previousSibling（紧邻在前的那个同级节点）属性
=============================================================================================================================================
Node 接口
属性：
Node.prototype.nodeType     返回一个整数值，表示节点的类型。  document.nodeType // 9  Node 对象定义了几个常量，对应这些类型值。Node.DOCUMENT_NODE //9
Node.prototype.nodeName     返回节点的名称。元素节点（element）返回大写的标签名
Node.prototype.nodeValue    返回一个字符串，表示当前节点本身的文本值，该属性可读写。div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。
Node.prototype.textContent  返回当前节点和它的所有后代节点的文本内容，该属性是可读写的。会自动忽略当前节点内部的 HTML 标签，返回所有文本内容。
							document.getElementById('foo').textContent = '<p>GoodBye!</p>';这里<p>标签解释为文本，而不会当作标签处理。文档节点和文档类型节点的textContent属性为null
Node.prototype.baseURI      返回一个字符串，表示当前网页的绝对路径。可以使用 HTML 的<base>标签，改变该属性的值。
Node.prototype.ownerDocument    返回当前节点所在的顶层文档对象，即document对象。document对象本身的ownerDocument属性，返回null。
Node.prototype.nextSibling      返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。该属性还包括文本节点和注释节点
Node.prototype.previousSibling  返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。该属性还包括文本节点和注释节点
Node.prototype.parentNode       返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点。
								文档节点（document）和文档片段节点（documentfragment）的父节点都是null
Node.prototype.parentElement    返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。父节点只可能是三种类型：
								元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。
Node.prototype.firstChild		返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null，如果父元素与子元素之间有空白字符，这导致firstChild返回的是文本节点。
Node.prototype.lastChild		返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null
Node.prototype.childNodes		返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。文档节点就有两个子节点：文档类型节点docType和 HTML根元素节点。
Node.prototype.isConnected		返回一个布尔值，表示当前节点是否在文档之中。
方法：
Node.prototype.appendChild()		接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。
									如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。
									如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。
Node.prototype.hasChildNodes()		返回一个布尔值，表示当前节点是否有子节点。子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，hasChildNodes方法也会返回true。
Node.prototype.cloneNode()			克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点，会丧失addEventListener方法和on-属性
Node.prototype.insertBefore() 		用于将某个节点插入父节点内部的指定位置。如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。
									如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。
不存在insertAfter方法，可以使用parent.insertBefore(s1, s2.nextSibling);实现该功能。
Node.prototype.removeChild()		接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。
Node.prototype.replaceChild()		用于将一个新的节点，替换当前节点的某一个子节点。var replacedNode = parentNode.replaceChild(newChild, oldChild);
Node.prototype.contains()			返回一个布尔值，表示参数节点是否满足以下三个条件之一。参数节点为当前节点；参数节点为当前节点的子节点；参数节点为当前节点的后代节点。
Node.prototype.compareDocumentPosition() 返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。0表示两个节点相同；16表示当前节点包含参数节点；8表示参数节点包含当前节点
Node.prototype.isEqualNode()		返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。
Node.prototype.isSameNode()			返回一个布尔值，表示两个节点是否为同一个节点。
Node.prototype.normalize() 			清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。
Node.prototype.getRootNode()		返回当前节点所在文档的根节点，与ownerDocument属性的作用相同。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
DOM 提供两种节点集合，用于容纳多个节点：NodeList和HTMLCollection。许多 DOM 属性和方法，返回的结果是NodeList实例或HTMLCollection实例。
主要区别是，NodeList可以包含各种类型的节点，HTMLCollection只能包含 HTML 元素节点。
NodeList 接口
NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。
	Node.childNodes			//var children = document.body.childNodes; children instanceof NodeList // true  Array.isArray(children) // false
	document.querySelectorAll()等节点搜索方法
NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。
目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合。
NodeList 实例children不是数组，但是具有length属性和forEach方法。使用var nodeArr = Array.prototype.slice.call(children);将NodeList实例转换为（构造新的）数组
这个接口的实例在ie和Chrome下表现不太一样，在ie下不能使用forEach方法，而Chrome却可以。
NodeList 实例有一个item方法，参数为索引下标，实际用途和[]一样，通常直接使用[]而不使用item方法
NodeList 实例提供keys()方法返回子元素索引的遍历器，提供values()方法返回所有子元素的遍历器，entries()方法返回索引和子元素键值对的遍历器，可以通过for...of循环遍历器获取每一个成员的信息
	var children = document.body.childNodes;
	for (var entry of children.entries()) {
		console.log(entry);
	}
	// Array [ 0, #text ]
	...

HTMLCollection 接口
HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。HTMLCollection没有forEach方法，只能使用for循环遍历。
返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如document.links、docuement.forms、document.images等。
HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。
可以直接使用原生的id或name属性获取元素：var lik = document.links.lnkBlogLogo //<a id="lnkBlogLogo" href="https://www.cnblogs.com/penghongwei/">aaa</a>
也可以使用namedItem(idName)方法通过id或name获取子元素，item(i)方法和[]用法相同。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ParentNode接口 和 ChildNode接口
如果当前节点是父节点，就会继承ParentNode接口。
只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，会继承ParentNode接口。
属性：
	children 返回一个HTMLCollection实例，成员是当前节点的所有元素子节点，如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。
	firstElementChild 返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。document.firstElementChild.nodeName // "HTML"
	lastElementChild  返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。
	childElementCount  返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。
方法：
	append() 当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面，没有返回值。
	prepend() 为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面，也是没有返回值。

如果一个节点有父节点，那么该节点就继承了ChildNode接口。
方法：
	remove() 从父节点移除当前节点。
	before() 在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。
	after() 在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点
	replaceWith() 使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。
========================================================================================================================================================
document对象
document节点对象代表整个文档，继承了EventTarget接口、Node接口、ParentNode接口。
document对象有不同的办法可以获取：
	正常的网页，直接使用document或window.document。
	iframe框架里面的网页，使用iframe节点的contentDocument属性。
	Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。
	内部节点的ownerDocument属性。
属性：
	defaultView 返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。
	doctype 对于HTML文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向<DOCTYPE>节点，
即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成<!DOCTYPE html>。
如果网页没有声明 DTD，该属性返回null。
	documentElement 返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，
紧跟在document.doctype节点后面。HTML网页的该属性，一般是<html>节点。
	document.body属性指向<body>节点，document.head属性指向<head>节点。这两个属性总是存在的，
如果网页源码里面省略了<head>或<body>，浏览器会自动创建。另外，这两个属性是可写的
	scrollingElement 返回文档的滚动元素，标准模式下，这个属性返回的文档的根元素document.documentElement（即<html>）。
兼容（quirk）模式下，返回的是<body>元素，如果该元素不存在，返回null。
	activeElement 返回获得当前焦点（focus）的 DOM 元素。
通常，这个属性返回的是<input>、<textarea>、<select>等表单元素，如果当前没有焦点元素，返回<body>元素或null。
	fullscreenElement 返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。chrome没有提供
节点集合属性：
	links 返回当前文档所有设定了href属性的<a>及<area>节点。
	forms 返回所有<form>表单节点。如果页面没有form表单元素，返回的HTMLCollection实例length为0.
除了使用位置序号，id属性和name属性也可以用来引用表单。document.forms[0] === document.forms.foo
	images 返回页面所有<img>图片节点。
	document.embeds属性和document.plugins属性，都返回所有<embed>节点。
	scripts属性返回所有<script>节点。
	styleSheets属性返回文档内嵌或引入的样式表集合
	除了document.styleSheets，以上的集合属性返回的都是HTMLCollection实例。
文档静态信息属性：
	document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，
documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。
	domain属性返回当前文档的域名，不包含协议和端口。
	document.location 返回浏览器提供的原生对象Location
	lastModified属性返回一个字符串，表示当前文档最后修改的时间。如果页面上有 JavaScript 生成的内容，
document.lastModified属性返回的总是当前时间。
	title属性返回当前文档的标题。默认情况下，返回<title>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。
	characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。
	referrer属性返回一个字符串，表示当前文档的访问者来自哪里。上一步所在的位置（超链接源位置），
如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。
	dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；
ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。chrome直接返回空字符串
	compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。
一般来说，如果网页代码的第一行设置了明确的DOCTYPE（比如<!doctype html>），document.compatMode的值都为CSS1Compat。
文档状态属性：
	hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，
使得document.hidden返回true。
	visibilityState返回文档的可见状态："visible"--页面可见 "hidden"--页面不可见 "prerender"==页面处于正在渲染状态，
对于用户来说，该页面不可见 "unloaded"--页面从内存里面卸载了。
	readyState属性返回当前文档的状态: "loading"--加载 HTML 代码阶段（尚未完成解析） "interactive"--加载外部资源阶段
"complete"--加载完成 浏览器解析文档元素完成后readyState属性从loading变为interactive，当图片、样式表等外部资源加载完成
readyState属性从interactive变为complete
	cookie属性用来操作浏览器 Cookie
	designMode属性控制当前文档是否可编辑。该属性只有两个值on和off，默认值为off。一旦设为on，用户就可以编辑整个文档的内容。
	implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。
createDocument()：创建一个 XML 文档。createHTMLDocument()：创建一个 HTML 文档。createDocumentType()：创建一个 DocumentType 对象。
方法：
	open()清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。
	close()关闭document.open()打开的文档。
	write()用于向当前文档写入内容。首次渲染时没有执行document.close()前，document.write写入的内容就会追加在已有
内容的后面。
	document.write会当作 HTML 代码解析，不会转义。document.write('<p>hello world</p>');<p>当作 HTML 标签解释。
如果页面已经解析完成（DOMContentLoaded事件发生之后），再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。
如果在页面渲染过程中调用write方法，并不会自动调用open方法。可以看出是此时页面已经open，但没有close，所以可以直接write
write是 JavaScript 语言标准化之前就存在的方法，现在通常不再使用，而是使用innerHTML属性或其他方法代替
	writeln方法与write方法完全一致，除了会在输出内容的尾部添加换行符。writeln方法添加的是 ASCII 码的换行符，
渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<br>。
	querySelector()接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，
则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。
	querySelectorAll() 用法和querySelector()类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。
	这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。
	它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。
	querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。
另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。
	这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。
	getElementsByTagName()搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个HTMLCollection实例，
可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。getElementsByTagName方法也是大小写不敏感的
如果传入*，就可以返回文档中所有 HTML 元素。元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。
	getElementsByClassName()返回一个HTMLCollection实例,包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。
参数是多个class时，它们之间使用空格分隔，表示同时含有这些class属性。正常模式下，CSS 的class是大小写敏感的。
任何元素节点都具有getElementsByClassName方法。
	getElementsByName()用于选择拥有name属性的 HTML 元素（比如<form>、<radio>、<img>、<frame>、<embed>和<object>等），
返回一个NodeList实例
	getElementById()返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。参数是大小写敏感的
document.getElementById('myElement') //元素id
document.querySelector('#myElement') //CSS语法
document.getElementById()比document.querySelector()效率高得多。
	elementFromPoint()返回位于页面指定位置最上层的元素节点
	elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。
	document.caretPositionFromPoint() 返回一个 CaretPosition 对象（光标插入点），该对象具有属性offsetNode，表示
该位置的节点对象，offset属性表示该位置在offsetNode对象内部，与起始位置相距的字符数。chrome未提供
	createElement() 用来生成元素节点，并返回该节点。参数为元素的标签名，参数里面不能包含尖括号（即<和>），
参数可以是自定义的标签名。
var newDiv = document.createElement('div');//OK
document.createElement('<div>'); //ERROR
document.createElement('foo');
	createTextNode()生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。这个方法可以确保返回的节点，
被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。
该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值
	createAttribute()生成一个新的属性节点（Attr实例），并返回它。
var node = document.getElementById('div1');
var a = document.createAttribute('my_attrib');
a.value = 'newVal';
node.setAttributeNode(a);
// 或者
node.setAttribute('my_attrib', 'newVal');
	createComment() 生成一个新的注释节点，并返回该节点。参数是一个字符串，会成为注释节点的内容
	createDocumentFragment()生成一个空的文档片段对象（DocumentFragment实例）。
DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。
这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档
的 DOM 有更好的性能表现。
	createEvent()生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。
参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。
	addEventListener()，removeEventListener()，dispatchEvent() 继承自EventTarget接口
	hasFocus()返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。
有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点
	adoptNode()将某个节点及其子节点，从原来所在的文档（iframe中的document）或DocumentFragment里面移除，归属当前
document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性
是null。此方法只是改变了节点的归属（ownerDocument属性指针），并没有将这个节点插入新的文档树。所以，还要再用
appendChild方法或insertBefore方法，将新节点插入当前文档树。
	importNode()从原来所在的文档或DocumentFragment里面，拷贝某个节点及其子节点，让它们归属当前document对象。
拷贝的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。
第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（false）。
虽然第二个参数是可选的，但是建议总是保留这个参数，并设为true。此方法只是拷贝外部节点，这时该节点的父节点是null。
下一步还必须将这个节点插入当前文档树。
	createNodeIterator()返回一个子节点遍历器（NodeIterator实例）。第一个参数为所要遍历的根节点，第二个参数为所要
遍历的节点类型（使用NodeFilter中的常量：NodeFilter.SHOW_ALL --所有节点、NodeFilter.SHOW_ELEMENT--元素节点、
NodeFilter.SHOW_TEXT--文本节点、NodeFilter.SHOW_COMMENT--评论节点）
返回的遍历器具有nextNode()方法和previousNode()方法，nextNode方法先返回遍历器的内部指针所在的节点，然后会将指针
移向下一个节点。所有成员遍历完成后，返回null。previousNode方法则是先将指针移向上一个节点，然后返回该节点。
currentNode表示遍历器指向的节点document返回的遍历器返回的第一个节点总是根节点：body
	createTreeWalker() 返回一个 DOM 的子树遍历器（TreeWalker实例），该遍历器返回的第一个节点不是根节点。
	getSelection()指向window.getSelection()
	execCommand()当document.designMode属性设为on或元素的contenteditable属性设为true时，调用此方法可以改变内容的样式，
比如document.execCommand('bold')会使得字体加粗。
document.execCommand(command, showDefaultUI, input) 第一个参数command：字符串，表示所要实施的样式，第二个参数
showDefaultUI：布尔值，表示是否要使用默认的用户界面，建议总是设为false。第三个参数input：字符串，表示该样式的辅助内容，
比如生成超级链接时，这个参数就是所要链接的网址。
	queryCommandEnabled()方法返回一个布尔值，表示浏览器是否允许使用这个方法。
	queryCommandSupported()方法返回一个布尔值，表示当前是否可用某种样式改变。
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Element节点
所有的HTML元素都是Element节点对象。nodeType属性值为1.
Element节点实际上不是一种对象，而是一组对象，不同的HTML元素对象都继承了Element的属性和方法，也有各自构造函数的属性和方法。
实例属性
	Element.id 返回指定元素的id属性，可读写。id属性的值是大小写敏感。
	Element.tagName 返回指定元素的大写标签名，与nodeName属性的值相等。
	Element.dir 用于读写当前元素的文字方向，可能是从左到右（"ltr"），也可能是从右到左（"rtl"）。汉语返回空字符串。
	Element.accessKey 用于读写分配给当前元素的快捷键。
		document.querySelector("[type=submit]").accessKey="h"	//设置快捷键后，使用Alt+h就可以使用了
	Element.draggable返回一个布尔值，表示当前元素是否可拖动。该属性可读写。
	Element.lang 返回当前元素的语言设置。该属性可读写。
	Element.title 用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。
	Element.tabIndex 返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。通常是-1，表示Tab 键不会遍历到该元素。
	状态相关属性：
	Element.hidden 读写当前元素的hidden属性，返回一个布尔值。CSS 的设置高于Element.hidden。这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。
	Element.contentEditable 返回元素是否可写，改属性可以修改，但是修改该属性的值不会改变元素的可写性，元素的可写性是通过添加或去除该属性实现的
	Element.isContentEditable 返回元素是否可写，此属性不可修改。
	Element.attributes 返回一个类似数组的对象，成员是当前元素节点的所有属性节点
	Element.className 用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。
	Element.classList 指向一个类似数组的对象，该对象的length属性（只读）返回当前元素的class数量。classList对象有下列方法：add();remove();contains();toggle();item();toString()
	Element.dataset 返回一个对象，可以从这个对象读写data-属性。网页元素可以自定义data-属性，用来添加数据。<div data-timestamp="1522907809292"></div>,data-timestamp为自定义属性
	Element.innerHTML 返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<HTML>和<body>元素。
如果将innerHTML属性设为空，等于删除所有它包含的所有节点。var name = "<script>alert('haha')</script>";el.innerHTML = name;插入的字符串含有标签会被解析成DOM元素，但是不会执行里面
的脚本。var name = "<img src=x onerror=alert(1)>"; el.innerHTML = name; 这里会执行，所以如果插入的是文本，最好用textContent属性代替innerHTML。
	Element.outerHTML 返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。对它进行赋值，等于替换掉当前元素。该元素被替换掉后不会消失，仍然保留在内存中
如果一个节点没有父节点，设置outerHTML属性会报错。
	Element.clientHeight 返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。
	Element.clientWidth 返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。
	Element.clientLeft 等于元素节点左边框（left border）的整数宽度（单位像素），不包括左侧的padding和margin。如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。
	Element.clientTop属性等于网页元素顶部边框的宽度（单位像素）
	Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括padding，但是不包括border、margin以及水平
滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。
	Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。
	Element.scrollLeft属性表示当前元素的水平滚动条向右侧滚动的像素数量。
	Element.scrollTop属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。
	Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），
则offsetParent属性返回null。
	Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。
	Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。如果元素的 CSS 设为不可见（比如display: none;），则返回0。
	Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移，Element.offsetTop返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。
		function getElementPosition(e) {
		  var x = 0;
		  var y = 0;
		  while (e !== null)  {
			x += e.offsetLeft;
			y += e.offsetTop;
			e = e.offsetParent;
		  }
		  return {x: x, y: y};
		}
	这一段代码可以算出元素左上角相对于整张网页的坐标。
	Element.style 用来读写该元素的行内样式信息
	Element.children 返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。
这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。
	Element.childElementCount 返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。
	Element.firstElementChild 返回当前元素的第一个元素子节点，Element.lastElementChild 返回最后一个元素子节点。如果没有元素子节点，这两个属性返回null。
	Element.nextElementSibling 返回当前元素节点的后一个同级元素节点，如果没有则返回null。
	Element.previousElementSibling 返回当前元素节点的前一个同级元素节点，如果没有则返回null。
实例方法
	Element.querySelector 接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。方法可以接受任何复杂的 CSS 选择器。
	Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。
	Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。
	Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。
	Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。
	Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。
	Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。该方法可以接受一个布尔值作为参数。
如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐
（前提是当前区域可滚动）。如果没有提供该参数，默认为true。
	Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。
	Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。对于盒状元素（比如<div>和<p>），该方法返回的对象中只有该元素一个成员。
对于行内元素（比如<span>、<a>、<em>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。
	Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。
该方法接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值：
beforebegin：当前元素之前	afterbegin：当前元素内部的第一个子节点前面	beforeend：当前元素内部的最后一个子节点后面	afterend：当前元素之后
	Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。
该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置四个值(同insertAdjacentElement的参数)之一。
	Element.insertAdjacentText方法在相对于当前节点的指定位置，插入一个文本节点，用法与Element.insertAdjacentHTML方法完全一致。
	Element.remove方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。
	Element.focus方法用于将当前页面的焦点，转移到指定元素上。该方法可以接受一个对象作为参数。参数对象的preventScroll属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。
	Element.blur方法用于将焦点从当前元素移除。
	Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。
	属性相关方法
	getAttribute()：读取某个属性的值
	getAttributeNames()：返回当前元素的所有属性名
	setAttribute()：写入属性值
	hasAttribute()：某个属性是否存在
	hasAttributes()：当前元素是否有属性
	removeAttribute()：删除属性
	事件相关方法：
	Element.addEventListener()：添加事件的回调函数
	Element.removeEventListener()：移除事件监听函数
	Element.dispatchEvent()：触发事件
【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【【
元素的属性
	HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）
	属性本身是一个对象（Attr对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（HTMlElement对象）来操作属性。
	元素对象有一个attributes属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。
	单个属性可以通过序号引用，也可以通过属性名引用。返回的都是属性节点对象，而不是属性值。document.body.attributes[0]
	返回的属性节点对象有name和value属性，等同于nodeName属性和nodeValue属性。
	HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。并且是可写的。但是无法删除属性，delete运算符在这里不会生效。
		var img = document.getElementById('myImage');
		img.src = 'http://www.example.com/image.jpg';
	HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。多个单词，则采用骆驼拼写法
	保留字改名：for属性改为htmlFor、class属性改为className
	HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。将字符串true转为布尔值，将onClick的值转为一个函数
	元素节点操作属性的六个方法：
	getAttribute() 只返回字符串，不会返回其他类型的值。
	getAttributeNames()	返回一个数组
	setAttribute() 如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。属性值总是字符串，其他类型的值会自动转成字符串 b.setAttribute('disabled', true);
					对于button元素disabled不需要属性值，所以true可能被改成任意字符串
	hasAttribute()
	hasAttributes()
	removeAttribute()
	这六个方法对所有属性（包括用户自定义的属性）都适用。
	这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。
		image.setAttribute('class', 'myImage');
	标准提供data-*属性，可以用来为元素添加自定义属性，元素可以使用dataset.*来获取该属性。<div id="mydiv" data-foo="bar">  document.getElementById('mydiv').dataset.foo = 'baz'
	删除data-*属性：delete document.getElementById('myDiv').dataset.foo;
	data-后面的属性名有限制，只能包含字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_)。而且，属性名不应该使用A到Z的大写字母
	转成dataset的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，dataset的键名转成属性名时，
所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，dataset.helloWorld会转成data-hello-world。

】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】】
Text 节点
	父节点的firstChild、nextSibling等属性可以获取文本节点
	Document节点的createTextNode方法可以创造一个文本节点。
	文本节点除了继承Node接口，还继承了CharacterData接口。
	文本节点的data属性等同于nodeValue属性，用来设置或读取文本节点的内容。wholeText属性将当前文本节点与毗邻的文本节点，作为一个整体返回。
	length属性返回当前文本节点的文本长度。
	nextElementSibling属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回null。
	previousElementSibling属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回null：。
方法：
	appendData()：在Text节点尾部追加字符串。
	deleteData()：删除Text节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。
	insertData()：在Text节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。
	replaceData()：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。
	subStringData()：用于获取子字符串，第一个参数为子字符串在Text节点中的开始位置，第二个参数为子字符串长度。
	remove方法用于移除当前Text节点。
	splitText方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。
分割后，该方法返回分割位置后方的字符串，而原Text节点变成只包含分割位置前方的字符串。
	父元素节点的normalize方法可以将毗邻的两个Text节点合并。
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
DocumentFragment 节点 
	DocumentFragment节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，parentNode返回null，但是可以插入任意数量的子节点。
它不属于当前文档，操作DocumentFragment节点，要比直接操作 DOM 树快得多。
	它一般用于构建一个 DOM 结构，然后插入当前文档。document.createDocumentFragment方法，以及浏览器原生的DocumentFragment构造函数，
可以创建一个空的DocumentFragment节点。然后再使用其他 DOM 方法，向其添加子节点。
	DocumentFragment节点本身不能被插入当前文档。当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，
而不是它自身。一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。
如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。
	document.queryselector('ul').appendChild(docFrag.cloneNode(true));
	DocumentFragment节点对象没有自己的属性和方法，全部继承自Node节点和ParentNode接口
[[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]][[[[[[[[]]]]]]]]]]]

操作CSS
	操作 CSS 样式最简单的方法，就是使用网页元素节点的getAttribute方法、setAttribute方法和removeAttribute方法，直接读写或删除网页元素的style属性。
	div.setAttribute('style', 'background-color:red;' + 'border:1px solid black;');
	元素的style属性本身是一个对象，部署了 CSSStyleDeclaration 接口，可以直接读写style属性，读写style中的CSS属性时使用驼峰名称
	document.querySelector('div').style.fontSize='10em'
	如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串css，比如float写成cssFloat。
	Element.style返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。
	元素的全部样式要通过window.getComputedStyle()得到。
	style对象的属性一部分与CSS规则相对应，只是采用驼峰名称，另一部分属性来自 CSSStyleDeclaration 接口。
CSSStyleDeclaration 实例属性 
	CSSStyleDeclaration.cssText 用来读写当前规则的所有样式声明文本。	document.querySelector('div').style.cssText='background-color:red;border:1px solid black;';
	CSSStyleDeclaration.length 返回一个整数值，表示当前规则包含多少条样式声明。
	CSSStyleDeclaration.parentRule 返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回null。该属性只读，且只在使用 CSSRule 接口时有意义。
		var declaration = document.styleSheets[0].rules[0].style;
		declaration.parentRule === document.styleSheets[0].rules[0]
		// true
CSSStyleDeclaration 实例方法
	CSSStyleDeclaration.getPropertyPriority方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置important优先级。如果有就返回important，否则返回空字符串。
	CSSStyleDeclaration.getPropertyValue方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。
	CSSStyleDeclaration.item方法接受一个整数值作为参数，返回该位置的 CSS 属性名。
	CSSStyleDeclaration.removeProperty方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。
	CSSStyleDeclaration.setProperty方法用来设置新的 CSS 属性。该方法没有返回值.该方法可以接受三个参数。
		第一个参数：属性名，该参数是必需的。
		第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。
		第三个参数：优先级，该参数可选。如果设置，唯一的合法值是important，表示 CSS 规则里面的!important。
测试CSS属性是否存在：
	判断元素的style对象的某个属性值是否为字符串：
	typeof element.style.animationName === 'string';
	document.body.style['maxWidth'] // ""
	document.body.style['maximumWidth'] // undefined
	这两种写法都可以：
	document.body.style['backgroundColor'] // ""
	document.body.style['background-color'] // ""
CSS对象
	浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。这个对象目前有两个静态方法。
	<div id="foo#bar"> 查询该元素不能直接写成document.querySelector('#foo#bar')，只能写成document.querySelector('#foo\\#bar')。
	使用CSS.escape转义：
		CSS.escape('foo#bar') //"foo\#bar"
	CSS.supports方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。
	它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。
		// 第一种写法
		CSS.supports('transform-origin', '5px') // true

		// 第二种写法
		CSS.supports('display: table-cell') // true
	window.getComputedStyle方法，返回浏览器计算后得到的最终规则。接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。
这个实例是只读的。
		var div = document.querySelector('div');
		var styleObj = window.getComputedStyle(div);
		styleObj.backgroundColor
	getComputedStyle方法还可以接受第二个参数，表示当前元素的伪元素（比如:before、:after、:first-line、:first-letter等）。
	CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括px后缀），颜色是rgb(#, #, #)或rgba(#, #, #, #)格式。
	CSSStyleDeclaration 实例使用CSS 规则的简写形式无效。比如，想读取margin属性的值，不能直接读，只能读marginLeft、marginTop等属性；再比如，font属性也是不能直接读的，只能读font-size等单个属性。
	CSSStyleDeclaration 实例读取 CSS 原始的属性名，要用方括号运算符，比如styleObj['z-index']；如果读取骆驼拼写法的 CSS 属性名，可以直接读取styleObj.zIndex。
	该方法返回的 CSSStyleDeclaration 实例的cssText属性无效，返回undefined。
CSS伪元素：
	CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过:before和:after选择器生成，然后用content属性指定伪元素的内容。
	<div id="test">Test content</div>
	#test:before {
	  content: 'Before ';
	  color: green;
	}
	产生结果：
	<div id="test">
		::before 
		Test content
	</div>
	节点元素的style对象无法读写伪元素的样式，这时就要用到window.getComputedStyle():
	var test = document.querySelector('#test');
	var result = window.getComputedStyle(test, ':before').content;	//读取伪元素内容
	var color = window.getComputedStyle(test, ':before').color;     //读取伪元素样式中的颜色
	也可以使用getPropertyValue方法从伪元素获取其属性
StyleSheet 接口
	StyleSheet接口代表网页的一张样式表，包括<link>元素加载的样式表和<style>元素内嵌的样式表。
	document对象的styleSheets属性，可以返回当前页面的所有StyleSheet实例（即所有样式表）。它是一个类似数组的对象。
	如果是<style>元素嵌入的样式表，还有另一种获取StyleSheet实例的方法，就是这个节点元素的sheet属性。
	<style id="myStyle"></style>
	var myStyleSheet = document.getElementById('myStyle').sheet;
	myStyleSheet instanceof StyleSheet // true
	StyleSheet接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类CSSStyleSheet表示网页的 CSS 样式表。这个子接口继承了StyleSheet的所有属性和方法，并且定义了几个自己的属性
StyleSheet实例属性：
	StyleSheet.disabled返回一个布尔值，表示该样式表是否处于禁用状态。手动设置disabled属性为true，等同于在<link>元素里面，将这张样式表设为alternate stylesheet，即该样式表将不会生效。
注意，disabled属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。
	Stylesheet.href返回样式表的网址。对于内嵌样式表，该属性返回null。该属性只读。
	StyleSheet.media属性返回一个类似数组的对象（MediaList实例），成员是表示适用媒介的字符串。
	MediaList实例的appendMedium方法，用于增加媒介；deleteMedium方法用于删除媒介。
	StyleSheet.title属性返回样式表的title属性。
	StyleSheet.type属性返回样式表的type属性，通常是text/css。
	CSS 的@import命令允许在样式表中加载其他样式表。StyleSheet.parentStyleSheet属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回null。
	StyleSheet.ownerNode属性返回StyleSheet对象所在的 DOM 节点，通常是<link>或<style>。对于那些由其他样式表引用的样式表，该属性为null。
	CSSStyleSheet.cssRules属性指向一个类似数组的对象（CSSRuleList实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的cssText属性，可以得到 CSS 规则对应的字符串。
	document.querySelector('#styleElement').sheet.cssRules[0].cssText  // "body { background-color: red; margin: 20px; }"
	每条 CSS 规则还有一个style属性，指向一个对象，用来读写具体的 CSS 命令。  cssStyleSheet.cssRules[0].style.color = 'red';
	有些样式表是通过@import规则输入的，它的ownerRule属性会返回一个CSSRule实例，代表那行@import规则。如果当前样式表不是通过@import引入的，ownerRule属性返回null。
实例方法
	CSSStyleSheet.insertRule方法用于在当前样式表的插入一个新的 CSS 规则。该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。
第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。
	浏览器对脚本在样式表里面插入规则有很多限制。所以，这个方法最好放在try...catch里使用。
	CSSStyleSheet.deleteRule方法用来在样式表里面移除一条规则，它的参数是该条规则在cssRules对象中的位置。该方法没有返回值。document.styleSheets[0].deleteRule(1);
网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<style>节点。另一种是添加外部样式表，即在文档中添加一个<link>节点，然后将href属性指向外部样式表的 URL。
		var style = document.createElement('style');
		style.setAttribute('media', 'screen');
		style.innerHTML = 'body{color:red}';
		document.head.appendChild(style);
	CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。
	CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过rules.item(index)或者rules[index]拿到。CSS 规则的条数通过rules.length拿到。
	添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过StyleSheet.insertRule()和StyleSheet.deleteRule()操作。

CSSRule 接口
	一条 CSS 规则包括两个部分：CSS 选择器和样式声明（CSS命令）。
	实例属性：
	CSSRule.cssText属性返回当前规则的文本
	CSSRule.parentStyleSheet属性返回当前规则所在的样式表对象（StyleSheet 实例）
	CSSRule.parentRule属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回null。
	CSSRule.type属性返回一个整数值，表示当前规则的类型。1：普通样式规则（CSSStyleRule 实例）	3：@import规则
	一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令）还部署了 CSSStyleRule 接口，具有两个属性：
	CSSStyleRule.selectorText属性返回当前规则的选择器。这个属性是可写的。
	CSSStyleRule.style属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。
	CSSStyleDeclaration 实例的cssText属性，可以返回所有样式声明，格式为字符串。
window.matchMedia()
	用来将 CSS 的MediaQuery条件语句，转换成一个 MediaQueryList 实例。
	如果参数不是有效的MediaQuery条件语句，window.matchMedia不会报错，依然返回的一个 MediaQueryList 实例。
	MediaQueryList.media属性返回一个字符串，表示对应的 MediaQuery 条件语句。
	MediaQueryList.matches属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。
	MediaQueryList.onchange属性用来指定change事件的监听函数。该函数的参数是change事件对象（MediaQueryListEvent 实例），
该对象与 MediaQueryList 实例类似，也有media和matches属性。change事件会在window参数被调整后触发，从而可以实现适配式样式设置。
		var mql = window.matchMedia('(max-width: 600px)');

		mql.onchange = function(e) {
		  if (e.matches) {
			/* 视口不超过 600 像素 */
		  } else {
			/* 视口超过 600 像素 */
		  }
		}
	MediaQueryList 实例有两个方法MediaQueryList.addListener()和MediaQueryList.removeListener()，用来为change事件添加或撤销监听函数。
	
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
Mutation Observer API
	Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。
	概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，
也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。
	Mutation Observer 有以下特点。
		它等待所有脚本任务完成后，才会运行（即异步触发方式）。
		它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。
		它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。
	使用MutationObserver构造函数：
	var observer = new MutationObserver(callback);
	参数是一个回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例
实例方法：
	observe方法用来启动监听，它接受两个参数。
		第一个参数：所要观察的 DOM 节点
		第二个参数：一个配置对象，指定所要观察的特定变动	
	var article = document.querySelector('article');

	var  options = {
	  'childList': true,
	  'attributes':true
	} ;

	observer.observe(article, options);
	观察器所能观察的 DOM 变动类型（即上面代码的options对象），有以下几种。
		childList：子节点的变动（指新增，删除或者更改）。
		attributes：属性的变动。
		characterData：节点内容或节点文本的变动。
	想要观察哪一种变动类型，就在option对象中指定它的值为true
	options对象还可以设定以下属性：
		subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点。
		attributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。
		characterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值。
		attributeFilter：数组，表示需要观察的特定属性（比如['class','src']）。
	disconnect方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。
	takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。
	DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）
	MutationRecord对象包含了DOM的相关信息，有如下属性：
		type：观察的变动类型（attribute、characterData或者childList）。
		target：发生变动的DOM节点。
		addedNodes：新增的DOM节点。
		removedNodes：删除的DOM节点。
		previousSibling：前一个同级节点，如果没有则返回null。
		nextSibling：下一个同级节点，如果没有则返回null。
		attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。
		oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。
	function mycallback(mutations){
		mutations.forEach(function(mutation){
			console.log(mutation.oldValue)
		})
	}

	observer = new MutationObserver(mycallback);

	let options = {
		'oldValue':true,
		'target':true,
		'characterData':true
	};

	let teacherTxt = document.getElementById('teacher-intro'); 

	observer.observe(teacherTxt,options)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EventTarget 接口
	为元素绑定事件处理函数、移除事件处理函数、触发事件的三个方法声明在EventTarget接口中，这三个方法是：addEventListener、
removeEventListener和dispatchEvent
	addEventListener(type, listener[, useCapture]);接收3个参数，第一个type为事件名，如'click'，第二个listener是回调函数，
第三个参数是可选，默认为false...
	function hello() {
	  console.log('Hello world');
	}

	var button = document.getElementById('btn');
	button.addEventListener('click', hello, false);
	第二个参数还可以是一个对象，该对象需要具有handleEvent方法：
	buttonElement.addEventListener('click', {
	  handleEvent: function (event) {
		console.log('click');
	  }
	});
	第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性：
	capture：布尔值，表示该事件是否在捕获阶段触发监听函数。
	once：布尔值，表示监听函数是否只触发一次，然后就自动移除。
	passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。

	可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发
	如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除
	可以用匿名函数包装一下监听函数：
	para.addEventListener('click', function (e) {
	  console.log(this.nodeName); // "P"
	  print(e);
	}, false);
	监听函数内部的this，指向当前事件所在的那个对象。
	
	removeEventListener方法没有返回值，参数与addEventListener方法完全一致
	removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。
	第三个参数也必须保持一致才能移除
	
	dispatchEvent方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。参数是一个Event对象的实例：
	para.addEventListener('click', hello, false);
	var event = new Event('click');
	para.dispatchEvent(event);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
事件模型
	为元素绑定事件处理函数的3中方式：
	1、使用HTML 的 on- 属性 
		<body onload="doSomething()">
		<div onclick="console.log('触发事件')">
		这些属性的值是将会执行的代码，而不是一个函数。
		使用这个方法指定的监听代码，只会在冒泡阶段触发。
		直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。
	2、使用元素节点的事件属性
		indow.onload = doSomething;

		div.onclick = function (event) {
		  console.log('触发事件');
		};
		监听函数也是只会在冒泡阶段触发。同一个事件只能绑定一个处理函数
		事件属性的值是函数名，或者说是函数引用，而使用on-属性的值是执行代码
	3、使用EventTarget.addEventListener()方法
		所有 DOM 节点实例都有addEventListener方法
	
	监听函数内部的this指向触发事件的那个元素节点。
	一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：
		第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。
		第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。
		第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。
	这种三阶段的传播模型，使得同一个事件会在多个节点上触发。
	<div>
	  <p>点击</p>
	</div>
	
	var phases = {
	  1: 'capture',
	  2: 'target',
	  3: 'bubble'
	};

	var div = document.querySelector('div');
	var p = document.querySelector('p');

	div.addEventListener('click', callback, true);
	p.addEventListener('click', callback, true);
	div.addEventListener('click', callback, false);
	p.addEventListener('click', callback, false);

	function callback(event) {
	  var tag = event.currentTarget.tagName;
	  var phase = phases[event.eventPhase];
	  console.log("Tag: '" + tag + "'. EventPhase: '" + phase + "'");
	}

	// 点击以后的结果
	// Tag: 'DIV'. EventPhase: 'capture'
	// Tag: 'P'. EventPhase: 'target'
	// Tag: 'P'. EventPhase: 'target'
	// Tag: 'DIV'. EventPhase: 'bubble'
	
	div绑定第一个click事件处理函数设置了参数capture为true，所以捕获阶段会调用该函数
	click事件从div下传到p后,p上的处理函数在目标阶段调用一次
	click事件从p冒泡到div前，p上的处理函数在目标阶段再调用一次
	click事件从p冒泡到div后，div上的处理函数在冒泡阶段执行一次
	
	事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。
这种方法叫做事件的代理（delegation）。
	var ul = document.querySelector('ul');

	ul.addEventListener('click', function (event) {
	  if (event.target.tagName.toLowerCase() === 'li') {
		// some code
	  }
	});
	如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。
	stopPropagation方法只会阻止事件的传播，不会阻止该事件触发节点的其他click事件的监听函数
	如果想要彻底取消该事件，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
事件对象Event
	事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。
	Event对象本身就是一个构造函数，可以用来生成新的实例：event = new Event(type, options);
	第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性：
		bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。
		cancelable：布尔值，可选，默认为false，表示事件是否可以被取消
	如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数
		// HTML 代码为
		// <div><p>Hello</p></div>
		var div = document.querySelector('div');
		var p = document.querySelector('p');

		function callback(event) {
		  var tag = event.currentTarget.tagName;
		  console.log('Tag: ' + tag); // 没有任何输出
		}

		div.addEventListener('click', callback, false);//捕获阶段不调用事件处理函数

		var click = new Event('click');//bubbles属性默认为false，事件不会冒泡
		p.dispatchEvent(click);//p上触发事件，不会冒泡到div上
	Event实例属性：
	bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性
	eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。（返回0(未发生)、1(捕获)、2(目标)、3(冒泡)）
	cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性。大多数浏览器的原生事件是可以取消的
	当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。
	如果Event.cancelable属性为false，调用Event.preventDefault()会没有任何效果
	cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。
	defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。
	currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。
	target属性返回原始触发事件的那个节点，即事件最初发生的节点
	type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。
	timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。
	isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生
	detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。
	实例方法：
	preventDefault方法取消浏览器对当前事件的默认行为。该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播
		// HTML 代码为
		// <input type="text" id="my-input" />
		var input = document.getElementById('my-input');
		input.addEventListener('keypress', checkName, false);

		function checkName(e) {
		  if (e.charCode < 97 || e.charCode > 122) {
			e.preventDefault();
		  }
		}
	stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。
	stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。
	composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。
	// <div>
	//   <p>Hello</p>
	// </div>
	p上的click事件的最底层节点是p，向上依次是div、body、html、document、Window。
====================================================================================================================
鼠标事件
	鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。
	浏览器提供的主要鼠标事件有：click、dbclick、mousedown、mouseup、mouseover、mouseenter、mouseleave、mouseout、mousemove、wheel等
	click事件实际上是在同一个位置先完成mousedown动作，再完成mouseup动作，最后完成click动作
	dblclick事件则会在mousedown、mouseup、click之后触发。
	鼠标进入一个节点时触发mouseenter事件和mouseover事件。在父节点内部进入子节点，不会触发mouseenter事件，但是会触发mouseover事件。
	鼠标离开一个节点时触发mouseout事件和mouseleave事件。在父元素内部离开一个子元素时，mouseleave事件不会触发，而mouseout事件会触发。
	MouseEvent接口代表了鼠标相关的事件，鼠标事件都是MouseEvent接口的实例
	MouseEvent接口继承了Event接口，所以拥有Event的所有属性和方法。
	浏览器原生提供一个MouseEvent构造函数，用于新建一个MouseEvent实例。var event = new MouseEvent(type, options);
	第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选，属性可以是Event接口的实例配置属性和鼠标事件相关属性：
screenX、clientX、ctrlKey、button、relatedTarget等
	MouseEvent实例对象可以使用这些属性：
		altKey等返回事件触发时是否按下相应的键；
		button返回事件发生时按下了鼠标的哪个键；
		clientX等返回触发事件时鼠标的位置信息；
		relatedTarget返回事件的相关节点（mouseover事件的target属性返回将要进入的节点，relatedTarget属性返回将要离开的节点）
	实例方法：getModifierState方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。
		e.getModifierState('CapsLock');	//是否按下大写键
	WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个wheel事件，
用户滚动鼠标的滚轮，就生成这个事件的实例。
	浏览器原生提供WheelEvent()构造函数：var wheelEvent = new WheelEvent(type, options);
	type目前只能是字符串"wheel"
	options课配置属性除了MouseEvent的属性配置对象属性外，还可以是以下属性：
		deltaX：表示滚轮的水平滚动量，默认值是 0.0。
		deltaY：表示滚轮的垂直滚动量，默认值是 0.0。
		deltaZ：表示滚轮的 Z 轴滚动量，默认值是 0.0。
		deltaMode：表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。
	实例属性：deltaX等
====================================
键盘事件
	主要有keydown、keypress、keyup三个事件，它们都继承了KeyboardEvent接口。
	keypress事件在按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，
再触发这个事件。
	如果用户一直按键不松开，就会连续触发键盘事件：
		keydown
		keypress
		keydown
		keypress
		...（重复以上过程）
		keyup
	KeyboardEvent接口：继承了Event接口，用来描述用户与键盘的互动
	浏览器原生提供KeyboardEvent构造函数：new KeyboardEvent(type, options)
	第二个参数除了Event构造参数的配置参数属性外，还可以使用以下属性：
		key：字符串，当前按下的键，默认为空字符串。
		code：字符串，表示当前按下的键的字符串形式，默认为空字符串。
		ctrlKey：布尔值，是否按下 Ctrl 键，默认为false。
		repeat：布尔值，是否重复按键，默认为false。
	KeyboardEvent实例属性：
		altKey：是否按下 Alt 键
		code：返回一个字符串，表示当前按下的键的字符串形式：数字键0 - 9：返回digital0 - digital9；字母键A - z：返回KeyA - KeyZ
		key：返回一个字符串，表示按下的键名。该属性只读。如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。
	不可打印的特殊字符，则返回预定义的键值：Backspace、Tab等
		location属性返回一个整数，表示按下的键处在键盘的哪一个区域。0：处在键盘的主区域，或者无法判断处于哪一个区域
	1：处在键盘的左侧。3：处在数字小键盘。
		repeat返回一个布尔值，代表该键是否被按着不放
		实例方法：getModifierState()方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下：
			Alt：Alt 键
			CapsLock：大写锁定键
		event.getModifierState('Control')
==============================================
进度事件
	进度事件用来描述资源加载的进度，主要由 AJAX 请求、<img>、<audio>、<video>、<style>、<link>等外部资源的加载触发，继承了ProgressEvent接口。
	类型：
		abort：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。
		error：由于错误导致外部资源无法加载时触发。
		load：外部资源加载成功时触发。
		loadstart：外部资源开始加载时触发。
		loadend：外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面。
		progress：外部资源加载过程中不断触发。
		timeout：加载超时时触发。
	除了资源下载，文件上传也存在这些事件。
		image.addEventListener('load', function (event) {
		  image.classList.add('finished');
		});
	资源加载可能会在脚本运行之前就完成，这样load和error事件的监听函数就不会执行。所以最后使用complete属性先判断一下是否加载完成。
		if (image.complete) {
		  loaded();
		} else {
		  image.addEventListener('load', loaded);
		}
	loadend事件的监听函数，可以用来取代abort事件、load事件、error事件的监听函数，因为它总是在这些事件之后发生。
	error事件有一个特殊的性质，就是不会冒泡。所以，子元素的error事件，不会触发父元素的error事件监听函数。
	ProgressEvent 接口：用来描述外部资源加载的进度，进度相关的事件都继承了这个接口。
	浏览器原生提供了ProgressEvent()构造函数：new ProgressEvent(type, options)
	第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用Event接口的配置属性，还可以使用下面的属性：
		lengthComputable：布尔值，表示加载的总量是否可以计算，默认是false。
		loaded：整数，表示已经加载的量，默认是0。
		total：整数，表示需要加载的总量，默认是0。
	这些配置属性也是ProgressEvent实例对象上的属性。
	如果ProgressEvent.lengthComputable为false，ProgressEvent.total实际上是没有意义的。
		var p = new ProgressEvent('load', {
		  lengthComputable: true,
		  loaded: 30,
		  total: 100,
		});

		document.body.addEventListener('load', function (e) {
		  console.log('已经加载：' + (e.loaded / e.total) * 100 + '%');
		});

		document.body.dispatchEvent(p);
		// 已经加载：30%
==============================================
表单事件：
	input事件当<input>、<select>、<textarea>的值发生变化时触发。对于复选框（<input type=checkbox>）或单选框（<input type=radio>），
用户改变选项时，也会触发这个事件。另外，对于打开contenteditable属性的元素，只要值发生变化，也会触发input事件。
	用户每按下一次按键，就会触发一次input事件。input事件对象继承了InputEvent接口。
		/* HTML 代码如下
		<select id="mySelect">
		  <option value="1">1</option>
		  <option value="2">2</option>
		  <option value="3">3</option>
		</select>
		*/

		function inputHandler(e) {
		  console.log(e.target.value)
		}

		var mySelect = document.querySelector('#mySelect');
		mySelect.addEventListener('input', inputHandler);
	select事件当在<input>、<textarea>里面选中文本时触发。选中的文本可以通过event.target元素的selectionDirection、selectionEnd、
	selectionStart和value属性拿到。
		// HTML 代码如下
		// <input id="test" type="text" value="Select me!" />

		var elem = document.getElementById('test');
		elem.addEventListener('select', function (e) {
		  console.log(e.type); // "select"
		  console.log(e.target.value.substr(e.target.selectionStart,e.target.selectionEnd)); // 选中的文本
		}, false);
	change事件当<input>、<select>、<textarea>的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发	
		激活单选框（radio）或复选框（checkbox）时触发。
		用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。
		当文本框或<textarea>元素的值发生改变，并且丧失焦点时触发。
		var inputElem = document.getElementById('testInput');
        inputElem.addEventListener('input',function (e) {
            console.log("input "+e.target.value);
        },false);
        inputElem.addEventListener('change',function (e) {
            console.log("change "+e.target.value);
        },true);
	invalid事件在提交表单时，如果表单元素的值不满足校验条件触发：
		<form>
		  <input type="text" required oninvalid="console.log('invalid input')" />
		  <button type="submit">提交</button>
		</form>
	reset事件当表单重置（所有表单成员变回默认值）时触发。发生在表单对象<form>上，而不是发生在表单的成员上。
	submit事件当表单数据向服务器提交时触发。发生在表单对象<form>上，而不是发生在表单的成员上。
	
	InputEvent接口主要用来描述input事件的实例。该接口继承了Event接口
	浏览器原生提供InputEvent()构造函数	new InputEvent(type, options)
	配置对象的字段除了Event构造函数的配置属性，还可以设置下面的字段：
		inputType：字符串，表示发生变更的类型，Chrome 浏览器的常用值如下：insertText表示 手动插入文本，insertFromPaste表示 粘贴插入文本，
deleteContentBackward 表示 向后删除，deleteContentForward表示 向前删除
		data：字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回null或空字符串。
		dataTransfer：一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。
	InputEvent的实例属性主要就是上面三个属性，这三个实例属性都是只读的。
==============================
触摸事件
	Touch接口的实例对象用来表示触摸点，具有位置、大小、形状、压力、目标元素等属性。多个触摸点的集合由TouchList接口的实例对象表示。
	TouchEvent接口的实例对象表示由触摸引发的事件，只有触摸屏才会引发这一类事件。
	很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，
在触摸屏的情况下仍然能用。如果想避免这种情况，可以用event.preventDefault方法阻止发出鼠标事件。
	浏览器原生提供Touch构造函数：var touch = new Touch(touchOptions);	touchOptions具有以下属性：
		identifier：必需，表示触摸点的唯一 ID
		target：必需，类型为元素节点，表示触摸点开始时所在的网页元素。
		clientX(clientX)：可选，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。
		screenX(screenY)：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。
		pageX(pageX)：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。
		radiusX(radiusX)：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。
		rotationAngle：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。
		force：可选，类型为数值，范围在0到1之间，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力，默认为0。
	TouchList接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是Touch的实例对象，表示所有触摸点。
	它的实例主要通过触摸事件的TouchEvent.touches、TouchEvent.changedTouches、TouchEvent.targetTouches这几个属性获取。
	实例属性：TouchList.length 表示touch实例的数量
	实例方法：item(i)，返回第I个touch实例
	TouchEvent 接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。
	浏览器原生提供TouchEvent()构造函数，new TouchEvent(type, options)
	options除了可以使用Event接口的配置属性还可以使用下面的属性：
		touches：TouchList实例，代表所有的当前处于活跃状态的触摸点
		targetTouches：TouchList实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点
		changedTouches：TouchList实例，代表本次触摸事件的相关触摸点
		ctrlKey(altKey/shiftKey/metaKey)：布尔值，表示 Ctrl 键是否同时按下，默认值为false。
	以上配置对象属性也是TouchEvent实例对象的可访问属性。
	类型：
		touchstart：用户开始触摸时触发，它的target属性返回发生触摸的元素节点。
		touchend：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的target属性与touchstart事件一致的，就是开始触摸时所在的元素节点。
它的changedTouches属性返回一个TouchList实例，包含所有不再触摸的触摸点（即Touch实例对象）。
		touchmove：用户移动触摸点时触发，它的target属性与touchstart事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。
		touchcancel：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、
用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。
		var el = document.getElementsByTagName('canvas')[0];
		el.addEventListener('touchstart', handleStart, false);
		el.addEventListener('touchmove', handleMove, false);

		function handleStart(evt) {
		  evt.preventDefault();
		  var touches = evt.changedTouches;
		  for (var i = 0; i < touches.length; i++) {
			console.log(touches[i].pageX, touches[i].pageY);
		  }
		}

		function handleMove(evt) {
		  evt.preventDefault();
		  var touches = evt.changedTouches;
		  for (var i = 0; i < touches.length; i++) {
			var touch = touches[i];
			console.log(touch.pageX, touch.pageY);
		  }
		}
===================================================
拖拉事件
	拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。
	拖拉的对象包括元素节点、图片、链接、选中的文字等；在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、
选中的文字）都是可以直接拖拉的。
	为了让元素节点可拖拉，可以将该节点的draggable属性设为true。
	draggable属性可用于任何元素节点，但是图片（<img>）和链接（<a>）不加这个属性，就可以拖拉。对于它们，用到这
个属性的时候，往往是将其设为false，防止拖拉这两种元素。
	一旦某个元素节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了。
	当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件：
		drag：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。
		dragstart：用户开始拖拉时，在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。
		dragend：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。
		dragenter：拖拉进入当前节点时，在当前节点上触发一次，该事件的target属性是当前进入的节点。
		dragover：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的target属性是当前节点。
		dragenter事件在进入当前节点时触发一次，然后只要没有离开这个节点，dragover事件会持续触发。
		dragleave：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。
		drop：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，
即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件
/**
 * HTML
 **/ 
<div class="dropzone">
	<div id="draggable" draggable="true">
		该节点可拖拉
	</div>
</div>
<div class="dropzone"></div>
<div class="dropzone"></div>
<div class="dropzone"></div>
/**
 * CSS
 **/
<style type="text/css">
	.dropzone{
		width: 200px;
		height: 100px;
		border: solid;
	}
</style>
/**
 * JavaScript
 **/
// 被拖拉节点
var dragged;

document.addEventListener('dragstart', function (event) {
  // 保存被拖拉节点
  dragged = event.target;
  // 被拖拉节点的背景色变透明
  event.target.style.opacity = 0.5;
  event.target.style.backgroundColor='red';
}, false);

document.addEventListener('dragend', function (event) {
  // 被拖拉节点的背景色恢复正常
  event.target.style.opacity = '';
  event.target.style.backgroundColor='';
}, false);

document.addEventListener('dragover', function (event) {
  // 防止拖拉效果被重置，允许被拖拉的节点放入目标节点
  event.preventDefault();
}, false);

document.addEventListener('dragenter', function (event) {
  // 目标节点的背景色变紫色
  // 由于该事件会冒泡，所以要过滤节点
  if (event.target.className === 'dropzone') {
	event.target.style.background = 'purple';
  }
}, false);

document.addEventListener('dragleave', function( event ) {
  // 目标节点的背景色恢复原样
  if (event.target.className === 'dropzone') {
	event.target.style.background = '';
  }
}, false);

document.addEventListener('drop', function( event ) {
  // 防止事件默认行为（比如某些元素节点上可以打开链接），
  event.preventDefault();
  if (event.target.className === 'dropzone') {
	// 恢复目标节点背景色
	event.target.style.background = '';
	// 将被拖拉节点插入目标节点
	dragged.parentNode.                                                      (dragged);
	event.target.appendChild( dragged );
  }
}, false);

	拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。
	将文件从操作系统拖拉进浏览器，不会触发dragstart和dragend事件。
	dragenter和dragover事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为
放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，
首先必须阻止这两个事件的默认行为。
	拖拉事件都继承了DragEvent接口，这个接口又继承了MouseEvent接口和Event接口。
	new DragEvent(type, options):DragEvent()构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；
第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。
	配置对象除了接受MouseEvent接口和Event接口的配置属性，还可以设置dataTransfer属性要么是null，要么是一个DataTransfer
接口的实例,实例对象用来读写拖拉事件中传输的数据
	所有拖拉事件的实例都有一个dataTransfer属性，用来读写需要传递的数据。这个属性的值是一个DataTransfer接口的实例。
	DataTransfer()构造函数不接受参数。
	拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如text/plain、image/jpeg），数据的值是一个字符串。一般来说，
如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。
	拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过dragenter和dragover事件的监听函数，检查
数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为text/uri-list。
发生drop事件时，监听函数取出拖拉的数据，对其进行处理。
	DataTransfer 的实例属性:
		dropEffect，用在dragover，dragenter事件监听函数中设置放下（drop）被拖拉节点时的效果：
			copy：复制被拖拉的节点
			move：移动被拖拉的节点
			none：无法放下被拖拉的节点
		effectAllowed，用在dragstart事件监听函数中设置被拖拉的节点允许的效果：
			copy：复制被拖拉的节点
			move：移动被拖拉的节点
			none：无法放下被拖拉的节点
		files属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，
则该属性为空的 FileList 对象。
		types属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是text/plain。
		items属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）
	DataTransfer 的实例方法：
		setData()方法用来设置拖拉事件所带有的数据。该方法没有返回值。第一个参数表示数据类型（比如text/plain），
第二个参数是具体数据。如果指定类型的数据在dataTransfer属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。
			event.dataTransfer.setData('text/plain', 'Text to drag');
		getData()方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用setData方法添加
的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有drop事件触发后，才能取出数据。返回值是一个字符串，
如果其中包含多项数据，就必须手动解析。
			var data = event.dataTransfer.getData('text/plain');
		clearData()方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，
则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。
		setDragImage()方法可以自定义这张图片。它接受三个参数。第一个是<img>节点或者<canvas>节点，如果省略或为null，
则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。

资源事件：
	beforeunload 事件：窗口、文档、各种资源将要卸载前触发这个事件：
	window.addEventListener("beforeunload",function(event){
			event.returnValue="are you sure to leave";
		});
	设置event的returnValue为非空字符串，浏览器就会弹出一个对话框，询问用户是否要卸载该资源。
	浏览器对这个事件的行为很不一致，有的浏览器调用event.preventDefault()，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，
才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。（Chrome只会显示默认提示）
	应用：用户修改了表单，还没有保存就要离开。（可以在修改表单同时添加监听器，保存后再移除添加的监听器）。
	unload事件：在窗口关闭或者document对象将要卸载时触发。它的触发顺序排在beforeunload、pagehide事件后面。
	unload事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。
这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。
任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。
	load事件在页面或某个资源加载成功时触发。页面上所有的资源（图片，音频，视频等）被加载以后才会触发页面load事件
	error事件是在页面或资源加载失败时触发。
	abort事件在用户取消加载时触发。
	pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，
可以放在这个事件的监听函数。第一次加载时，它的触发顺序排在load事件后面。从缓存加载时，load事件不会触发
	pageshow 事件有一个persisted属性，返回一个布尔值。页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true。
	pagehide事件与pageshow事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 
对象上定义unload事件的监听函数之后，页面不会保存在缓存中，而使用pagehide事件，页面会保存在缓存中。
	pagehide事件实例也有一个persisted属性，将这个属性设为true，就表示页面要保存在缓存中；设为false，表示网页不保存在缓存中，这时
如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。
	如果页面包含<frame>或<iframe>元素，则<frame>页面的pageshow事件和pagehide事件，都会在主页面之前触发。
	
	DOMContentLoaded 事件：
	当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，因为脚本可能会更改DOM，
脚本执行完成才会触发DOMContentLoaded事件。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。
	readystatechange事件：
	当 Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发。document.readyState有三个可能的值：loading（网页正在加载）、
interactive（网页已经解析完成，但是外部资源仍然处在加载状态）和complete（网页和所有外部资源已经结束加载，load事件即将触发）。
		document.onreadystatechange = function () {
		  if (document.readyState === 'interactive') {
			// ...相当于DOMContentLoaded事件
		  }
		}

浏览器渲染页面过程：
	1、HTML解析出DOM Tree
	2、CSS解析出Style Rules
	3、将二者关联生成Render Tree
	4、Layout 根据Render Tree计算每个节点的信息
	5、Painting 根据计算好的信息绘制整个页面
浏览器解析文档，当遇到<script>标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。
如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 defer或者async。
脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。

	现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析完成后才开始构建和布局渲染树。
部分的内容将被提前解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，
js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，
但是不会减少DOMContentLoaded被触发的时间。脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，
JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。

	hashchange事件：
	在 URL 的 hash 部分（即#号后面的部分，包括#号）发生变化时触发。该事件一般在window对象上监听。hashchange的事件实例具有两个特有属性：
oldURL属性和newURL属性，分别表示变化前后的完整 URL。
	scroll事件：在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。
	resize事件：在改变浏览器窗口大小时触发，主要发生在window对象上面。
	fullscreenchange事件：在进入或退出全屏状态时触发，该事件发生在document对象上面。
	copy事件：进行复制动作时触发。此事件是ClipboardEvent的实例，有一个实例属性clipboardData，是一个 DataTransfer 对象，存放剪贴的数据。

	focus：元素节点获得焦点后触发，该事件不会冒泡。
	blur：元素节点失去焦点后触发，该事件不会冒泡。
	由于focus和blur事件不会冒泡，只能在捕获阶段触发，所以addEventListener方法的第三个参数需要设为true。

	自定义事件：CustomEvent构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。
CustomEvent的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性：detail--表示事件的附带数据，默认为null。
	var myEvent = new CustomEvent('myevent', {
	  detail: {
		foo: 'bar'
	  },
	  bubbles: true,
	  cancelable: false
	});

	el.addEventListener('myevent', function (event) {
	  console.log('Hello ' + event.detail.foo);
	});

	el.dispatchEvent(myEvent);

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
GlobalEventHandlers 接口
	HTMLElement、Document和Window都继承了这个接口,这个接口提供了一种简洁的为元素添加事件处理函数的方式：div.onclick=function(e){...}。 
	abort属性：某个对象的abort事件（停止加载）发生时，就会调用onabort属性指定的回调函数。
	error属性：error事件发生时，就会调用onerror属性指定的回调函数。
	JavaScript 运行时错误，会传到window对象，触发window.onerror()。
	资源加载错误，比如<img>或<script>加载的资源出现加载错误；Error 对象会传到对应的元素，导致该元素的onerror属性指定的回调函数开始执行
	其他属性：onload\onloadstart\onfocus\onblur\onscroll 
	oncontextmenu:用户在页面上按下鼠标的右键，会触发contextmenu事件，导致执行oncontextmenu()。如果该属性执行后返回false，
就等于禁止了右键菜单。
	元素的右键菜单显示时，会触发该元素的onshow监听函数。

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
浏览器模型
	浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。
	代码嵌入网页的方法：1、<script>元素直接嵌入代码；2、<script>标签加载外部脚本；3、事件属性；4、URL 协议
	<script>元素有一个type属性，用来指定脚本类型，它有两个值，text/javascript和application/javascript，
type属性可以省略，那么默认取text/javascript，这个值是老的浏览器用来识别js脚本的，而新的浏览器使用
application/javascript，当然text/javascript也是可以识别的。如果type属性的值，浏览器不认识，那么它不会
执行其中的代码，但是这个<script>节点依然存在于 DOM 之中，可以使用<script>节点的text属性读出它的内容。
		<script id="mydata" type="x-custom-data">
			console.log('Hello World');  //不会执行
		</script>
	使用外部脚本时，如果脚本文件使用了非英语字符，还应该注明字符的编码。为了防止攻击者篡改外部脚本，
script标签允许设置一个integrity属性，写入该外部脚本的 Hash 签名（SHA256 签名），用来验证脚本的一致性。
		<script charset="utf-8" src="https://www.example.com/script.js" 
			integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
		</script>
	如果有多个script标签，浏览器会同时并行下载a.js和b.js，但是，执行时会保证先执行a.js，然后再执行b.js，
即使后者先下载完成
	在事件属性中添加js代码：<button id="myBtn" onclick="console.log(this.id)">点击</button>
	在 URL 的位置写入代码：<a href="javascript:console.log('Hello')">点击</a>
如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都
会消失。
如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。
	
	<script>元素的defer属性：它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。
		<script src="a.js" defer></script>
有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发
前执行（即刚刚读取完</html>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。
	<script>元素的async属性：使用另一个进程下载脚本，下载时不会阻塞渲染，async属性可以保证脚本下载
的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结
束，就先执行那个脚本。
	一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。
如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。
	<script>元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载：
	['a.js', 'b.js'].forEach(function(src) {
	  var script = document.createElement('script');
	  script.src = src;
	   script.async = false;  //保证b.js在a.js后面执行
	  script.onload = function() {  //回调
		done();
	  };
	  script.onerror = function() {  //回调
		done(new Error('Failed to load script ' + src));
	  };
	  document.head.appendChild(script);
	});
	
	浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。
	渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。
不同的浏览器有不同的渲染引擎。
		Firefox：Gecko 引擎
		Safari：WebKit 引擎
		Chrome：Blink 引擎
		IE: Trident 引擎
		Edge: EdgeHTML 引擎
	渲染引擎处理网页，通常分成四个阶段。
		解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
		对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
		布局：计算出渲染树的布局（layout）。
		绘制：将渲染树绘制到屏幕。
以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：
网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。
	页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也
会触发重流和重绘，比如设置了鼠标悬停（a:hover）效果、页面滚动等。
	重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；
改变元素的布局，则会导致重绘和重流。
	大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，
而不会全局重新生成网页。
	JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。
	为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的
中间代码，以提高运行速度。
	字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。
	常见的一些 JavaScript 虚拟机：
		Chakra (ie)
		Nitro/JavaScript Core (Safari)
		Carakan (Opera)
		SpiderMonkey (Firefox)
		V8 (Chrome, Chromium)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
window对象
	浏览器提供的window对象代表当前的浏览器窗口，但是设计语言时为了简单起见，也把window对象设计成了
当前页面的顶层对象，其他页面对象都是它的下级。其实这算是一个设计失误，因为一个变量如果未声明，那么
默认成为window对象的属性，这样就不能在编译阶段检测这种未声明的变量。
	window对象作为窗口的属性：
		window.name属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合
超链接和表单的target属性使用。该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。浏览器
通常可以保存高达几MB容量的name串。只要浏览器窗口不关闭，这个属性就不会消失，刷新窗口也不会改变属性值，
这样在同一个窗口连续打开多个网页，window.name属性值都可以访问到。
		window.closed属性返回一个布尔值，表示窗口是否关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。
			var popup = window.open();
			if ((popup !== null) && !popup.closed) {
			  // 窗口仍然打开着
			}
		window.opener属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null。
			window.open().opener === window // true
			如果两个窗口之间不需要通信，建议将子窗口的opener属性显式设为null，这样可以减少一些安全隐患。虽然浏览
器会限制子窗口访问父窗口的某些信息(Blocked a frame with origin "null" from accessing a cross-origin frame.)，但是
仍有一些信息可以被子窗口访问(如URL等)
		window.self和window.window属性都指向窗口本身。这两个属性只读。
		window.frames:这个frame是属性其实是window的别名，但是语义上更清晰。当页面包含有frame元素或iframe元素时，window的length属性就
大于0，这是可以使用frames[i]来获取第i个frame或iframe，显然这里写成window[i]是很容易产生误解的。
		window.length属性表示的就是页面包含的frame或iframe元素的总数。
		如果iframe元素设置了id或name属性，那么就可以用属性值，引用这个iframe窗口。比如<iframe name="myIFrame">可以用
frames['myIFrame']或者frames.myIFrame来引用。
		window.frameElement属性主要用于当前窗口嵌在另一个网页的情况（嵌入<object>、<iframe>或<embed>元素），返回当前窗口所在的那个
元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回null。
		window.top属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。如果当前窗口没有父窗口，window.top指向自身。
		window.parent属性指向父窗口。如果当前窗口没有父窗口，window.parent指向自身。
		window.status属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。
		window.devicePixelRatio属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 
像素由多少个物理像素组成。通过浏览器的缩小放大功能，可以观察到这个属性值的变化。
		window.screenX和window.screenY属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。
		window.innerHeight和window.innerWidth属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小
（单位像素）。这两个属性只读。放大窗口时，innerHeight和innerWidth会变小，这表明这两个属性表示的实际是当前可见部分页面在正常窗口大小时的像素值。
		outerHeight和outerWidth属性表示的是窗口的高和宽。只有浏览器窗口实际大小发生变化时才会改变。
		window.scrollX属性返回页面的水平滚动距离，window.scrollY属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。
		window.pageXOffset属性和window.pageYOffset属性，是window.scrollX和window.scrollY别名。
		window.locationbar\menubar\toolbar这些属性暂时都只提供了visible属性，而且只读，不是很实用。
window作为全局对象的属性：
		window.document：指向document对象，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。
		window.location：指向Location对象，用于获取当前窗口的 URL 信息。它等同于document.location属性。
		window.navigator：指向Navigator对象，用于获取环境信息。
		window.history：指向History对象，表示浏览器的浏览历史。
		window.localStorage：指向本地储存的 localStorage 数据。
		window.sessionStorage：指向本地储存的 sessionStorage 数据。
		window.console：指向console对象，用于操作控制台。
		window.screen：指向Screen对象，表示屏幕信息。height属性表示屏幕总高度，availHeight表示最大可用高度(不包括任务栏)，这两个属性都不会改变。
		window.isSecureContext属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是true，否则就是false。
window 对象的方法
		window.alert()方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，
浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。参数只能是字符串，没法使用 CSS 样式，但是可以用\n指定换行。
		window.prompt()方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。
			var result = prompt('您的年龄？', 25) //用户填入的值，会作为返回值存入变量result。
		window.confirm()方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。
			var result = confirm('你最近好吗？');  //如果用户点击“确定”，返回true；如果用户点击“取消”，则返回false。
		这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。
		window.open方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回null。
			var popup = window.open(
				'https://www.google.com.hk/', /*这里如果是当前域名下的页面可以不写域名*/
				'DefinitionsWindows',
				'height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes'
			);
			window.open("","","_blank")
		三个参数都可以省略，默认在新的标签页打开about:blank页面。
		window.close方法用于关闭当前窗口，一般只用来关闭window.open方法新建的窗口。popup.close();
		window.stop()方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。
		window.moveTo()方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。
		window.moveBy方法将窗口移动到一个相对位置。它接受两个参数，分布是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。
		目前只有该窗口是用window.open方法新建的，并且它所在的 Tab 页是当前窗口里面唯一的，这种情况才允许使用上面的两个方法。
		window.resizeTo()方法用于缩放窗口到指定大小。第一个是参数缩放后的窗口宽度（outerWidth属性，包含滚动条、标题栏等等），第二个参数是缩放后的
窗口高度（outerHeight属性）。
		window.resizeBy()方法使用相对数据缩放窗口：
			window.resizeBy(-200, -200)	//将当前窗口的宽度和高度，都缩小200像素。
		这两个方法现在也只能用于使用window.open打开的窗口。
		window.scrollTo方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。也接受一个配置对象作为参数。
			window.scrollTo(0, 0);	//回滚到页面头部
			window.scrollTo({top: 1000,left:200,behavior: 'smooth'});
		window.scroll()方法是window.scrollTo()方法的别名。
		window.scrollBy()方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。
			window.scrollBy(0, window.innerHeight) 	//将网页向下滚动一屏
		window.print方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。
			document.getElementById('printLink').onclick = function () {
				window.print();
			}
		window.focus()方法会激活窗口，使其获得焦点，出现在其他窗口的前面。window.blur()方法将焦点从窗口移除。
		当前窗口获得焦点时，会触发focus事件；当前窗口失去焦点时，会触发blur事件。
		window.getSelection方法返回一个Selection对象，表示用户现在选中的文本。
			var selectedText = window.getSelection().toString();
		window.getComputedStyle()方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象
		window.requestAnimationFrame()方法跟setTimeout类似，都是推迟某个函数的执行。不同之处在于，setTimeout必须指定推迟的时间，
window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率
		window.requestAnimationFrame()的返回值是一个整数，这个整数可以传入window.cancelAnimationFrame()，用来取消回调函数的执行。
				var element = document.getElementById('animate');
				element.style.position = 'absolute';

				var start = null;

				function step(timestamp) {
					if (!start) start = timestamp;
					var progress = timestamp - start;
					// 元素不断向左移，最大不超过200像素
					element.style.left = Math.min(progress / 10, 200) + 'px';
					// 如果距离第一次执行不超过 2000 毫秒，
					// 就继续执行动画
					if (progress < 2000) {
						window.requestAnimationFrame(step);
					}
				}

				window.requestAnimationFrame(step);
		window.requestIdleCallback()将回调函数推迟到系统资源空闲时执行。用来保证网页性能。接受一个回调函数和一个配置对象作为参数。配置对象
可以指定一个推迟执行的最长时间（timeout属性），如果过了这个时间，回调函数不管系统资源有无空虚，都会执行。
		回调函数执行时，系统会传入一个IdleDeadline对象作为参数。IdleDeadline对象有一个didTimeout属性（布尔值，表示是否为超时调用）和一个
timeRemaining()方法（返回该空闲时段剩余的毫秒数）。
		window.requestIdleCallback()方法返回一个整数。该整数可以传入window.cancelIdleCallback()取消回调函数。
		如果多次执行window.requestIdleCallback()，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。
事件监听属性：
		window.onload属性指定文档在浏览器窗口加载完毕这个事件的回调函数。
		window.onerror属性对浏览器脚本发生错误事件指定回调函数。由于历史原因，window的error事件的回调函数不接受错误对象作为参数，
而是一共可以接受五个参数（错误消息，脚本网址，行号，列号，错误对象）。如果脚本网址与网页网址不在同一个域，浏览器根本不会提供详
细的出错信息，只会提示出错。这是浏览器防止向外部泄露脚本信息，个解决方法是在脚本所在的服务器，设置Access-Control-Allow-Origin的 
HTTP 头信息，然后，在网页的<script>标签中设置crossorigin属性：<script crossorigin="anonymous" src="//example.com/file.js"></script>
		其他事件监听属性：window.onhashchange：hashchange事件的监听函数、window.onafterprint：afterprint事件的监听函数等
		对于iframe嵌入的窗口，document.getElementById方法可以拿到该窗口的 DOM 节点，然后使用contentWindow属性获得iframe节点包含的window对象。
这和使用window.frames[i]获得的对象是同一个对象。只有在满足同源限制的情况下，才可以读取子窗口内部的属性。
		<iframe>元素的contentDocument属性，可以拿到子窗口的document对象。window.frames[0].document也可以拿到这个document。
		<iframe>窗口的window对象，有一个frameElement属性，返回<iframe>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于null。
		每个窗口都有三个引用其他窗口的变量：top：顶层窗口，即最上层的那个窗口、parent：父窗口、self：当前窗口，即自身

==========================================================================================================================================
Navigator 对象
		window.navigator属性指向 Navigator 对象，这个对象包含浏览器和系统信息，脚本通过这个属性可以了解用户的环境信息。
		navigator.userAgent属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。但是通过userAgent属性识别浏览器，不是一个好办法。
现在通常使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能 来识别浏览器。
		不过，通过userAgent可以大致准确地识别手机浏览器，方法就是测试是否包含mobi字符串。
			var ua = navigator.userAgent.toLowerCase();
			if (/mobi/i.test(ua)) {
				// 手机浏览器
			} else {
				// 非手机浏览器
			}
		Navigator.plugins属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。
		Navigator.platform属性返回用户的操作系统信息，比如MacIntel、Win32、Linux x86_64等 。
		navigator.onLine属性返回一个布尔值，表示用户当前在线(无法区分是局域网还是公网)还是离线（浏览器断线）。
		用户变成在线会触发online事件，变成离线会触发offline事件，可以通过window.ononline和window.onoffline指定这两个事件的回调函数。
		Navigator.language属性返回一个字符串，表示浏览器的首选语言。该属性只读。
		Navigator.languages属性返回一个数组，表示用户可以接受的语言。Navigator.language总是这个数组的第一个成员。HTTP 请求头信息的
Accept-Language字段，就来自这个数组。
		Navigator.geolocation属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用，否则调用
下面方法时会报错。Geolocation 对象提供下面三个方法。
			Geolocation.getCurrentPosition()：得到用户的当前位置
			Geolocation.watchPosition()：监听用户位置变化
			Geolocation.clearWatch()：取消watchPosition()方法指定的监听函数
			注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。
		Navigator.cookieEnabled属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。这个属性反映的是浏览器总的特性，与是否储存某个具体
的网站的 Cookie 无关。
		Navigator.javaEnabled()方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。
		Navigator.sendBeacon()方法用于向服务器异步发送数据,待续...
======================================================================================================================================
Screen 对象
		Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。window.screen属性指向这个对象。
		Screen.height：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。
		Screen.width：浏览器窗口所在的屏幕的宽度（单位像素）。
		Screen.availHeight：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏
		Screen.availWidth：浏览器窗口可用的屏幕宽度（单位像素）。
		Screen.pixelDepth：整数，表示屏幕的色彩位数，比如24表示屏幕提供24位色彩。
		Screen.colorDepth：Screen.pixelDepth的别名。
		Screen.orientation：返回一个对象，表示屏幕的方向。该对象的type属性是一个字符串，表示屏幕的具体方向，landscape-primary表示横放，
landscape-secondary表示颠倒的横放，portrait-primary表示竖放，portrait-secondary。
		根据屏幕的宽度，将用户导向不同网页的代码：
			if ((screen.width <= 800) && (screen.height <= 600)) {
				window.location.replace('small.html');
			} else {
				window.location.replace('wide.html');
			}
		
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Cookie
		Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。
		Cookie 主要用来分辨两个请求是否来自同一个浏览器，以及用来保存一些状态信息。它的常用场合有以下一些:
			对话（session）管理：保存登录、购物车等需要记录的信息。
			个性化：保存用户的偏好，比如网页的字体大小、背景色等等。
			追踪：记录和分析用户行为。
		Cookie的内容：Cookie 的名字、Cookie 的值、到期时间、最大存活时间、域名、路径。
		浏览器可以设置不接受 Cookie，也可以设置不向服务器发送 Cookie。
		document.cookie属性返回当前网页的 Cookie。
			document.cookie
			// "_ga=GA1.2.1855025828.1552040729; _gid=GA1.2.247919174.1552040729; Hm_lvt_5eec262881855af3dede6a71234571f6=1551257361,1552006888,1552040729,1552102802; Hm_lpvt_5eec262881855af3dede6a71234571f6=1552110500"
		一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。
		浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie,这里不要求协议相同。
		Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。
		服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。Set-Cookie:foo=bar
		HTTP 回应可以包含多个Set-Cookie字段，即在浏览器生成多个 Cookie:
			HTTP/1.0 200 OK
			Content-type: text/html
			Set-Cookie: yummy_cookie=choco
			Set-Cookie: tasty_cookie=strawberry

			[page content]
		Set-Cookie字段还可以附加 Cookie 的属性。Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date>;Max-Age=<non-zero-digit>;Domain=<domain-value>;Path=<path-value>;Secure;HttpOnly
		如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的key、domain、path和secure都匹配。只要有一个属性不同，
就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。
		浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。	Cookie: foo=bar  多个Cookie: Cookie: name=value; name2=value2; name3=value3
		浏览器发送HTTP请求携带Cookie需要根据域名和路径来判断，如果路径为/，那么发往域名下所有路径的请求都会携带该Cookie，如果path为/test，则
只有发给域名/test路径及子路径的请求才会携带该Cookie
		浏览器发送出去的请求携带的cookie只有name和value值，而不包括Expire、Max-Age等信息。
		Cookie 的属性：
			Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用Date.prototype.toUTCString()
进行格式转换。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。
这个时间用来和浏览器本地时间比较，所以可能不太可靠。
		Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。
		如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。
		Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。
如果指定了domain属性，那么子域名也会附带这个 Cookie。如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。
		Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。
		Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。
		HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。
这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。

		document.cookie属性用于读写当前网页所有的 Cookie(没有HTTPOnly属性的Cookie)。document.cookie属性是可写的，可以通过它为当前网站添加 Cookie。
		document.cookie一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。
		写入的时候，Cookie 的值必须写成key=value的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义
（它们都不允许作为 Cookie 的值），这可以用encodeURIComponent方法达到。
			document.cookie = "foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT";
		Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。
		删除一个现存 Cookie 的唯一方法，是设置它的expires属性为一个过去的日期。
			document.cookie = 'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT';
==============================================================================================================================================
XMLHttpRequest 对象
	2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档
从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本
发起通信，就可以叫做 AJAX 通信。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了
	AJAX 包括以下几个步骤。
		创建 XMLHttpRequest 实例
		发出 HTTP 请求
		接收服务器传回的数据
		更新网页数据
	XMLHttpRequest对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有XML和Http，它实际上可以使用多种协议（比如file或ftp），
发送任何格式的数据（包括字符串和二进制）。XMLHttpRequest本身是一个构造函数，没有参数：
		var xhr = new XMLHttpRequest();
	XMLHttpRequest对象使用open方法设置请求地址、方法[以及是否异步执行(很多浏览器已经不支持设置同步调用，默认为true)、用户名和密码，这三个参数可选]。
对使用过open()方法的 AJAX 请求，再次使用这个方法，等同于调用abort()
		xhr.open('GET','http://www.example.com/page.php',true,'user','password');
	XMLHttpRequest对象使用onreadystatechange属性绑定 readyState属性改变(通常是请求完成、错误等)事件的回调方法。
		xhr.onreadystatechange = function(){
			console.log(xhr.response);
		}
	XMLHttpRequest对象使用send方法发送请求，根据请求方法的类型决定是否需要带参数。
	AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错
XMLHttpRequest对象的属性：
	readyState属性返回一个整数，表示实例对象的当前状态。该属性只读。值：
		0，表示 XMLHttpRequest 实例对象的open()方法还没有被调用。
		1，表示open()方法已经调用，但是实例的send()方法还没有调用，此时可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。
		2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。
		3，表示正在接收服务器传来的数据体（body 部分）。
		4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。
		readyState属性值的每次改变都会触发readyStateChange事件。
	onreadystatechange属性用于绑定一个监听函数。readystatechange事件发生时（实例的readyState属性变化），就会执行绑定的监听函数。
	response属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，该属性只读。
如果本次请求没有成功或者数据不完整，该属性等于null。但是，如果responseType属性等于text或空字符串，在请求没有结束之前（readyState等于3的阶段），
response属性包含服务器已经返回的部分数据。
	responseType属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用open()方法之后、调用send()方法之前，
设置这个属性的值，告诉服务器返回指定类型的数据。值：
		""（空字符串）和text：表示服务器返回文本数据。
		"json"：JSON 对象。（将这个属性设为json，浏览器实际上是对返回数据调用JSON.parse()方法得到json对象）
		"document"：Document 对象，表示服务器返回一个文档对象。
		"blob"：Blob 对象，表示服务器返回二进制对象。
		"arraybuffer"：ArrayBuffer 对象，表示服务器返回二进制数组。
	responseText属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。
	responseXML属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析
为 XML 或 HTML，该属性等于null。该属性生效的前提是 HTTP 回应的Content-Type头信息等于text/xml或application/xml。可以通过在发送请求前，
设置XMLHttpRequest.responseType属性为document做到。该属性得到的数据，是直接解析后的文档 DOM 树。
	responseURL属性是字符串，表示发送数据的服务器的网址。这个属性的值与open()方法指定的请求网址不一定相同。如果服务器端发生跳转，
这个属性返回最后实际返回数据的网址。
	status属性返回一个整数，表示服务器回应的 HTTP 状态码。请求发出之前，该属性为0。该属性只读。基本上，只有2xx和304的状态码，表示服务器返回是正常状态。
	statusText属性返回一个字符串，表示服务器发送的状态提示。不同于status属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前该属性的值是空字符串
	timeout属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。
	ontimeout属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。
	onloadstart属性用于绑定 loadstart 事件（HTTP 请求发出）的监听函数
	onprogress属性用于绑定 progress事件（正在发送和加载数据）的监听函数，progress事件的监听函数有一个事件对象参数，该对象有三个属性：
loaded属性返回已经传输的数据量，total属性返回总的数据量，lengthComputable属性返回一个布尔值，表示加载的进度是否可以计算。
	onabort属性用于绑定 abort 事件（请求中止，比如用户调用了abort()方法）的监听函数
	onerror属性用于绑定 error 事件（请求失败）的监听函数，如果发生网络错误（比如服务器无法连通），onerror事件无法获取报错信息。
	onload属性用于绑定 load 事件（请求成功完成）的监听函数
	onloadend属性用于绑定 loadend 事件（请求完成，不管成功或失败：abort、load和error这三个事件）的监听函数
	所有 XMLHttpRequest 的监听事件，都必须在send()方法调用之前设定。
	withCredentials属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，
即向example.com发出跨域请求时，不会发送example.com设置在本机上的 Cookie（如果有的话）。如果需要跨域 AJAX 请求发送 Cookie，需要将
withCredentials属性设为true。注意，同源的请求不需要设置这个属性。withCredentials属性设为true。同源的请求不需要设置这个属性。
只有服务器（能够）显式返回Access-Control-Allow-Credentials这个头信息才能确定这个属性生效。withCredentials属性打开也会保存跨域主机指定的 Cookie
	upload属性用于在使用AJAX上传文件时获取一个对象，通过观察这个对象，可以得知上传的进展。
XMLHttpRequest对象的方法：
	setRequestHeader()方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在open()之后、send()之前调用。设定同一个字段时，可以多次设置，
每一次调用的值会被合并成一个单一的值发送。
		xhr.setRequestHeader('Content-Type', 'application/json');
	overrideMimeType()方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理（通常不应该这样做）。使用：
如果服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，可以把 MIME 类型改成text/plain，
这样浏览器就不会去自动解析，这样就可以拿到原始文本了。
	希望服务器返回指定的数据类型，可以用responseType属性告诉服务器
	getResponseHeader()方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回null。该方法的参数不区分大小写。
	getAllResponseHeaders()方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用CRLF分隔（回车+换行），
如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。
	abort()方法用来终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。
	Navigator.sendBeacon() 用于卸载网页的时候，向服务器发送一些数据。（如果在unload事件或beforeunload事件的监听函数里面，使用XMLHttpRequest对象发送数据，
可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。如果使用同步模式则需要考虑浏览器是否仍然支持）
	Navigator.sendBeacon()方法使用异步发出请求，但是请求与当前页面脱钩，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。这个方法由浏览器
提供支持，接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），返回值是一个布尔值，成功发送数据为true，否则为false。
该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数

使用FormData对象构造表单数据：
	var formData = new FormData();
	//var formData = new FormData(form);	form是页面form元素对应的dom节点
	formData.append('username', '张三');
	formData.append('email', 'zhangsan@example.com');
	formData.append('birthDate', 1940);
	//使用AJAX提交表单
	var xhr = new XMLHttpRequest();
	xhr.open('POST', '/register');
	xhr.send(formData);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
同源限制
	1995年，同源限制由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。
	早期它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”（协议相同、域名相同、端口相同）
	现代同源限制的内容：无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB；无法接触非同源网页的 DOM；无法向非同源地址发送 AJAX 请求
（可以发送，但浏览器会拒绝接受响应）。
	通过 JavaScript 脚本可以拿到其他窗口的window对象时，如果是非同源的网页，目前只允许一个窗口接触其他网页的window对象的九个属性和四个方法：
		window.closed
		window.frames
		window.length
		window.location
		window.opener
		window.parent
		window.self
		window.top
		window.window
		window.blur()
		window.close()
		window.focus()
		window.postMessage()
	只有window.location是可读写的，其他八个全部都是只读。而且，即使是location对象，非同源的情况下，也只允许调用location.replace方法和写入location.href属性。
规避同源限制：
	Cookie共享：如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置document.domain共享 Cookie。浏览器允许修改document.domain为原值的后缀(也就是
一级域名)，对于www.example.com，document.domain可以被修改为example.com。如果设置document.domain为其他非当前域名后缀的域名，浏览器就会抛出异常。
A 和 B 两个网页都需要设置document.domain属性，才能达到同源的目的。因为设置document.domain的同时，会把端口重置为null，因此如果只设置一个网页的document.domain，
会导致两个网址的端口不同，还是达不到同源的目的。这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法规避同源政策
服务器可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如.example.com。
		Set-Cookie: key=value; domain=.example.com; path=/
这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。
	父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。
		document.getElementById("myIFrame").contentWindow.document
	子窗口获取主窗口的 DOM 也会报错：
		window.parent.document.body
	iframe窗口、window.open方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。
	如果两个窗口一级域名相同，只是二级域名不同，那么设置document.domain属性，就可以规避同源政策，拿到 DOM。
	片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。
父窗口可以把信息，写入子窗口的片段标识符,子窗口通过监听hashchange事件可以得到通知，子窗口也可以改变父窗口的片段标识符（经过测试子窗口不能读取父窗口的片段标识符）
	使用片段标识符进行跨域通信的技巧：域A页面使用iframe嵌入域B的页面，域B嵌入另一个域A的页面，域A页面可以修改域B页面的hash，域B页面监听hash改变后修改嵌入的域A的
hash，这个页面可以直接使用window.top调用顶层域A页面的方法完成通信。
	HTML5的跨文档通信 API：
	这个 API 为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。
		var popup = window.open('http://bbb.com', 'title');
		popup.postMessage('Hello World!', 'http://bbb.com');
		// 子窗口向父窗口发消息
		window.opener.postMessage('Nice to see you', 'http://aaa.com');
	postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。
	父窗口和子窗口都可以通过message事件，监听对方的消息。
		// 监听 message 消息
		window.addEventListener('message', function (e) {
		  console.log(e.data);
		},false);
		//使用onmessage 属性：
		window.onmessage = function(e) {
		  if (e.origin !== 'http://bbb.com') {
			return;
		  }
		  var payload = JSON.parse(e.data);
		  localStorage.setItem(payload.key, JSON.stringify(payload.data));	//可以将消息内容写到当前窗口的localstorage中
		};
	message事件的参数是事件对象event，提供以下三个属性：
		event.source：发送消息的窗口
		event.origin: 发送消息的网址	//子窗口可以通过这个属性向父窗口发送
		event.data: 消息内容
	LocalStorage的API：localStorage.setItem('key','value');		localStorage.getItem('key'); 	localStorage.removeItem('key');
JSONP:
	JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务端改造非常小。但是JSONP 只能发GET请求。
	它的基本思想是，网页通过添加一个<script>元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。
		function addScriptTag(src) {
		  var script = document.createElement('script');
		  script.setAttribute("type","text/javascript");
		  script.src = src;
		  document.body.appendChild(script);
		}

		window.onload = function () {
		  addScriptTag('http://example.com/ip?callback=foo');
		}

		function foo(data) {
		  console.log('Your public IP address is: ' + data.ip);
		};
	请求路径中的参数callback，用来指定回调函数的名字，这对于 JSONP 是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。
	WebSocket：是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
	WebSocket请求头：
		GET /chat HTTP/1.1
		Host: server.example.com
		Upgrade: websocket
		Connection: Upgrade
		Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
		Sec-WebSocket-Protocol: chat, superchat
		Sec-WebSocket-Version: 13
		Origin: http://example.com
	服务器可以根据Origin这个字段，判断是否许可本次通信
	WebSocket响应头：
		HTTP/1.1 101 Switching Protocols
		Upgrade: websocket
		Connection: Upgrade
		Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
		Sec-WebSocket-Protocol: chat
	=====================================================================================================================================
	CORS(跨域资源共享)
		CORS是W3C的标准，它允许浏览器向跨域的服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制。它需要浏览器和服务器同时支持，目前，所有浏览器都支持该功能。
		CORS 请求分成两类：简单请求和非简单请求
		简单请求：请求方法是以下三种方法之一：HEAD、GET、POST，HTTP，请求头信息只包括以下几种字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type，
	Content-Type的值只限于以下三个：application/x-www-form-urlencoded、multipart/form-data、text/plain
		不同时满足上面两个条件，就属于非简单请求。
		表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式。
		浏览器发现跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。
		如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器检查回应的头信息如果没有包含Access-Control-Allow-Origin字段，就抛出一个错误，这个错误会被
XMLHttpRequest的onerror回调函数捕获。这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。
		如果Origin指定的源，在许可范围内，返回的 HTTP 回应会多出几个头信息字段：
			Access-Control-Allow-Origin：一定会返回，值是发送请求的请求头中的origin或*；当Access-Control-Allow-Credentials为true时，这个属性值不能设为*
			Access-Control-Allow-Credentials：可选，值是一个布尔值（只能为true），表示是否接受浏览器发送的 Cookie，需要配合浏览器端XMLHttpRequest对象的withCredentials属性使用
			Access-Control-Expose-Headers: CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个服务器返回的基本字段：Cache-Control、Content-Language、Content-Type、
	Expires、Last-Modified、Pragma。在Access-Control-Expose-Headers里面指定希望拿到的其他字段。
	非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求.
	“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。预检请求还会携带请求头：
		Access-Control-Request-Method：必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法
		Access-Control-Request-Headers：可选，逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段
		服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
		服务器返回的响应中如果包含请求头：Access-Control-Allow-Origin，并且这个请求头为发送cors请求的域名或*，就表示允许跨域请求。
		如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。
		服务器不同意预检请求，会触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。
		服务器可以返回其他一些跨域请求相关的请求头：
			Access-Control-Allow-Methods: GET, POST, PUT	//允许的所有跨域请求的方法
			Access-Control-Allow-Headers: X-Custom-Header //服务器支持的所有头信息字段
			Access-Control-Allow-Credentials: true				//服务器是否接受跨域的cookie
			Access-Control-Max-Age: 1728000								//指定本次预检请求的有效期，单位为秒。
		一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。