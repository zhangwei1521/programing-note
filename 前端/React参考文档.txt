												React参考文档
	React 是一个用于构建用户界面的 JavaScript 库。
	React可以根据需要进行部分引入，也就是说可以在传统的项目的部分页面使用React，也可以创建一个完全基于React的项目。
	
	第一章
	在传统的非单页应用程序中使用React：
		1、在html页面中创建一个想要包含React组件的容器：（这里使用id属性标记容器，方便后面找到它）
			<div id="like_button_container"></div>
		2、引入React支持：
			<!-- 加载 React。-->
			<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
			<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
			<!-- 注意: 部署时，将 "development.js" 替换为 "production.min.js"。-->
		3、创建一个 React 组件：（like_button.js）
			'use strict';
			const e = React.createElement;
			class LikeButton extends React.Component {
				constructor(props) {
					super(props);
					this.state = { liked: false };
				}

				render() {
					if (this.state.liked) {
						return 'You liked this.';
					}

					return e(
						'button',
						{ onClick: () => this.setState({ liked: true }) },
						'Like'
					);
				}
			}
			//将上面的组件添加到页面的容器中，这两行不属于组件，但是在浏览器环境下也只好放在这里。
			const domContainer = document.querySelector('#like_button_container');
			ReactDOM.render(e(LikeButton), domContainer);
		4、加载创建的React组件：
			<script src="like_button.js"></script>
	如果要重用一个组件，可以在html页面上创建多个容器，为这些容器添加class属性，最后通过class查找到这些容器，遍历时
将每个组件添加到每个容器中。
		document.querySelectorAll('.like_button_container')
			.forEach(domContainer => {
				// Read the comment ID from a data-* attribute.
				const commentID = parseInt(domContainer.dataset.commentid, 10);
				ReactDOM.render(	//这里commentID不是组件的属性，需要在组件内通过this.props.commentID拿到
					e(LikeButton, { commentID: commentID }),	
					domContainer
				);
		});
	压缩组件：
		1、使用npm初始化项目为npm项目:	npm init -y
		2、安装terser:	npm install terser
		3、压缩指定js文件:	npx terser -c -m -o like_button.min.js -- like_button.js
	使用JSX语法创建组件：
		return (
			<button onClick={() => this.setState({ liked: true })}>
				Like
			</button>
		);
	引入babel脚本转换JSX语句，然后可以在设置了type="text/babel"的<script>标签内使用JSX语法，需要注意，这种方式
不能引用外部脚本文件：
		<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
		<script type="text/babel" >
			ReactDOM.render(
				<h1>Hello, world!</h1>,
				document.getElementById('root')
			);
		</script>
		//下面的写法会报错
		<script src="like_button.js" type="text/babel"></script>
	使用 JSX 预处理器：
		如果不是npm项目，需要先初始化项目为npm项目：npm init -y
		安装babel：npm install babel-cli@6 babel-preset-react-app@3
		将like_button.js移动到src目录下，修改为使用JSX语法的版本：
			...
			return (
				<button onClick={() => this.setState({ liked: true })}>
					Like
				</button>
			);
			...
			ReactDOM.render(<LikeButton name="zhangwei"/>, domContainer);
		执行命令：npx babel --watch src --out-dir . --presets react-app/prod 
	这个命令将会监听src目录下js文件的变化，在src目录外层生成一个同名的js文件，这个文件可以在浏览器运行，加载babel
预处理后的js文件：
		<script src="like_button.js"></script>
	这里JSX预处理器还是不能处理ES6的import语句，所以也就不能实现组件的组合了。

	第二章
	使用Create React App 创建react应用：
		npx create-react-app react2
	这个命令创建的react应用，可以使用 npm start 启动一个本地服务器监听3000端口，然后自动打开浏览器访问这个端口，
每次修改源代码后，应用将会自动更新到浏览器。可以使用 npm run build 生成一个build 文件夹，内部包括此应用的优化版本，
这通常用于正式环境中，默认发布路径为/（根路径），可以在package.json配置homepage属性调整发布路径：
		 "homepage":"e:/tem_file/react2/build"
	JSX简介：
	React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要
通知到 UI，以及需要在 UI 中展示准备好的数据。
	React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散
耦合单元之中，来实现关注点分离。
	React使用JSX来实现这种页面元素和逻辑的耦合单元。
	JSX是一个 JavaScript 的语法扩展，允许在逻辑代码中包含标签元素(建议将内容包裹在括号中)：
		const element = <h1>Hello, world!</h1>;
	在标签中包含逻辑代码：
		function formatName(user) {
			return user.firstName + ' ' + user.lastName;
		}

		const user = {
			firstName: 'Harper',
			lastName: 'Perez'
		};

		const element = (
			<h1 onClick={()=>console.log("hello")}>
				Hello, {formatName(user)}!
			</h1>
		);
	在编译之后，JSX表达式会被转为普通JavaScript函数调用，并且对其取值后得到 JavaScript 对象。所以可以将JSX表达式
赋值给变量，把JSX表达式当作参数传入，以及将JSX表达式作为函数返回值。
	在JSX表达式中，可以使用引号，将属性值指定为字符串字面量，也可以使用大括号，在属性值中插入一个JavaScript表达式：
		const element = <div tabIndex="0" name={username}></div>;
	 React DOM 使用camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定，例如JSX里的 class属性
变成了className，而tabindex则变为tabIndex。
	React DOM 在渲染所有输入内容之前，默认会进行转义。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS
（跨站脚本）攻击。
	Babel 将JSX表达式转译成一个名为 React.createElement() 函数调用：
		const element = (
			<h1 className="greeting">
				Hello, world!
			</h1>
		);
	转译后：
		const element = React.createElement(
			'h1',
			{className: 'greeting'},
			'Hello, world!'
		);
	React.createElement() 会创建一个如下结构的对象：
		const element = {
			type: 'h1',
			props: {
				className: 'greeting',
				children: 'Hello, world!'
			}
		};
	这类对象被称为 “React元素”。它们描述了我们希望在屏幕上看到的内容。React通过读取这些对象，然后使用它们来构建 DOM 
以及保持随时更新。
	React元素是构成 React 应用的最小单元，元素和组件是不同的概念，组件是由元素构成的。元素是React根据JSX表达式创建的
普通对象，React DOM 会负责更新 DOM 来与 React元素保持一致。
	使用react的应用的某个HTML文件的某处通常会有一个称为“根” DOM 节点的<div>，这个div内的所有内容都将由 React DOM 管理。
		<div id="root"></div>
	仅使用 React 构建的应用通常只有单一的根 DOM 节点。当然完全可以配置多个这种容器节点。
	ReactDOM.render()将一个 React 元素渲染到根 DOM 节点中：
		const element = <h1>Hello, world</h1>;
		ReactDOM.render(element, document.getElementById('root'));
	React 元素是不可变对象。一旦被创建，就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。
更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。//存疑.....待确定
	一个计时器：
		function tick() {
			const element = (
				<div>
					<h1>Hello, world!</h1>
					<h2>It is {new Date().toLocaleTimeString()}.</h2>
				</div>
			);
			ReactDOM.render(element, document.getElementById('root'));
		}
		setInterval(tick, 1000);
		//在实践中，大多数 React 应用只会调用一次 ReactDOM.render()。
	React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。前面的定时器每次
都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容。

	React将 UI 拆分为独立可复用的代码片段，这些代码片段就是独立设计的组件。组件类似于JavaScript 函数。它接受任意的入参
（即 “props”），并返回用于描述页面展示内容的 React 元素。
	可以使用JavaScript 函数作为组件，通常使用函数实现的组件具有如下形式：
		function Welcome(props) {
			return <h1>Hello, {props.name}</h1>;
		}
	参数名为props，返回一个JSX表达式，前面说过JSX表达式实际上是一个React元素。
	可以使用 ES6 的 class 来定义组件：
		class Welcome extends React.Component {
			render() {
				return <h1>Hello, {this.props.name}</h1>;
			}
		}
	函数没有状态，但是class具有自己的状态。
	React 元素除了可以是 标准的HTML(DOM)标签外，还可以是我们自定义的组件：
		const element = <Welcome name="Sara" />;
	使用自定义组件作为React元素时，JSX中的属性将被封装到一个名为"props"的对象中传递给组件。
	React要求组件名称必须以大写字母开头，小写字母开头的组件视为原生 DOM 标签。
	组件可以在其输出中引用其他组件：
		function Welcome(props) {
			return <h1>Hello, {props.name}</h1>;
		}

		function App() {
			return (
				<div>
					{/*这里引用了三次Welcome组件*/}
					<Welcome name="Sara" />					
					<Welcome name="Cahal" />
					<Welcome name="Edite" />
				</div>
			);
		}

		ReactDOM.render(
			<App />,
			document.getElementById('root')
		);	
	通常一个完整的React 应用程序的顶层组件是一个唯一的App组件。
	多层嵌套的组件通常难以维护，且很难复用它的各个部分，应该考虑把这样的组件细分为多个更细粒度的组件的组合，比如下面的组件：
		function Comment(props) {
			return (
				<div className="Comment">
					<div className="UserInfo">
						<img className="Avatar"
							src={props.author.avatarUrl}
							alt={props.author.name}
						/>
						<div className="UserInfo-name">
							{props.author.name}
						</div>
					</div>
					<div className="Comment-text">
						{props.text}
					</div>
					<div className="Comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}
	将图片提取出来构造一个新的可复用的组件：
		function Avatar(props) {
			return (
				<img className="Avatar"
					src={props.user.avatarUrl}
					alt={props.user.name}
				/>

			);
		}
	使用上面提取的组件构造新的UserInfo 组件：
		function UserInfo(props) {
			return (
				<div className="UserInfo">
					<Avatar user={props.user} />
					<div className="UserInfo-name">
						{props.user.name}
					</div>
				</div>
			);
		}
	最后组合提取的组件为原组件：
		function Comment(props) {
			return (
				<div className="Comment">
					<UserInfo user={props.author} />
					<div className="Comment-text">
						{props.text}
					</div>
					<div className="Comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}
	React要求Props的属性不能更改，意思是不能改变Props的属性的指向，例如不能这样写：
		props.obj=hello;
	但是可以修改props属性对象的属性：
		props.obj.name=hello;
	不修改入参的函数一般称为纯函数，React就要求所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。
	
	组件的状态：
	使用ES6的class实现的组件可以具有自己的状态，这种有状态的组件可以在更新状态后被react感知，然后react将根据更新后的组件去
渲染页面（调整DOM）。下面是一个时钟组件：
		import React,{Component} from "react";
		export default class Clock extends Component{
			constructor(props){
				super(props);
				this.state={
					count:0,
					date:new Date().toLocaleTimeString(),
				}
			}

			componentDidMount=()=>{
				this.timerId = setInterval(()=>this.setState({date:new Date().toLocaleTimeString()}),1000);
			}

			componentWillUnMount=()=>{
				clearInterval(this.timerId);
			}

			render(){
				console.log("clock: "+this.state.count++);
				return (<div>
					{this.state.date}
				</div>)
			}
		}
	组件每次通过setState()方法更新状态后，react将会调用组件的render方法，但是不会调用上层组件的render方法。
	this.state 可能会异步更新，即React 可能会把多个 setState() 调用合并成一个调用，所以最好不要依赖原值来更新下一个状态：
		this.setState({counter: this.state.counter});
	解决方案是让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：
		this.setState((state, props) => ({counter: state.counter + props.increment}));

	React事件机制：
	React 元素和 DOM 元素的事件处理不同之处有两点：
		1、React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
		2、使用 JSX 语法时需要传入一个函数作为事件处理函数，而不是一个字符串。
	在 React 中不能通过返回 false 的方式阻止默认行为，必须显式的使用 preventDefault ：
		function ActionLink() {
			function handleClick(e) {
				e.preventDefault();
				console.log('The link was clicked.');
			}
			return (
				<a href="#" onClick={handleClick}>
				Click me
				</a>
			);
		}
	在class中调用函数需要注意this问题，为了正确处理this问题，可以在constructor中为函数绑定this，或者使用箭头函数：
		class Toggle extends React.Component {
			constructor(props) {
				super(props);
				this.handleClick = this.handleClick.bind(this);
			}

			handleClick() {
				...
			}
			//使用箭头函数不需要在constructor中为函数绑定this
			handleClick = () =>{
				...
			}
			...
		}
	向事件处理函数传递额外的参数：
		<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
	条件渲染：
		<div>
			<h1>Hello!</h1>
			{ unreadMessages.length > 0 && <h2>You have {unreadMessages.length} unread messages.</h2> }
		</div>
	由于true && expression 总是返回 expression, 而 false && expression 总是返回 false。所以这种写法如果条件是 true，
&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。
	如果 组件的render 方法直接返回 null，组件将不会被渲染，但是这不会影响组件的生命周期。
	JSX允许在{}中引用一个React元素数组：
		const numbers = [1, 2, 3, 4, 5];
		const listItems = numbers.map((number) =>
			<li>{number}</li>
		);
		const uList = <ul>{listItems}</ul>;
	react希望在元素列表中的元素具有key属性，每个列表元素的key属性的值应该在列表内独一无二，react使用这个key值来识别列表元素
是否被修改，如果render后得到的"树"中列表元素key值没有修改，这个列表元素就不需要重新渲染（但是会将新的列表元素的属性同步到旧元
素上，这可能造成数据不一致）。通常列表元素的key值应该是该条数据的标识符id，如果没有id，可以使用索引或随机数代替，但是这些替代
写法只能消除react的警告，却有可能带来难以预测的问题，而且必定造成render性能损耗。
		const sidebar = (
			<ul>
			{props.posts.map((post) =>
				<li key={post.id}>
				{post.title}
				</li>
			)}
			</ul>
		);
	key 会传递信息给 React ，但不会传递给组件，即在组件内使用this.props.key不能获取设置的key。
	基于两个假设的react Diffing 算法：
	假设：
		两个不同类型的元素会产生出不同的树；
		开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；
	Diffing 算法是比较React的render()方法创建的树的差异的算法。react的render() 方法会创建一棵由 React 元素组成的树，
在下一次 state 或 props 更新时，相同的render()方法会返回一棵不同的树。标准的树比较算法的最好复杂程度为 O(n^3 )，基于
以上假设的算法可以优化到复杂度降为O(n)。
	react Diffing算法中，对比两颗树时，React 首先比较两棵树的根节点。当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。
这个过程中，如果子树有自定义组件，该组件实例的componentWillMount会先被调用(创建新的react元素)，然后再调用componentWillUnmount(销毁旧的
react元素)，最后调用componentDidMount(挂载新的react组件元素后调用)。
	当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。如果子树有自定义组件，子树组件的componentWillReceiveProps
方法会先被调用，然后是子组件的componentWillUpdate方法被调用。然后调用子组件的render() 方法。
	当更新 style 属性时，React 仅更新有所更变的属性。
	列表元素从上到下进行比较，如果顺序调整了，就会造成不必要的列表元素的销毁和新建：
		//旧的列表
		<ul>
			<li>Duke</li>
			<li>Villanova</li>
		</ul>
		//新的列表
		<ul>
			<li>Connecticut</li>	//和旧列表的第一个元素不同，所以旧列表的第一个元素(对应一个DOM节点)会被销毁，然后新建这个元素
			<li>Duke</li>			//这里又会销毁旧列表的第二个元素，然后新建这个元素
			<li>Villanova</li>		//实际上只有这个元素是需要新建的
		</ul>
	上面的列表更新会造成不必要的性能损耗，所以react要求为每个列表元素配置key属性，然后react就使用元素的key属性值来判断是否需要更新
		//旧的列表
		<ul>
			<li key="2015">Duke</li>
			<li key="2016">Villanova</li>
		</ul>
		//新的列表
		<ul>
			<li key="2014">Connecticut</li>		//旧列表中没有key为2014的元素，这个元素将会新建
			<li key="2015">Duke</li>			//key存在就列表中，表明只需要对旧列表中key为2015的元素移动位置
			<li key="2016">Villanova</li>		
		</ul>
	根据上面的说明可知，使用随机数作为key值会导致性能损耗，而且如果出现随机数重复，将导致更严重的数据正确性问题，使用索引作为key值，如果
元素顺序重排，也会导致数据正确性问题。


















	