												React参考文档
	React 是一个用于构建用户界面的 JavaScript 库。
	React可以根据需要进行部分引入，也就是说可以在传统的项目部分页面使用React，也可以创建一个完全基于React的项目。
	
	第一章
	在传统的非单页应用程序中使用React：
		1、在html页面中创建一个想要包含React组件的容器：（这里使用id属性标记容器，方便后面找到它）
			<div id="like_button_container"></div>
		2、引入React支持：
			<!-- 加载 React。-->
			<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
			<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
			<!-- 注意: 部署时，将 "development.js" 替换为 "production.min.js"。-->
		3、创建一个 React 组件：（like_button.js）
			'use strict';
			const e = React.createElement;
			class LikeButton extends React.Component {
				constructor(props) {
					super(props);
					this.state = { liked: false };
				}

				render() {
					if (this.state.liked) {
						return 'You liked this.';
					}

					return e(
						'button',
						{ onClick: () => this.setState({ liked: true }) },
						'Like'
					);
				}
			}
			//将上面的组件添加到页面的容器中，这两行不属于组件，但是在浏览器环境下也只好放在这里。
			const domContainer = document.querySelector('#like_button_container');
			ReactDOM.render(e(LikeButton), domContainer);
		4、加载创建的React组件：
			<script src="like_button.js"></script>
	如果要重用一个组件，可以在html页面上创建多个容器，为这些容器添加class属性，最后通过class查找到这些容器，遍历时
将每个组件添加到每个容器中。
		document.querySelectorAll('.like_button_container')
			.forEach(domContainer => {
				// Read the comment ID from a data-* attribute.
				const commentID = parseInt(domContainer.dataset.commentid, 10);
				ReactDOM.render(	//这里commentID不是组件的属性，需要在组件内通过this.props.commentID拿到
					e(LikeButton, { commentID: commentID }),	
					domContainer
				);
		});
	压缩组件：
		1、使用npm初始化项目为npm项目:	npm init -y
		2、安装terser:	npm install terser
		3、压缩指定js文件:	npx terser -c -m -o like_button.min.js -- like_button.js
	使用JSX语法创建组件：
		return (
			<button onClick={() => this.setState({ liked: true })}>
				Like
			</button>
		);
	引入babel脚本转换JSX语句，然后可以在设置了type="text/babel"的<script>标签内使用JSX语法，需要注意，这种方式
不能引用外部脚本文件：
		<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
		<script type="text/babel" >
			ReactDOM.render(
				<h1>Hello, world!</h1>,
				document.getElementById('root')
			);
		</script>
		//下面的写法会报错
		<script src="like_button.js" type="text/babel"></script>
	使用 JSX 预处理器：
		如果不是npm项目，需要先初始化项目为npm项目：npm init -y
		安装babel：npm install babel-cli@6 babel-preset-react-app@3
		将like_button.js移动到src目录下，修改为使用JSX语法的版本：
			...
			return (
				<button onClick={() => this.setState({ liked: true })}>
					Like
				</button>
			);
			...
			ReactDOM.render(<LikeButton name="zhangwei"/>, domContainer);
		执行命令：npx babel --watch src --out-dir . --presets react-app/prod 
	这个命令将会监听src目录下js文件的变化，在src目录外层生成一个同名的js文件，这个文件可以在浏览器运行，加载babel
预处理后的js文件：
		<script src="like_button.js"></script>
	这里JSX预处理器还是不能处理ES6的import语句，所以也就不能实现组件的组合了。

	第二章
	使用Create React App 创建react应用：
		npx create-react-app react2
	这个命令创建的react应用，可以使用 npm start 启动一个本地服务器监听3000端口，然后自动打开浏览器访问这个端口，
每次修改源代码后，应用将会自动更新到浏览器。可以使用 npm run build 生成一个build 文件夹，内部包括此应用的优化版本，
这通常用于正式环境中，默认发布路径为/（根路径），可以在package.json配置homepage属性调整发布路径：
		 "homepage":"e:/tem_file/react2/build"
	JSX简介：
	React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要
通知到 UI，以及需要在 UI 中展示准备好的数据。
	React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散
耦合单元之中，来实现关注点分离。
	React使用JSX来实现这种页面元素和逻辑的耦合单元。
	JSX是一个 JavaScript 的语法扩展，允许在逻辑代码中包含标签元素(建议将内容包裹在括号中)：
		const element = <h1>Hello, world!</h1>;
	在标签中包含逻辑代码：
		function formatName(user) {
			return user.firstName + ' ' + user.lastName;
		}

		const user = {
			firstName: 'Harper',
			lastName: 'Perez'
		};

		const element = (
			<h1 onClick={()=>console.log("hello")}>
				Hello, {formatName(user)}!
			</h1>
		);
	在编译之后，JSX表达式会被转为普通JavaScript函数调用，并且对其取值后得到 JavaScript 对象。所以可以将JSX表达式
赋值给变量，把JSX表达式当作参数传入，以及将JSX表达式作为函数返回值。
	在JSX表达式中，可以使用引号，将属性值指定为字符串字面量，也可以使用大括号，在属性值中插入一个JavaScript表达式：
		const element = <div tabIndex="0" name={username}></div>;
	 React DOM 使用camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定，例如JSX里的 class属性
变成了className，而tabindex则变为tabIndex。
	React DOM 在渲染所有输入内容之前，默认会进行转义。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS
（跨站脚本）攻击。
	Babel 将JSX表达式转译成一个名为 React.createElement() 函数调用：
		const element = (
			<h1 className="greeting">
				Hello, world!
			</h1>
		);
	转译后：
		const element = React.createElement(
			'h1',
			{className: 'greeting'},
			'Hello, world!'
		);
	React.createElement() 会创建一个如下结构的对象：
		const element = {
			type: 'h1',
			props: {
				className: 'greeting',
				children: 'Hello, world!'
			}
		};
	这类对象被称为 “React元素”。它们描述了我们希望在屏幕上看到的内容。React通过读取这些对象，然后使用它们来构建 DOM 
以及保持随时更新。
	React元素是构成 React 应用的最小单元，元素和组件是不同的概念，组件是由元素构成的。元素是React根据JSX表达式创建的
普通对象，React DOM 会负责更新 DOM 来与 React元素保持一致。
	使用react的应用的某个HTML文件的某处通常会有一个称为“根” DOM 节点的<div>，这个div内的所有内容都将由 React DOM 管理。
		<div id="root"></div>
	仅使用 React 构建的应用通常只有单一的根 DOM 节点。当然完全可以配置多个这种容器节点。
	ReactDOM.render()将一个 React 元素渲染到根 DOM 节点中：
		const element = <h1>Hello, world</h1>;
		ReactDOM.render(element, document.getElementById('root'));
	React 元素是不可变对象。一旦被创建，就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。
更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。
	一个计时器：
		function tick() {
			const element = (
				<div>
					<h1>Hello, world!</h1>
					<h2>It is {new Date().toLocaleTimeString()}.</h2>
				</div>
			);
			ReactDOM.render(element, document.getElementById('root'));
		}
		setInterval(tick, 1000);
		//在实践中，大多数 React 应用只会调用一次 ReactDOM.render()。
	React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。前面的定时器每次
都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容。





















	