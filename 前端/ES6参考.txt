													ES6参考
							(参考书籍：阮一峰:ECMAScript 6 入门: http://es6.ruanyifeng.com/)
	第一章 let和const
	var命令声明的变量作用域是全局或函数作用域，let和const声明的变量作用域是声明处的代码块：
		{
		  var a = 1;
		  let b = 2;
		  const c = 3; 
		}
		console.log("a = " + a);	//a = 1
		console.log("b = " + b);	//ReferenceError
		console.log("c = " + c);	//ReferenceError
		
		function f1() {
			let n = 5;
			if (true) {
				let n = 10;
			}
			console.log(n);
		}
		f1();	// 5
	使用块级作用域替换IIFE立即执行函数表达式：
		{
			{
				let a = 1;
				{
					let a = 2;	//允许覆盖外层作用域的变量声明
				}
			}
			console.log("a is not defined");
			console.log(a);	//ReferenceError: a is not defined
		}
	es6之前的js只有全局作用域的问题：
		var tmp = new Date();
		function f() {
			console.log(tmp);
			if (false) {
				var tmp = 'hello world';
			}
		}
		f(); // undefined	--变量声明提升覆盖全局数据tmp,导致tmp为undefined
	js使用let/const的for循环的特殊之处：
		每一次循环的i都是一个新的变量：
			let a = [];
			for (let i = 0; i < 2; i++) {
				a[i] = function () {
					console.log(i);
				};
			}
			a[0]();		//0
			a[1]();		//1
		设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域；
		循环体内部（块级作用域）内使用let/const声明和外部相同的变量名时，该变量名在代码块内部形成"暂时性死区"，而且没有变量声明提升：
			for (let i = 0; i < 2; i++) {
				//console.log(i);	ReferenceError	--没有变量声明提升，形成暂时性死区
				let i = 'abc';
				console.log(i);
			}
			// abc
			// abc
			typeof x; // ReferenceError --没有变量声明提升，typeof不再完全安全
			let x;
			let y=y;	// ReferenceError --暂时性死区
	使用var的for循环：
		全局只有一个循环变量i:
			var a = [];
			for (var i = 0; i < 10; i++) {
			  a[i] = function () {
				console.log(i);
			  };
			}
			a[6](); // 10
	let/const不允许在相同作用域内，重复声明同一个变量。	
		let a = 'a';
		var/let/const a = 'b';		//SyntaxError
	ES5标准规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
	但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。
	ES6允许在块级作用域之中声明函数。
	ES5下运行：
		function f() { console.log('I am outside!'); }
		(function () {
		  if (false) {
			// 重复声明一次函数f
			function f() { console.log('I am inside!'); }
		  }
		  f();
		}());
		输出：I am inside! 	//ES5下函数f被提升到外层函数头部
	ES6下运行上面的代码，理论上应该得到“I am outside!”，但是如果这样就会造成无法兼容旧代码，所以 ES6标准在附录 B里面规定，浏览器的实现
可以不实现前面的逻辑，允许ES6浏览器像var一样把代码块内的函数声明提升到外层函数作用域头部，所以ES6浏览器实际上执行：
		输出：Uncaught TypeError: f is not a function	//因为只有函数声明被提升了：var f = undefined;
	const声明的变量不允许改变（存储变量名的内存地址的值不能修改，即变量名不能再指向其他内存地址）：
		const a = "a";
		a = "b";	//TypeError
		const b;	//SyntaxError	因为不允许在修改b的值，所以必须设置初始化值
	ES6规定，let命令、const命令、class命令声明的全局变量，不再是属于顶层对象的属性。
	在 Web浏览器中，可以通过 window、self 或者 frames 取到全局对象；在 Web Workers 中只有 self 可以取到全局对象。在 Node.js 中，必须使用
global才能取到全局对象。
	现在有一个新提案，提出引入globalThis作为顶层对象，该提案目前处于Stage 3，Chrome71、Firefox65开始支持这个globalThis作为顶层对象。

	第二章	解构赋值
	解构赋值的含义：按照一定模式，从数组和对象中提取值，对变量进行赋值
		let [a, b, c] = [1, 2, 3];
		let [x, , y] = [1, 2, 3];						//y:3
		let [foo, [[bar], baz]] = [1, [[2], 3]];		//bar:2
		let [head, ...tail] = [1, 2, 3, 4];				//tail:[2,3,4]
		let [a,b] = ['a'];								//b:undefined	这里不会抛错
		let [x, y] = [1, 2, 3];
		let { bar, foo } = { foo: 'aaa', bar: 'bbb' };	//对象的解构赋值是根据属性名称实现的，与顺序无关
		const { log } = console;
	解构赋值表达式等号右边的结构必须是可遍历的结构，否则将报错：
		let [a] = 1;	//报错
		let {a} = 1;	//不会报错，1会被转成对象
	解构赋值指定默认值：
		let [foo = true] = [];
		let [x, y = 'b'] = ['a'];
		let [x = 1] = [undefined];		//x:1	ES6 内部使用严格相等运算符（===），判断一个位置是否有值
		let [x = 1] = [null];			//x:null
		let [x = 1, y = x] = []; 		//y:1
		let [x = y, y = 1] = [];     	// ReferenceError: y is not defined
		var {x = 3} = {};
		var {x: y = 3} = {};			//y:3
		var {x = 3} = {x: undefined};	//x:3
		var {x = 3} = {x: null};		//x:null
	如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值:
		function f() {
			console.log('aaa');
		}
		let [x = f()] = [1];	//f不会执行
	对象的解构赋值允许使用不同的属性名：
		let { foo: baz } = { foo: 'aaa', bar: 'bbb' };		//baz:"aaa"
	对象的解构赋值的本质：
		let { foo,bar} = { foo: 'aaa', bar: 'bbb' };	=>
		let {foo:foo,bar:bar} = { foo: 'aaa', bar: 'bbb' };
		let {foo: {bar}} = {baz: 'baz'};	//报错，解构对象没有foo属性
	对象的解构赋值可以取到继承的属性：
		const obj1 = {};
		const obj2 = { foo: 'bar' };
		Object.setPrototypeOf(obj1, obj2);
		const { foo } = obj1;
		foo 		// "bar"
	将一个已经声明的变量用于解构赋值:
		let x;
		{x} = {x: 1};		//SyntaxError,这里js引擎将{x}当成了表达式
		({x} = {x: 1});		//可以实现解构赋值
	像对象一样对数组进行解构赋值：
		let {0:a,1:b} = [1,2];	//数组本质是特殊的对象,1、2都是属性名
	字符串可以解构赋值，字符串会被转换成一个类似数组的对象再进行操作：
		const [a, b, c, d, e] = 'hello';
	数字或boolean值可以进行对象的解构赋值:
		let {toString: s} = 123;
		s === Number.prototype.toString // true; s虽然是一个函数，但是不能调用，因为函数内部引用了this，但这时的this不是原来的数字
	解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
		let { prop: x } = undefined; // TypeError
		let { prop: y } = null; // TypeError
	函数的参数可以使用解构赋值语法：
		function func([x=0, y=0]){
			return x + y;
		}
		func([1, 2]); 		// 3
		function func2({x=0, y=0}={}){
			return [x,y]
		}
		func2(); 			//[0,0]
		func2({}); 			//[0,0]
		func2({x:3}); 		//[3,0]
	不正确的用法：
		let [(a)] = [1];	//报错，声明变量不允许这样使用()
		let {x: (c)} = {};	//报错，声明变量不允许这样使用()
		function f([(z)]) { return z; }		//报错，函数参数不允许这样使用()
	赋值语句中使用():
		([a]) = [5];		//报错
		[(b)] = [3]; 		//b:3 不会报错
	解构赋值的应用：
		let x = 1, y =2;
		[x, y] = [y, x];							//交换x、y
		let {foo, bar } = example();				//从函数返回的数组或对象中取出需要的值
		let {id,data:number} = jsonData;			//从json对象中取出需要的值
		function f({x=0, y=0, z=0}) { ... }			//定义函数参数并设置默认值
		import {func1,func2} from "./funcModal";	//获取需要的导出对象
		const map = new Map();
		map.set('first', 'hello');
		map.set('second', 'world');
		for (let [key, value] of map) {				//遍历map结构，使用[key]只遍历key值，使用[,value]只遍历value
			console.log(key + " is " + value);
		}
	第三章 字符串的扩展
	ES6之前的标准提供一种字符(串)的表示方法：\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。'\u007A'==='z'；
这种表示法只能表示码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。
		"\uD842\uDFB7" // "𠮷"
		"\u20BB7" // " 7" js引擎解释：\u20BB+7
	ES6标准允许把码点(十六进制)放入大括号，实现对码点超出\uFFFF的字符的正确解析：
		"\u{20BB7}"==="𠮷"，这里"\u{20BB7}".length===2
		'\u{62}\u{63}'	// "bc"
	ES6 为字符串添加了遍历器接口,使得字符串可以被for...of循环遍历。
		for (let codePoint of 'foo') {
			console.log(codePoint)
		}
	对于含有码点大于0xFFFF的字符的字符串，传统的for循环无法获取这样的字符：
		let text = String.fromCodePoint(0x20BB7);
		for (let i = 0; i < text.length; i++) {
			console.log(text[i]);
		}
		//打印两次：" "
	遍历器接口中的for...of循环可以正确获取上面的字符：
		for (let codePoint of text) {
			console.log(codePoint)
		}
		//打印一次："𠮷"
	ES2019新提案允许在字符串里直接使用U+2028（行分隔符）和 U+2029（段分隔符）（之前的标准不允许在字符串中直接使用，
但是JSON标准允许字符串直接使用这两个字符，这样JSON.parse(jsonData)就会报错）（Chrome74已经支持）
	ES2019 修改了JSON.stringify()的：如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，
留给应用自己决定下一步的处理（这是为了保证通过JSON.stringify()方法得到的JSON的字符串中的字符都符合UTF-8标准）。
	模板字符串(使用反引号`表示)可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
		`In JavaScript '\n' is a line-feed.`
		console.log(`a
		 b`)	//换行、空格将被保留
		alert(`a
		 b`)	//换行、空格将被保留
		let name = "Bob", time = "today";
		`Hello ${name}, how are you ${time}?`
		`\`Yo\` World!`		//转义`
	模板字符串的${}内部还可以使用js表达式:
		let x = 1, y = 2, obj = {x: 1, y: 2};
		`${x} + ${y} = ${x + y}`
		`${obj.x + obj.y}`
		function fn() {
			return "Hello World";
		}
		`foo ${fn()} bar`	//可以调用函数（引用函数返回值）
	模板字符串允许嵌套。
	标签模板：函数调用的一种特殊形式，“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数：
		alert`123`	==>		alert(123)
		console.log`abcd`	==>		console.log(['abcd']);
		let name = "jame";
		console.log`hello ${name}`	==>		console.log(['hello ',''],jame);

	ES5为String对象提供一个fromCharCode方法，用于从Unicode码点返回对应的UTF-16编码字符：String.fromCharCode(0x0BB7)==="ஷ"
但是这个方法只能返回Unicode码点小于等于65535（0xFFFF）的字符，如果码点超出范围，将被舍弃超出的高位：String.fromCharCode(0x20BB7)==="ஷ"
	ES6为String对象新增了一个fromCodePoint方法，也用于从Unicode码点返回对应的UTF-8编码字符，但是可以接受任意的Unicode码点：String.fromCodePoint(0x20BB7)==='𠮷'
	ES6为String对象新增了一个raw()方法，用于处理字符串（默认转义\）：String.raw`Hi\n${2+3}!`; // Hi\n5! (这里不能转为上面的标签模板来理解)
String.raw作为普通方法使用：String.raw({ raw: 'test' }, 0, 1, 2);	//"t0e1s2t"	(将后面的参数依次间隔插入第一个参数字符串)
	JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。
	ES6 为字符串实例提供了codePointAt()方法，用于返回正确的字符码点：
		'𠮷a'.codePointAt(0) //134071	使用toString(16)转为16进制：'𠮷a'.codePointAt(0).toString(16)	//20bb7
		'𠮷a'.codePointAt(1) //57271	这里返回的数据其实也是不准确的，返回的是'𠮷'的后两个字节的码点
		'𠮷a'.codePointAt(2) // 97		a需要使用2作为参数才能得到码点，可以使用for...of循环解决这个问题：
			for (let ch of '𠮷a') {		//for...of循环可以正确获取四个字节的字符：
				console.log(ch.codePointAt(0));
			}
	ES6为字符串实例提供一个normalize()方法，用于将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化：
		'\u01D1'								// "Ǒ"
		'\u004F\u030C'							// "Ǒ"
		'\u004F\u030C'==='\u01D1'				// false
		'\u004F\u030C'.normalize()==='\u01d1'	// true
		'\u004F\u030C'.normalize();				// "Ǒ"
		'\u004F\u030C'.normalize().length		// 1
		'\u004F\u030C'.normalize().charCodeAt(0)	// 465
		'\u004F\u030C'.normalize().codePointAt(0)	// 465
		'\u004F\u030C'.codePointAt(0);				// 79
	normalize方法可以接受一个参数来指定normalize的方式:
		"NFC"，默认参数，表示“标准等价合成”,返回多个简单字符的合成字符;
		"NFD"，表示“标准等价分解”,返回合成字符分解的多个简单字符;
		"NFKC"，表示“兼容等价合成”,返回语义上存在等价，但视觉上不一定等价的合成字符；
		"NFKD"，表示“兼容等价分解”，返回语义上存在等价，但视觉上不一定等价的分解字符
	normalize方法目前不能识别三个或三个以上字符的合成（所以不支持中文）。
	ES6之前的js都只提供一个indexOf方法可以用来确定一个字符串是否包含在另一个字符串中
	ES6新增了includes(s)方法判断参数字符串是否存在、startsWith(s)方法判断参数字符串是否在当前字符串的头部、endsWith(s)方法判断参数字符串是否在当前字符串的尾部。
这三个方法都支持第二个参数，表示开始搜索的位置：
		'Hello world!'.startsWith('world', 6) // true
		'Hello world!'.includes('Hello', 6) // false
	ES6为字符串实例新增一个repeat方法，返回一个新字符串，表示将原字符串重复n次：
		'x'.repeat(3) // "xxx"
		'x'.repeat(0) // ""
	repeat方法可以接收除了 <=-1 和 Infinity的所有数字以及字符：'x'.repeat(2.9) // "xx"		'x'.repeat(-0.9) //""
	ES2017 引入了字符串补全长度的方法：padStart()用于头部补全，padEnd()用于尾部补全：
		'x'.padStart(5, 'ab') // 'ababx' 如果省略第二个参数，默认使用空格补全长度。
		'x'.padEnd(5, 'ab') // 'xabab'	如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
	ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()[这个方法会消除字符串两端的空格]一致，trimStart()只消除字符串头部的空格，
trimEnd()只消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。
	