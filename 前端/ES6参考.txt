													ES6参考
							(参考书籍：阮一峰:ECMAScript 6 入门: http://es6.ruanyifeng.com/)
	第一章 let和const
	var命令声明的变量作用域是全局或函数作用域，let和const声明的变量作用域是声明处的代码块：
		{
		  var a = 1;
		  let b = 2;
		  const c = 3; 
		}
		console.log("a = " + a);	//a = 1
		console.log("b = " + b);	//ReferenceError
		console.log("c = " + c);	//ReferenceError
		
		function f1() {
			let n = 5;
			if (true) {
				let n = 10;
			}
			console.log(n);
		}
		f1();	// 5
	使用块级作用域替换IIFE立即执行函数表达式：
		{
			{
				let a = 1;
				{
					let a = 2;	//允许覆盖外层作用域的变量声明
				}
			}
			console.log("a is not defined");
			console.log(a);	//ReferenceError: a is not defined
		}
	es6之前的js只有全局作用域的问题：
		var tmp = new Date();
		function f() {
			console.log(tmp);
			if (false) {
				var tmp = 'hello world';
			}
		}
		f(); // undefined	--变量声明提升覆盖全局数据tmp,导致tmp为undefined
	js使用let/const的for循环的特殊之处：
		每一次循环的i都是一个新的变量：
			let a = [];
			for (let i = 0; i < 2; i++) {
				a[i] = function () {
					console.log(i);
				};
			}
			a[0]();		//0
			a[1]();		//1
		设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域；
		循环体内部（块级作用域）内使用let/const声明和外部相同的变量名时，该变量名在代码块内部形成"暂时性死区"，而且没有变量声明提升：
			for (let i = 0; i < 2; i++) {
				//console.log(i);	ReferenceError	--没有变量声明提升，形成暂时性死区
				let i = 'abc';
				console.log(i);
			}
			// abc
			// abc
			typeof x; // ReferenceError --没有变量声明提升，typeof不再完全安全
			let x;
			let y=y;	// ReferenceError --暂时性死区
	使用var的for循环：
		全局只有一个循环变量i:
			var a = [];
			for (var i = 0; i < 10; i++) {
			  a[i] = function () {
				console.log(i);
			  };
			}
			a[6](); // 10
	let/const不允许在相同作用域内，重复声明同一个变量。	
		let a = 'a';
		var/let/const a = 'b';		//SyntaxError
	ES5标准规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
	但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。
	ES6允许在块级作用域之中声明函数。
	ES5下运行：
		function f() { console.log('I am outside!'); }
		(function () {
		  if (false) {
			// 重复声明一次函数f
			function f() { console.log('I am inside!'); }
		  }
		  f();
		}());
		输出：I am inside! 	//ES5下函数f被提升到外层函数头部
	ES6下运行上面的代码，理论上应该得到“I am outside!”，但是如果这样就会造成无法兼容旧代码，所以 ES6标准在附录 B里面规定，浏览器的实现
可以不实现前面的逻辑，允许ES6浏览器像var一样把代码块内的函数声明提升到外层函数作用域头部，所以ES6浏览器实际上执行：
		输出：Uncaught TypeError: f is not a function	//因为只有函数声明被提升了：var f = undefined;
	const声明的变量不允许改变（存储变量名的内存地址的值不能修改，即变量名不能再指向其他内存地址）：
		const a = "a";
		a = "b";	//TypeError
		const b;	//SyntaxError	因为不允许在修改b的值，所以必须设置初始化值
	ES6规定，let命令、const命令、class命令声明的全局变量，不再是属于顶层对象的属性。
	在 Web浏览器中，可以通过 window、self 或者 frames 取到全局对象；在 Web Workers 中只有 self 可以取到全局对象。在 Node.js 中，必须使用
global才能取到全局对象。
	现在有一个新提案，提出引入globalThis作为顶层对象，该提案目前处于Stage 3，Chrome71、Firefox65开始支持这个globalThis作为顶层对象。

	第二章	解构赋值
	解构赋值的含义：按照一定模式，从数组和对象中提取值，对变量进行赋值
		let [a, b, c] = [1, 2, 3];
		let [x, , y] = [1, 2, 3];						//y:3
		let [foo, [[bar], baz]] = [1, [[2], 3]];		//bar:2
		let [head, ...tail] = [1, 2, 3, 4];				//tail:[2,3,4]
		let [a,b] = ['a'];								//b:undefined	这里不会抛错
		let [x, y] = [1, 2, 3];
		let { bar, foo } = { foo: 'aaa', bar: 'bbb' };	//对象的解构赋值是根据属性名称实现的，与顺序无关
		const { log } = console;
		let {group:{one,two}} = {group:{one:1,two:2}};	// one -- 1;	tow -- 2
	解构赋值表达式等号右边的结构必须是可遍历的结构，否则将报错：
		let [a] = 1;	//报错
		let {a} = 1;	//不会报错，1会被转成对象
	解构赋值指定默认值：
		let [foo = true] = [];
		let [x, y = 'b'] = ['a'];
		let [x = 1] = [undefined];		//x:1	ES6 内部使用严格相等运算符（===），判断一个位置是否有值
		let [x = 1] = [null];			//x:null
		let [x = 1, y = x] = []; 		//y:1
		let [x = y, y = 1] = [];     	// ReferenceError: y is not defined
		var {x = 3} = {};
		var {x: y = 3} = {};			//y:3
		var {x = 3} = {x: undefined};	//x:3
		var {x = 3} = {x: null};		//x:null
	如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值:
		function f() {
			console.log('aaa');
		}
		let [x = f()] = [1];	//f不会执行
	对象的解构赋值允许使用不同的属性名：
		let { foo: baz } = { foo: 'aaa', bar: 'bbb' };		//baz:"aaa"
	对象的解构赋值的本质：
		let { foo,bar} = { foo: 'aaa', bar: 'bbb' };	=>
		let {foo:foo,bar:bar} = { foo: 'aaa', bar: 'bbb' };
		let {foo: {bar}} = {baz: 'baz'};	//报错，解构对象没有foo属性
	对象的解构赋值可以取到继承的属性：
		const obj1 = {};
		const obj2 = { foo: 'bar' };
		Object.setPrototypeOf(obj1, obj2);
		const { foo } = obj1;
		foo 		// "bar"
	将一个已经声明的变量用于解构赋值:
		let x;
		{x} = {x: 1};		//SyntaxError,这里js引擎将{x}当成了表达式
		({x} = {x: 1});		//可以实现解构赋值
	像对象一样对数组进行解构赋值：
		let {0:a,1:b} = [1,2];	//数组本质是特殊的对象,1、2都是属性名
	字符串可以解构赋值，字符串会被转换成一个类似数组的对象再进行操作：
		const [a, b, c, d, e] = 'hello';
	数字或boolean值可以进行对象的解构赋值:
		let {toString: s} = 123;
		s === Number.prototype.toString // true; s虽然是一个函数，但是不能调用，因为函数内部引用了this，但这时的this不是原来的数字
	解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
		let { prop: x } = undefined; // TypeError
		let { prop: y } = null; // TypeError
	函数的参数可以使用解构赋值语法：
		function func([x=0, y=0]){
			return x + y;
		}
		func([1, 2]); 		// 3
		function func2({x=0, y=0}={}){
			return [x,y]
		}
		func2(); 			//[0,0]
		func2({}); 			//[0,0]
		func2({x:3}); 		//[3,0]
	不正确的用法：
		let [(a)] = [1];	//报错，声明变量不允许这样使用()
		let {x: (c)} = {};	//报错，声明变量不允许这样使用()
		function f([(z)]) { return z; }		//报错，函数参数不允许这样使用()
	赋值语句中使用():
		([a]) = [5];		//报错
		[(b)] = [3]; 		//b:3 不会报错
	解构赋值的应用：
		let x = 1, y =2;
		[x, y] = [y, x];							//交换x、y
		let {foo, bar } = example();				//从函数返回的数组或对象中取出需要的值
		let {id,data:number} = jsonData;			//从json对象中取出需要的值
		function f({x=0, y=0, z=0}) { ... }			//定义函数参数并设置默认值
		import {func1,func2} from "./funcModal";	//获取需要的导出对象
		const map = new Map();
		map.set('first', 'hello');
		map.set('second', 'world');
		for (let [key, value] of map) {				//遍历map结构，使用[key]只遍历key值，使用[,value]只遍历value
			console.log(key + " is " + value);
		}

	第三章 字符串的扩展
	ES6之前的标准提供一种字符(串)的表示方法：\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。'\u007A'==='z'；
这种表示法只能表示码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。
		"\uD842\uDFB7" // "𠮷"
		"\u20BB7" // " 7" js引擎解释：\u20BB+7
	ES6标准允许把码点(十六进制)放入大括号，实现对码点超出\uFFFF的字符的正确解析：
		"\u{20BB7}"==="𠮷"，这里"\u{20BB7}".length===2
		'\u{62}\u{63}'	// "bc"
	ES6 为字符串添加了遍历器接口,使得字符串可以被for...of循环遍历。
		for (let codePoint of 'foo') {
			console.log(codePoint)
		}
	对于含有码点大于0xFFFF的字符的字符串，传统的for循环无法获取这样的字符：
		let text = String.fromCodePoint(0x20BB7);
		for (let i = 0; i < text.length; i++) {
			console.log(text[i]);
		}
		//打印两次：" "
	遍历器接口中的for...of循环可以正确获取上面的字符：
		for (let codePoint of text) {
			console.log(codePoint)
		}
		//打印一次："𠮷"
	ES2019新提案允许在字符串里直接使用U+2028（行分隔符）和 U+2029（段分隔符）（之前的标准不允许在字符串中直接使用，
但是JSON标准允许字符串直接使用这两个字符，这样JSON.parse(jsonData)就会报错）（Chrome74已经支持）
	ES2019 修改了JSON.stringify()的：如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，
留给应用自己决定下一步的处理（这是为了保证通过JSON.stringify()方法得到的JSON的字符串中的字符都符合UTF-8标准）。
	模板字符串(使用反引号`表示)可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
		`In JavaScript '\n' is a line-feed.`
		console.log(`a
		 b`)	//换行、空格将被保留
		alert(`a
		 b`)	//换行、空格将被保留
		let name = "Bob", time = "today";
		`Hello ${name}, how are you ${time}?`
		`\`Yo\` World!`		//转义`
	模板字符串的${}内部还可以使用js表达式:
		let x = 1, y = 2, obj = {x: 1, y: 2};
		`${x} + ${y} = ${x + y}`
		`${obj.x + obj.y}`
		function fn() {
			return "Hello World";
		}
		`foo ${fn()} bar`	//可以调用函数（引用函数返回值）
	模板字符串允许嵌套。
	标签模板：函数调用的一种特殊形式，“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数：
		alert`123`	==>		alert(123)
		console.log`abcd`	==>		console.log(['abcd']);
		let name = "jame";
		console.log`hello ${name}`	==>		console.log(['hello ',''],jame);

	ES5为String对象提供一个fromCharCode方法，用于从Unicode码点返回对应的UTF-16编码字符：String.fromCharCode(0x0BB7)==="ஷ"
但是这个方法只能返回Unicode码点小于等于65535（0xFFFF）的字符，如果码点超出范围，将被舍弃超出的高位：String.fromCharCode(0x20BB7)==="ஷ"
	ES6为String对象新增了一个fromCodePoint方法，也用于从Unicode码点返回对应的UTF-8编码字符，但是可以接受任意的Unicode码点：String.fromCodePoint(0x20BB7)==='𠮷'
	ES6为String对象新增了一个raw()方法，用于处理字符串（默认转义\）：String.raw`Hi\n${2+3}!`; // Hi\n5! (这里不能转为上面的标签模板来理解)
String.raw作为普通方法使用：String.raw({ raw: 'test' }, 0, 1, 2);	//"t0e1s2t"	(将后面的参数依次间隔插入第一个参数字符串)
	JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。
	ES6 为字符串实例提供了codePointAt()方法，用于返回正确的字符码点：
		'𠮷a'.codePointAt(0) //134071	使用toString(16)转为16进制：'𠮷a'.codePointAt(0).toString(16)	//20bb7
		'𠮷a'.codePointAt(1) //57271	这里返回的数据其实也是不准确的，返回的是'𠮷'的后两个字节的码点
		'𠮷a'.codePointAt(2) // 97		a需要使用2作为参数才能得到码点，可以使用for...of循环解决这个问题：
			for (let ch of '𠮷a') {		//for...of循环可以正确获取四个字节的字符：
				console.log(ch.codePointAt(0));
			}
	ES6为字符串实例提供一个normalize()方法，用于将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化：
		'\u01D1'								// "Ǒ"
		'\u004F\u030C'							// "Ǒ"
		'\u004F\u030C'==='\u01D1'				// false
		'\u004F\u030C'.normalize()==='\u01d1'	// true
		'\u004F\u030C'.normalize();				// "Ǒ"
		'\u004F\u030C'.normalize().length		// 1
		'\u004F\u030C'.normalize().charCodeAt(0)	// 465
		'\u004F\u030C'.normalize().codePointAt(0)	// 465
		'\u004F\u030C'.codePointAt(0);				// 79
	normalize方法可以接受一个参数来指定normalize的方式:
		"NFC"，默认参数，表示“标准等价合成”,返回多个简单字符的合成字符;
		"NFD"，表示“标准等价分解”,返回合成字符分解的多个简单字符;
		"NFKC"，表示“兼容等价合成”,返回语义上存在等价，但视觉上不一定等价的合成字符；
		"NFKD"，表示“兼容等价分解”，返回语义上存在等价，但视觉上不一定等价的分解字符
	normalize方法目前不能识别三个或三个以上字符的合成（所以不支持中文）。
	ES6之前的js都只提供一个indexOf方法可以用来确定一个字符串是否包含在另一个字符串中
	ES6新增了includes(s)方法判断参数字符串是否存在、startsWith(s)方法判断参数字符串是否在当前字符串的头部、endsWith(s)方法判断参数字符串是否在当前字符串的尾部。
这三个方法都支持第二个参数，表示开始搜索的位置：
		'Hello world!'.startsWith('world', 6) // true
		'Hello world!'.includes('Hello', 6) // false
	ES6为字符串实例新增一个repeat方法，返回一个新字符串，表示将原字符串重复n次：
		'x'.repeat(3) // "xxx"
		'x'.repeat(0) // ""
	repeat方法可以接收除了 <=-1 和 Infinity的所有数字以及字符：'x'.repeat(2.9) // "xx"		'x'.repeat(-0.9) //""
	ES2017 引入了字符串补全长度的方法：padStart()用于头部补全，padEnd()用于尾部补全：
		'x'.padStart(5, 'ab') // 'ababx' 如果省略第二个参数，默认使用空格补全长度。
		'x'.padEnd(5, 'ab') // 'xabab'	如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
	ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()[这个方法会消除字符串两端的空格]一致，trimStart()只消除字符串头部的空格，
trimEnd()只消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。
	
	第四章 正则表达式增强
	ES5构造正则表达式对象的合法语法：
		var regex = /xyz/i;
		var regex = new RegExp('xyz', 'i');
		var regex = new RegExp(/xyz/i);
	ES5中不合法的语法：
		var regex = new RegExp(/xyz/, 'i');		//报错
	ES6允许上面的语法，并且会使用后面的参数替换前面的修饰符：
		new RegExp(/abc/ig, 'i').flags		// "i"
	ES6标准将字符串的match()、replace()、search()和split()方法实现改为调用RegExp的实例方法，实现了所有与正则相关的方法，全都定义在RegExp对象上。
	ES6为正则表达式对象新增了Unicode模式，使用u修饰符：
		/^\uD83D/.test('\uD83D\uDC2A') // true	这里\uD83D\uDC2A是一个字符，但是js不能识别这种需要4个字节的字符，当成了两个字符，所以匹配成功
		/^\uD83D/u.test('\uD83D\uDC2A'')	//false 使用u修饰符后正确的识别了原字符
		/^.$/.test('𠮷') // false
		/^.$/u.test('𠮷') // true
	正则表达式中使用大括号表示 Unicode 字符必须要加u修饰符才能正确匹配：
		/\u{61}/.test('a') // false
		/\u{61}/u.test('a') // true
		/\u{20BB7}/u.test('𠮷') // true
	Unicode模式下可以正确识别非规范字符：
		/K/i.test('\u212A')	//false
		/K/iu.test('\u212A') //true
	正则表达式对象新增一个unicode属性可以返回是否为Unicode模式。
	ES6为正则表达式对象新增了粘连模式，使用y修饰符。
	y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确
保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
		var s = 'aaa_aa_a';
		var r1 = /a+/g;
		var r2 = /a+/y;
		r1.exec(s) // ["aaa"]
		r2.exec(s) // ["aaa"]
		r1.exec(s) // ["aa"]
		r2.exec(s) // null
	字符串的match方法中，正则表达式只使用y修饰符，只会返回第一个匹配项，如果需要返回所有的匹配项，还需要使用g修饰符：
		'a1a2a3'.match(/a\d/y) // ["a1"]
		'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]
	ES6中正则实例对象新增了sticky属性，表示是否设置了y修饰符。
	ES6 为正则表达式新增了flags属性，返回正则表达式的修饰符。
		/abc/ig.source		// "abc"，ES5中正则表达式的source属性返回模式字符串
		/abc/ig.flags		// "ig",ES6中正则表达式的flags属性返回修饰符
	正则表达式中.字符表示任意字符，但是不能表示4个字节的字符和行终止符：
		/^.$/.test('\u20bb7') 	// false
		/^.$/u.test('\u20bb7') 	// true	使用u修饰符可以用.匹配4个字节的字符
		/^.$/.test("\n")		//false	不能识别换行符
		/^.$/.test("\r")		//false	不能识别回车符
		/^.$/.test("\u{2028}")	//false	不能识别行分隔符
		/^.$/.test("\u{2029}")	//false	不能识别段分隔符
		/^./m.test("ab\ncd")	//true	多行修饰符m可以匹配换行符
	ES2018 引入s修饰符，称为dotAll模式，使得.可以匹配任意单个字符：
		/^.$/s.test("\n")		// true
		/^.$/s.test('\u20bb7') 	// false	s修饰符还是不能识别4个字节的字符
	正则表达式对象也相应的新增了一个dotAll属性，表示是否设置了s修饰符。
	ES2018之前JS不支持后行(否定)断言，只支持先行(否定)断言。
	先行断言：x只有在y前面才匹配，必须写成/x(?=y)/
		/\d+(?=%)/.exec('80%ab');		// ["80"]
	先行否定断言：x只有不在y前面才匹配，必须写成/x(?!y)/
		/\d+(?!%)/.exec('5% not 4'); 	// ["4"]
	ES2018开始支持后行(否定)断言，V8引擎4.9版（Chrome 62）开始提供支持。
	后行断言：x只有在y后面才匹配，必须写成/(?<=y)x/
		/(?<=\$)\d+/.exec("100 and $101 or #102");	// ["101"]
		"100 and $101 or #102".replace(/(?<=\$)\d+/,"99")	// "100 and $99 or #102"
	后行否定断言：x只有不在y后面才匹配，必须写成/(?<!y)x/
		/(?<!\$)\d+/.exec("100 and $101 or #102");	// ["100"]
	ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符,格式：
		\p{UnicodePropertyName=UnicodePropertyValue}
		/\p{Script=Greek}/u.test('π')	//true	\p{Script=Greek}/u表示匹配一个希腊文字符
	对于某些属性，可以只写属性名，或者只写属性值：
		/^\p{Decimal_Number}+$/u.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼')	// true	匹配十进制数字
		/\p{Number}+/u	// 匹配任意数字字符（包括罗马数字）
		\p{White_Space}	// 匹配所有空格
	普通组匹配,只能用数字序号引用匹配项：
		const matchArr = /(\d{4})-(\d{2})-(\d{2})/.exec('1999-12-31');
		matchArr[0]		// "1999-12-31"
		matchArr[1]		// "1999"
		matchArr[2]		//	"12"
		matchArr[3]		//	"31"
	ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。
		const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
		const matchArr = RE_DATE.exec('1999-12-31')；
		matchArr.groups.year		// "1999"
		matchArr.groups.month		// "12"
		matchArr.groups.day			// "31"
	使用解构赋值从组匹配中取值：
		let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
		one		// foo
		tow 	// bar
	使用具名组替换：
		let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
		'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
		// '02/01/2015'
	正则表达式内部可以使用组名称代替\i引用组：
		/^(?<word>[a-z]+)!\k<word>$/ 等价于 /^(?<word>[a-z]+)!\1$/ 	（二者使用==和===运算返回false）
	ES6现在有一个新提案，希望增加String.prototype.matchAll方法，返回一个遍历器，一次性取出字符串中所有匹配正则表达式的匹配性：
		const string = 'test1test2test3';
		const regex = /t(e)(st(\d?))/g;
		for (const match of string.matchAll(regex)) {
  			console.log(match);
		}
		// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
		// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
		// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]