													ES6参考
							(参考书籍：阮一峰:ECMAScript 6 入门: http://es6.ruanyifeng.com/)
	第一章 let和const
	var命令声明的变量作用域是全局或函数作用域，let和const声明的变量作用域是声明处的代码块：
		{
		  var a = 1;
		  let b = 2;
		  const c = 3; 
		}
		console.log("a = " + a);	//a = 1
		console.log("b = " + b);	//ReferenceError
		console.log("c = " + c);	//ReferenceError
		
		function f1() {
			let n = 5;
			if (true) {
				let n = 10;
			}
			console.log(n);
		}
		f1();	// 5
	使用块级作用域替换IIFE立即执行函数表达式：
		{
			{
				let a = 1;
				{
					let a = 2;	//允许覆盖外层作用域的变量声明
				}
			}
			console.log("a is not defined");
			console.log(a);	//ReferenceError: a is not defined
		}
	es6之前的js只有全局作用域的问题：
		var tmp = new Date();
		function f() {
			console.log(tmp);
			if (false) {
				var tmp = 'hello world';
			}
		}
		f(); // undefined	--变量声明提升覆盖全局数据tmp,导致tmp为undefined
	js使用let/const的for循环的特殊之处：
		每一次循环的i都是一个新的变量：
			let a = [];
			for (let i = 0; i < 2; i++) {
				a[i] = function () {
					console.log(i);
				};
			}
			a[0]();		//0
			a[1]();		//1
		设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域；
		循环体内部（块级作用域）内使用let/const声明和外部相同的变量名时，该变量名在代码块内部形成"暂时性死区"，而且没有变量声明提升：
			for (let i = 0; i < 2; i++) {
				//console.log(i);	ReferenceError	--没有变量声明提升，形成暂时性死区
				let i = 'abc';
				console.log(i);
			}
			// abc
			// abc
			typeof x; // ReferenceError --没有变量声明提升，typeof不再完全安全
			let x;
			let y=y;	// ReferenceError --暂时性死区
	使用var的for循环：
		全局只有一个循环变量i:
			var a = [];
			for (var i = 0; i < 10; i++) {
			  a[i] = function () {
				console.log(i);
			  };
			}
			a[6](); // 10
	let/const不允许在相同作用域内，重复声明同一个变量。	
		let a = 'a';
		var/let/const a = 'b';		//SyntaxError
	ES5标准规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
	但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。
	ES6允许在块级作用域之中声明函数。
	ES5下运行：
		function f() { console.log('I am outside!'); }
		(function () {
		  if (false) {
			// 重复声明一次函数f
			function f() { console.log('I am inside!'); }
		  }
		  f();
		}());
		输出：I am inside! 	//ES5下函数f被提升到外层函数头部
	ES6下运行上面的代码，理论上应该得到“I am outside!”，但是如果这样就会造成无法兼容旧代码，所以 ES6标准在附录 B里面规定，浏览器的实现
可以不实现前面的逻辑，允许ES6浏览器像var一样把代码块内的函数声明提升到外层函数作用域头部，所以ES6浏览器实际上执行：
		输出：Uncaught TypeError: f is not a function	//因为只有函数声明被提升了：var f = undefined;
	const声明的变量不允许改变（存储变量名的内存地址的值不能修改，即变量名不能再指向其他内存地址）：
		const a = "a";
		a = "b";	//TypeError
		const b;	//SyntaxError	因为不允许在修改b的值，所以必须设置初始化值
	ES6规定，let命令、const命令、class命令声明的全局变量，不再是属于顶层对象的属性。
	在 Web浏览器中，可以通过 window、self 或者 frames 取到全局对象；在 Web Workers 中只有 self 可以取到全局对象。在 Node.js 中，必须使用
global才能取到全局对象。
	现在有一个新提案，提出引入globalThis作为顶层对象，该提案目前处于Stage 3，Chrome71、Firefox65开始支持这个globalThis作为顶层对象。

	第二章	解构赋值
	解构赋值的含义：按照一定模式，从数组和对象中提取值，对变量进行赋值
		let [a, b, c] = [1, 2, 3];
		let [x, , y] = [1, 2, 3];						//y:3
		let [foo, [[bar], baz]] = [1, [[2], 3]];		//bar:2
		let [head, ...tail] = [1, 2, 3, 4];				//tail:[2,3,4]
		let [a,b] = ['a'];								//b:undefined	这里不会抛错
		let [x, y] = [1, 2, 3];
		let { bar, foo } = { foo: 'aaa', bar: 'bbb' };	//对象的解构赋值是根据属性名称实现的，与顺序无关
		const { log } = console;
		let {group:{one,two}} = {group:{one:1,two:2}};	// one -- 1;	tow -- 2
	解构赋值表达式等号右边的结构必须是可遍历的结构，否则将报错：
		let [a] = 1;	//报错
		let {a} = 1;	//不会报错，1会被转成对象
	解构赋值指定默认值：
		let [foo = true] = [];
		let [x, y = 'b'] = ['a'];
		let [x = 1] = [undefined];		//x:1	ES6 内部使用严格相等运算符（===），判断一个位置是否有值
		let [x = 1] = [null];			//x:null
		let [x = 1, y = x] = []; 		//y:1
		let [x = y, y = 1] = [];     	// ReferenceError: y is not defined
		var {x = 3} = {};
		var {x: y = 3} = {};			//y:3
		var {x = 3} = {x: undefined};	//x:3
		var {x = 3} = {x: null};		//x:null
	如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值:
		function f() {
			console.log('aaa');
		}
		let [x = f()] = [1];	//f不会执行
	对象的解构赋值允许使用不同的属性名：
		let { foo: baz } = { foo: 'aaa', bar: 'bbb' };		//baz:"aaa"
	对象的解构赋值的本质：
		let { foo,bar} = { foo: 'aaa', bar: 'bbb' };	=>
		let {foo:foo,bar:bar} = { foo: 'aaa', bar: 'bbb' };
		let {foo: {bar}} = {baz: 'baz'};	//报错，解构对象没有foo属性
	对象的解构赋值可以取到继承的属性：
		const obj1 = {};
		const obj2 = { foo: 'bar' };
		Object.setPrototypeOf(obj1, obj2);
		const { foo } = obj1;
		foo 		// "bar"
	将一个已经声明的变量用于解构赋值:
		let x;
		{x} = {x: 1};		//SyntaxError,这里js引擎将{x}当成了表达式
		({x} = {x: 1});		//可以实现解构赋值
	像对象一样对数组进行解构赋值：
		let {0:a,1:b} = [1,2];	//数组本质是特殊的对象,1、2都是属性名
	字符串可以解构赋值，字符串会被转换成一个类似数组的对象再进行操作：
		const [a, b, c, d, e] = 'hello';
	数字或boolean值可以进行对象的解构赋值:
		let {toString: s} = 123;
		s === Number.prototype.toString // true; s虽然是一个函数，但是不能调用，因为函数内部引用了this，但这时的this不是原来的数字
	解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
		let { prop: x } = undefined; // TypeError
		let { prop: y } = null; // TypeError
	函数的参数可以使用解构赋值语法：
		function func([x=0, y=0]){
			return x + y;
		}
		func([1, 2]); 		// 3
		function func2({x=0, y=0}={}){
			return [x,y]
		}
		func2(); 			//[0,0]
		func2({}); 			//[0,0]
		func2({x:3}); 		//[3,0]
	不正确的用法：
		let [(a)] = [1];	//报错，声明变量不允许这样使用()
		let {x: (c)} = {};	//报错，声明变量不允许这样使用()
		function f([(z)]) { return z; }		//报错，函数参数不允许这样使用()
	赋值语句中使用():
		([a]) = [5];		//报错
		[(b)] = [3]; 		//b:3 不会报错
	解构赋值的应用：
		let x = 1, y =2;
		[x, y] = [y, x];							//交换x、y
		let {foo, bar } = example();				//从函数返回的数组或对象中取出需要的值
		let {id,data:number} = jsonData;			//从json对象中取出需要的值
		function f({x=0, y=0, z=0}) { ... }			//定义函数参数并设置默认值
		import {func1,func2} from "./funcModal";	//获取需要的导出对象
		const map = new Map();
		map.set('first', 'hello');
		map.set('second', 'world');
		for (let [key, value] of map) {				//遍历map结构，使用[key]只遍历key值，使用[,value]只遍历value
			console.log(key + " is " + value);
		}

	第三章 字符串的扩展
	ES6之前的标准提供一种字符(串)的表示方法：\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。'\u007A'==='z'；
这种表示法只能表示码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。
		"\uD842\uDFB7" // "𠮷"
		"\u20BB7" // " 7" js引擎解释：\u20BB+7
	ES6标准允许把码点(十六进制)放入大括号，实现对码点超出\uFFFF的字符的正确解析：
		"\u{20BB7}"==="𠮷"，这里"\u{20BB7}".length===2
		'\u{62}\u{63}'	// "bc"
	ES6 为字符串添加了遍历器接口,使得字符串可以被for...of循环遍历。
		for (let codePoint of 'foo') {
			console.log(codePoint)
		}
	对于含有码点大于0xFFFF的字符的字符串，传统的for循环无法获取这样的字符：
		let text = String.fromCodePoint(0x20BB7);
		for (let i = 0; i < text.length; i++) {
			console.log(text[i]);
		}
		//打印两次：" "
	遍历器接口中的for...of循环可以正确获取上面的字符：
		for (let codePoint of text) {
			console.log(codePoint)
		}
		//打印一次："𠮷"
	ES2019新提案允许在字符串里直接使用U+2028（行分隔符）和 U+2029（段分隔符）（之前的标准不允许在字符串中直接使用，
但是JSON标准允许字符串直接使用这两个字符，这样JSON.parse(jsonData)就会报错）（Chrome74已经支持）
	ES2019 修改了JSON.stringify()的：如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，
留给应用自己决定下一步的处理（这是为了保证通过JSON.stringify()方法得到的JSON的字符串中的字符都符合UTF-8标准）。
	模板字符串(使用反引号`表示)可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
		`In JavaScript '\n' is a line-feed.`
		console.log(`a
		 b`)	//换行、空格将被保留
		alert(`a
		 b`)	//换行、空格将被保留
		let name = "Bob", time = "today";
		`Hello ${name}, how are you ${time}?`
		`\`Yo\` World!`		//转义`
	模板字符串的${}内部还可以使用js表达式:
		let x = 1, y = 2, obj = {x: 1, y: 2};
		`${x} + ${y} = ${x + y}`
		`${obj.x + obj.y}`
		function fn() {
			return "Hello World";
		}
		`foo ${fn()} bar`	//可以调用函数（引用函数返回值）
	模板字符串允许嵌套。
	标签模板：函数调用的一种特殊形式，“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数：
		alert`123`	==>		alert(123)
		console.log`abcd`	==>		console.log(['abcd']);
		let name = "jame";
		console.log`hello ${name}`	==>		console.log(['hello ',''],jame);

	ES5为String对象提供一个fromCharCode方法，用于从Unicode码点返回对应的UTF-16编码字符：String.fromCharCode(0x0BB7)==="ஷ"
但是这个方法只能返回Unicode码点小于等于65535（0xFFFF）的字符，如果码点超出范围，将被舍弃超出的高位：String.fromCharCode(0x20BB7)==="ஷ"
	ES6为String对象新增了一个fromCodePoint方法，也用于从Unicode码点返回对应的UTF-8编码字符，但是可以接受任意的Unicode码点：String.fromCodePoint(0x20BB7)==='𠮷'
	ES6为String对象新增了一个raw()方法，用于处理字符串（默认转义\）：String.raw`Hi\n${2+3}!`; // Hi\n5! (这里不能转为上面的标签模板来理解)
String.raw作为普通方法使用：String.raw({ raw: 'test' }, 0, 1, 2);	//"t0e1s2t"	(将后面的参数依次间隔插入第一个参数字符串)
	JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。
	ES6 为字符串实例提供了codePointAt()方法，用于返回正确的字符码点：
		'𠮷a'.codePointAt(0) //134071	使用toString(16)转为16进制：'𠮷a'.codePointAt(0).toString(16)	//20bb7
		'𠮷a'.codePointAt(1) //57271	这里返回的数据其实也是不准确的，返回的是'𠮷'的后两个字节的码点
		'𠮷a'.codePointAt(2) // 97		a需要使用2作为参数才能得到码点，可以使用for...of循环解决这个问题：
			for (let ch of '𠮷a') {		//for...of循环可以正确获取四个字节的字符：
				console.log(ch.codePointAt(0));
			}
	ES6为字符串实例提供一个normalize()方法，用于将字符的不同表示方法统一为同样的形式，称为 Unicode 正规化：
		'\u01D1'								// "Ǒ"
		'\u004F\u030C'							// "Ǒ"
		'\u004F\u030C'==='\u01D1'				// false
		'\u004F\u030C'.normalize()==='\u01d1'	// true
		'\u004F\u030C'.normalize();				// "Ǒ"
		'\u004F\u030C'.normalize().length		// 1
		'\u004F\u030C'.normalize().charCodeAt(0)	// 465
		'\u004F\u030C'.normalize().codePointAt(0)	// 465
		'\u004F\u030C'.codePointAt(0);				// 79
	normalize方法可以接受一个参数来指定normalize的方式:
		"NFC"，默认参数，表示“标准等价合成”,返回多个简单字符的合成字符;
		"NFD"，表示“标准等价分解”,返回合成字符分解的多个简单字符;
		"NFKC"，表示“兼容等价合成”,返回语义上存在等价，但视觉上不一定等价的合成字符；
		"NFKD"，表示“兼容等价分解”，返回语义上存在等价，但视觉上不一定等价的分解字符
	normalize方法目前不能识别三个或三个以上字符的合成（所以不支持中文）。
	ES6之前的js都只提供一个indexOf方法可以用来确定一个字符串是否包含在另一个字符串中
	ES6新增了includes(s)方法判断参数字符串是否存在、startsWith(s)方法判断参数字符串是否在当前字符串的头部、endsWith(s)方法判断参数字符串是否在当前字符串的尾部。
这三个方法都支持第二个参数，表示开始搜索的位置：
		'Hello world!'.startsWith('world', 6) // true
		'Hello world!'.includes('Hello', 6) // false
	ES6为字符串实例新增一个repeat方法，返回一个新字符串，表示将原字符串重复n次：
		'x'.repeat(3) // "xxx"
		'x'.repeat(0) // ""
	repeat方法可以接收除了 <=-1 和 Infinity的所有数字以及字符：'x'.repeat(2.9) // "xx"		'x'.repeat(-0.9) //""
	ES2017 引入了字符串补全长度的方法：padStart()用于头部补全，padEnd()用于尾部补全：
		'x'.padStart(5, 'ab') // 'ababx' 如果省略第二个参数，默认使用空格补全长度。
		'x'.padEnd(5, 'ab') // 'xabab'	如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
	ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()[这个方法会消除字符串两端的空格]一致，trimStart()只消除字符串头部的空格，
trimEnd()只消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。
	
	第四章 正则表达式增强
	ES5构造正则表达式对象的合法语法：
		var regex = /xyz/i;
		var regex = new RegExp('xyz', 'i');
		var regex = new RegExp(/xyz/i);
	ES5中不合法的语法：
		var regex = new RegExp(/xyz/, 'i');		//报错
	ES6允许上面的语法，并且会使用后面的参数替换前面的修饰符：
		new RegExp(/abc/ig, 'i').flags		// "i"
	ES6标准将字符串的match()、replace()、search()和split()方法实现改为调用RegExp的实例方法，实现了所有与正则相关的方法，全都定义在RegExp对象上。
	ES6为正则表达式对象新增了Unicode模式，使用u修饰符：
		/^\uD83D/.test('\uD83D\uDC2A') // true	这里\uD83D\uDC2A是一个字符，但是js不能识别这种需要4个字节的字符，当成了两个字符，所以匹配成功
		/^\uD83D/u.test('\uD83D\uDC2A'')	//false 使用u修饰符后正确的识别了原字符
		/^.$/.test('𠮷') // false
		/^.$/u.test('𠮷') // true
	正则表达式中使用大括号表示 Unicode 字符必须要加u修饰符才能正确匹配：
		/\u{61}/.test('a') // false
		/\u{61}/u.test('a') // true
		/\u{20BB7}/u.test('𠮷') // true
	Unicode模式下可以正确识别非规范字符：
		/K/i.test('\u212A')	//false
		/K/iu.test('\u212A') //true
	正则表达式对象新增一个unicode属性可以返回是否为Unicode模式。
	ES6为正则表达式对象新增了粘连模式，使用y修饰符。
	y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确
保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
		var s = 'aaa_aa_a';
		var r1 = /a+/g;
		var r2 = /a+/y;
		r1.exec(s) // ["aaa"]
		r2.exec(s) // ["aaa"]
		r1.exec(s) // ["aa"]
		r2.exec(s) // null
	字符串的match方法中，正则表达式只使用y修饰符，只会返回第一个匹配项，如果需要返回所有的匹配项，还需要使用g修饰符：
		'a1a2a3'.match(/a\d/y) // ["a1"]
		'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]
	ES6中正则实例对象新增了sticky属性，表示是否设置了y修饰符。
	ES6 为正则表达式新增了flags属性，返回正则表达式的修饰符。
		/abc/ig.source		// "abc"，ES5中正则表达式的source属性返回模式字符串
		/abc/ig.flags		// "ig",ES6中正则表达式的flags属性返回修饰符
	正则表达式中.字符表示任意字符，但是不能表示4个字节的字符和行终止符：
		/^.$/.test('\u20bb7') 	// false
		/^.$/u.test('\u20bb7') 	// true	使用u修饰符可以用.匹配4个字节的字符
		/^.$/.test("\n")		//false	不能识别换行符
		/^.$/.test("\r")		//false	不能识别回车符
		/^.$/.test("\u{2028}")	//false	不能识别行分隔符
		/^.$/.test("\u{2029}")	//false	不能识别段分隔符
		/^./m.test("ab\ncd")	//true	多行修饰符m可以匹配换行符
	ES2018 引入s修饰符，称为dotAll模式，使得.可以匹配任意单个字符：
		/^.$/s.test("\n")		// true
		/^.$/s.test('\u20bb7') 	// false	s修饰符还是不能识别4个字节的字符
	正则表达式对象也相应的新增了一个dotAll属性，表示是否设置了s修饰符。
	ES2018之前JS不支持后行(否定)断言，只支持先行(否定)断言。
	先行断言：x只有在y前面才匹配，必须写成/x(?=y)/
		/\d+(?=%)/.exec('80%ab');		// ["80"]
	先行否定断言：x只有不在y前面才匹配，必须写成/x(?!y)/
		/\d+(?!%)/.exec('5% not 4'); 	// ["4"]
	ES2018开始支持后行(否定)断言，V8引擎4.9版（Chrome 62）开始提供支持。
	后行断言：x只有在y后面才匹配，必须写成/(?<=y)x/
		/(?<=\$)\d+/.exec("100 and $101 or #102");	// ["101"]
		"100 and $101 or #102".replace(/(?<=\$)\d+/,"99")	// "100 and $99 or #102"
	后行否定断言：x只有不在y后面才匹配，必须写成/(?<!y)x/
		/(?<!\$)\d+/.exec("100 and $101 or #102");	// ["100"]
	ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符,格式：
		\p{UnicodePropertyName=UnicodePropertyValue}
		/\p{Script=Greek}/u.test('π')	//true	\p{Script=Greek}/u表示匹配一个希腊文字符
	对于某些属性，可以只写属性名，或者只写属性值：
		/^\p{Decimal_Number}+$/u.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼')	// true	匹配十进制数字
		/\p{Number}+/u	// 匹配任意数字字符（包括罗马数字）
		\p{White_Space}	// 匹配所有空格
	普通组匹配,只能用数字序号引用匹配项：
		const matchArr = /(\d{4})-(\d{2})-(\d{2})/.exec('1999-12-31');
		matchArr[0]		// "1999-12-31"
		matchArr[1]		// "1999"
		matchArr[2]		//	"12"
		matchArr[3]		//	"31"
	ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。
		const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
		const matchArr = RE_DATE.exec('1999-12-31')；
		matchArr.groups.year		// "1999"
		matchArr.groups.month		// "12"
		matchArr.groups.day			// "31"
	使用解构赋值从组匹配中取值：
		let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
		one		// foo
		tow 	// bar
	使用具名组替换：
		let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
		'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
		// '02/01/2015'
	正则表达式内部可以使用组名称代替\i引用组：
		/^(?<word>[a-z]+)!\k<word>$/ 等价于 /^(?<word>[a-z]+)!\1$/ 	（二者使用==和===运算返回false）
	ES6现在有一个新提案，希望增加String.prototype.matchAll方法，返回一个遍历器，一次性取出字符串中所有匹配正则表达式的匹配性：
		const string = 'test1test2test3';
		const regex = /t(e)(st(\d?))/g;
		for (const match of string.matchAll(regex)) {
  			console.log(match);
		}
		// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
		// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
		// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]

	第五章 数值的扩展
	ES6之前的js表示数值的合法方式：
		普通十进制：57
		八进制：071
		十六进制：0x39
	ES6标准中，八进制写法应该写为：0o71或者0O71，新增二进制写法：0b11 或 0B11
	使用Number函数可以把二进制或八进制数值转为十进制：Number(0b11)	//3
	Number对象新增Number.isFinite()方法，用来检查一个数值是否为有限的（finite），即不是Infinity，参数类型不是数值，Number.isFinite
总是返回false。新增Number.isNaN()方法，用来检查一个值是否为NaN。
	全局方法isFinite()和isNaN()都是先调用Number()将非数值的值转为数值，再进行判断，Number.isFinite()和Number.isNaN()不会这样转换，
		isNaN("NaN") // true
		Number.isNaN("NaN") // false	"NaN"是字符串，不会被转为数字
		Number.isNaN("NaN" / "NaN") // true	 这里"NaN" / "NaN"在运算前会转为数字NaN,运算后还是得到NaN
	ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
	Number.isInteger()用来判断一个数值是否为整数。	
		Number.isInteger(25.0) // true 25.0和25内部存储相同
		Number.isInteger('15') // false 非数值返回false
	当小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，就会导致超出的位被丢弃，造成误判：
		Number.isInteger(3.0000000000000002) // true
	ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。64位浮点数格式这个值位2^-52
Number.EPSILON实际上是 JavaScript 能够表示的最小精度
		0.1+0.2-0.3===0 //false 
		0.1+0.2-0.3<Number.EPSILON //true
	ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示能够准确表示的整数范围的上下限：
		Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
		Number.MIN_SAFE_INTEGER === -9007199254740991
	Number.isSafeInteger()用来判断一个整数是否落在上面的范围之内。

	Math对象新增一个trunc方法，用于去除一个数的小数部分，返回整数部分。
		Math.trunc(4.1) // 4
		Math.trunc('123.456') // 123
		Math.trunc('foo');    // NaN
	Math对象新增一个sign方法，用于判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
		Math.sign(-5) // -1
		Math.sign(5) // +1
		Math.sign(0) // +0
		Math.sign(-0) // -0
		Math.sign(NaN) // NaN
		Math.sign('9')  // +1
	Math对象新增一个cbrt方法，用于计算一个数的立方根。非数值先使用Number方法将其转为数值。
	Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。
		Math.clz32(0b01000000000000000000000000000000) // 1
	Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。
	Math.fround方法返回一个数的32位单精度浮点数形式（将64位双精度浮点数转为32位单精度浮点数）。
	Math.hypot方法返回所有参数的平方和的平方根（勾股定理，但是参数可以超过两个）。
	Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。
	Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。
	Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。
	Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。
	ES6 新增了 6 个双曲函数方法，这里不介绍了。
	ES2016 新增了一个指数运算符（**）：
		2 ** 2 // 4
		2 ** 3 // 8
		2 ** 3 ** 2 == 2 ** (3 ** 2)	//512 右结合
		let b = 4;
		b **= 3;	// b = b ** 3

	第六章 函数的扩展
	ES6 允许为函数的参数设置默认值：
		function log(x, y = 'World') {
			console.log(x, y);
		}
		log('Hello', '') // Hello
		log('Hello') // Hello World
	函数参数的默认值不是在声明时传值的，而是每次函数调用都重新计算默认值表达式的值。
		let x = 99;
		function foo(p = x + 1) {
			console.log(p);
		}
		foo() // 100
		x = 100;
		foo() // 101
	参数默认值使用解构赋值：
		function foo({x, y = 5} = {}) {
			console.log(x, y);
		}
		foo() // undefined 5
	定义了默认值的参数，应该是函数的尾参数，否则这个参数不能省略：
		function f(x = 1, y) {
			return [x, y];
		}
		f(, 1) // 报错
		f(2) // [2, undefined])
	为参数指定了默认值后，函数的length属性将失真（这个属性可以返回函数预期传入的参数个数）。
		(function (a = 0, b, c) {}).length // 0
	暂时性死区：
		var x = 1;
		function foo(x = x) {...}
		foo() // ReferenceError: x is not defined
	参数默认值为函数时，该函数不能使用宿主函数中声明的变量（参数除外）
		function bar(func = () => foo) {
			let foo = 'inner';
			console.log(func());
		}
		bar() // ReferenceError: foo is not defined

		function bar(func = () => kk,kk) {
      		console.log(func());	//5
		}
		bar(undefined,5)
	ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，可以用来替换arguments对象（arguments对象是一个类似数组的对象，
但是不是数组）。
		function add(...values) {...}
		add(2, 5, 3);
		function push(array, ...items) {...}
		push([], 1, 2, 3);
	ES6规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
		// 报错
		function doSomething(a, b = a) {
			'use strict';
			// code
		}
	各大浏览器很早就支持函数的name属性，但是这个属性一直都不是规范的要求，ES6将这个属性正式纳入语言规范。
		var f = function () {};
		f.name 		// ES5返回：""
		f.name 		// ES6返回："f"
		const bar = function baz() {};
		bar.name // ES5、ES6都返回原名称 "baz"	
	ES6 允许使用“箭头”（=>）定义函数:
		var f = v => v;
		var sum = (num1, num2) => { return num1 + num2; }
		let getTempItem = id => ({ id: id, name: "Temp" });		//返回对象
		let fn = () => void doesNotReturn();					//没有返回值
		构造数组：
		const numbers = (...nums) => nums;
		numbers(1, 2, 3, 4, 5)
	箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
		function foo() {
			setTimeout(() => {
				console.log('id:', this.id);	//让setTimeout里面的this绑定定义时所在的作用域，setTimeout中使用普通函数则执行时this执行全局this
			}, 100);
		}
		var id = 21;
		foo.call({ id: 42 });		// id: 42
	将ES6的箭头函数转换为ES5 版本的普通函数，就可以清楚地看成箭头函数里面根本没有自己的this，而是引用外层的this：
	箭头函数中，arguments、super、new.target也不存在，实际是指向外层函数的对应变量。
		function foo() {
			setTimeout(() => {
				console.log('args:', arguments);
			}, 100);
		}
		foo(2, 4, 6, 8)		// args: [2, 4, 6, 8]
	对象不构成单独的作用域，所以对象中不适用箭头函数：对象中的函数内部的this不指向这个对象。
		const cat = {
			lives: 9,
			jumps: () => {
				this.lives--;
			}
		}
	尾调用（Tail Call）是函数式编程的一个重要概念,指的是某个函数的最后一步是调用另一个函数。
		function f(x){
			return g(x);
		}
	这种不属于尾调用：
		function f(x){
			g(x);	
			//这里隐藏了返回：return undefined
		}
	函数调用会在内存形成一个“调用记录”，通常称为“调用帧”，保存着调用位置和内部变量等信息。
	如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。
如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
	尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层
函数的调用帧，取代外层函数的调用帧就可以了。
	尾调用优化：只保留内层函数的调用帧，可以节省内存。
	函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
	递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。
	对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
	递归计算斐波拉契数列：
		function Fibonacci (n) {
			if ( n <= 1 ) {return 1};
			return Fibonacci(n - 1) + Fibonacci(n - 2);
		}
		Fibonacci(100) // 超时
	ES6标准规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。
	柯里化（currying）：多参数的函数转换成单参数的形式。
		function currying(fn, n) {
			return function (m) {
				return fn.call(this, m, n);
			};
		}
	其实是把原函数的多个参数分开传入，原函数的参数可以分为两类，一类是需输入的数据，另一类其实是函数自身的状态。所以柯里化
过程把函数状态参数作为参数传递给柯里化函数，然后返回一个包装了状态参数的新函数。
	ES6 的尾调用优化只在严格模式下开启，正常模式是无效的，因为在正常模式下，函数内部的两个变量（arguments和caller），可以
跟踪函数的调用栈（外层调用者函数），在尾调用优化发生时，函数的调用栈会改写，因此这两个变量就会失真。
	蹦床函数（trampoline）可以将递归执行转为循环执行：
		function trampoline(f) {
			while (f && f instanceof Function) {
				f = f();
			}
			return f;
		}
	ES2017 允许函数的最后一个参数有尾逗号(定义和调用时都可以加一个尾逗号):
		function fnc(a,b,){...}
		fnc(1,2,);
	
	第七章 扩展的数组
	创建数组时设置初始值：let arr = [1,2];
	数组中添加一组值：arr.push(3,4);
	ES6新增扩展运算符(...)，用于将数组转为一组值（展开数组）：console.log(...arr);	// 1 2 3 4
	扩展运算符可以看成是rest 参数的逆运算：
		function push(array, ...items) {
			array.push(...items);
		}
		push(arr,...[5,6]);
	扩展运算符后面是一个空数组，不产生任何效果：
		[...[], 1]	// [1]
		[...[]]			// []
	只有函数调用时，扩展运算符才可以放在圆括号中:
		(...[1, 2])	//报错
	扩展运算符可以替换函数的apply方法，apply方法是ES6之前使用数组向函数传入多个参数的方法。
		Math.max.apply(null,arr);
		Math.max(...arr);
	ES5复制数组：let arr2 = arr.concat();
	ES5合并数组：let arr3 = arr.concat(arr,[7,8]);
	使用扩展运算符复制数组：let arr4 = [...arr];
	使用扩展运算符合并数组：let arr5 = [...arr,...[7,8]];
	如果数组成员是对象，则复制和合并都是进行的浅拷贝。
	同时使用解构赋值：
		const [first, ...rest] = [1, 2, 3, 4, 5];
		first // 1
		rest  // [2, 3, 4, 5]
	将字符串转为真正的数组: [...'hello']		// [ "h", "e", "l", "l", "o" ]
	使用扩展运算符转换字符串为数组时，总是能够正确识别四个字节保存的字符：
		'🚀🐏'.length 				// 4
		[...'🚀🐏'].length		// 2
	任何定义了遍历器（Iterator）接口的对象,都可以用扩展运算符转为真正的数组(扩展运算符内部调用的是数据结构的 Iterator 接口)。
		let nodeList = document.querySelectorAll('div');
		let array = [...nodeList];
	Array对象新增一个from方法，用于将类似数组的对象和可遍历的对象转为真正的数组：
		let arrayLike = {
			'0': 'a',
			'1': 'b',
			'2': 'c',
			length: 3
		};
		//ES5
		var arr1 = Array.prototype.slice.call(arrayLike); // ['a', 'b', 'c']
		//ES6
		let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
	类似数组的对象是指任何有length属性的对象，都可以通过Array.from方法转为数组:
		Array.from({ length: 2 }, () => 'jack')
		// ['jack', 'jack']
	Array.from还可以接受一个函数作为第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组。
		Array.from(arrayLike, x => x * x);
	Array.from还可以将字符串对象转为数组，并且可以正确处理4个字节的字符。
		Array.from('ab🐏')	// ["a", "b", "🐏"]
	Array对象新增一个of方法，用于将一组值，转换为数组：
		Array.of(3, 11, 8) // [3,11,8]
		Array.of(3)	//[3]
	对比Array()构造函数：
		Array(3, 11, 8) // [3,11,8]
		Array(3)	// [, , ,]
	数组实例新增一个copyWithin方法，用于在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组：
		[1, 2, 3, 4, 5].copyWithin(0, 3, 4)		// [4, 2, 3, 4, 5]
		[1, 2, 3, 4, 5].copyWithin(0, 3)			// [4, 5, 3, 4, 5]
		[1, 2, 3, 4, 5].copyWithin(0, -2, -1)	// [4, 2, 3, 4, 5]
	数组实例新增find方法，用于找出第一个符合条件的数组成员，没有就返回undefined. 参数为回调函数，且回调函数返回值类型为boolean，回调函数可以接受三个参数，
依次为当前的值、当前的位置和原数组。
		[1, 4, -5, 10].find((n) => n < 0)
		[1, 5, 10, 15].find(function(value, index, arr) {
  			return value > 9;
		})
	数组实例新增findIndex方法,用于找出第一个符合条件的数组成员的索引位置，找不到就返回-1，参数和find方法相同。
	数组实例新增fill方法，用于使用给定值填充一个数组。
		['a', 'b', 'c'].fill(7)		//[7,7,7]
		['a', 'b', 'c'].fill(7, 1, 2)		// ['a', 7, 'c'] 指定填充的起始结束位置
	ES6为数组实例对象提供三个新的方法：entries()，keys()和values()，用于遍历数组：
		for (let index of ['a', 'b'].keys()) {
			console.log(index);		//[].keys()方法返回键名的遍历器
		}
		// 0
		// 1
		for (let elem of ['a', 'b'].values()) {
			console.log(elem);		//[].values()方法返回数组元素的遍历器
		}
		// 'a'
		// 'b'
		for (let [index, elem] of ['a', 'b'].entries()) {
			console.log(index, elem);	//[].entries()方法返回数组键值对的遍历器
		}
		// 0 "a"
		// 1 "b"
		entries.next().value每次返回单个键值对
	ES2016为数组实例引入includes方法，返回一个布尔值，表示某个数组是否包含给定的值：
		[1, 2, 3].includes(2)     	// true
		[1, 2, 3].includes(3, 3);  	// false 开始查找索引位置为3
	数组实例新增的flat()用于将嵌套的数组“拉平”，变成一维的数组：
		[[1,2],3,4].flat();			// [1,2,3,4]
		[[1,2,[3,4],5],6,7].flat();	// [1,2,[3,4],5,6,7]	这里可以看出flat方法不能拉平多层嵌套数组，只能拉平一层。
		[[1,2,[3,4],5],6,7].flat(2);// [1,2,3,4,5,6,7]		拉平多层嵌套需要为flat方法设置参数，如果所有嵌套层都需要拉平，可以使用Infinity作为参数
		[1, 2, , 4, 5].flat()；		// [1, 2, 4, 5]			空位将被跳过
	flatMap()方法对原数组的每个成员执行一个函数，然后对返回值组成的数组执行flat()方法，并且只能展开一层数组。
		[2, 3, 4].flatMap((x) => [x, x * 2])		// [2, 4, 3, 6, 4, 8]
	flap方法和flatMap方法都不修改原数组。
	数组的空位没有任何值，而undefined、null都是存在的值。js对空位的处理一直都不统一，forEach方法等会跳过空位，toString等方法则把空位当做undefined处理；
ES6希望将空位当做undefined处理：from方法会将数组的空位转为undefined，扩展运算符（...）也会将空位转为undefined，for...of循环也会遍历空位，entries()类
方法将空位当做undefined处理。
	
	第八章 对象的扩展
	ES6之前不允许直接在对象中写变量或函数，ES6开始允许这种写法：
		const obj = 'bar';
		const func = v=> v**v;
		const newObj = {obj,func};
		newObj.obj;	// "bar"
		newObj.func(2);	// 4
	在使用字面量方式定义对象（使用大括号）时，ES5不能使用 [表达式] 来表示键名，只支持标准写法：
		var obj = {
			foo: true
		};
	ES6开始支持这种 [表达式] 来表示键名：
		let propKey = 'foo';
		let obj = {
			[propKey]: true,
			['a' + 'bc']: 123,
			['h' + 'ello']() {
				return 'hi';
			}
		};
	错误的用法：
		let obj = {[propKey]}	//这种写法会报错
	属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]：
		const keyA = {a: 1};
		const myObject = {
			[keyA]: 'valueA'
		}
		myObject	// {[object Object]: "valueA"}
	get和set方法的name属性不是直接通过方法键名获取：
		const obj = {
			get foo() {},
			set foo(x) {}
		};
		obj.foo.name	//报错
		Object.getOwnPropertyDescriptor(obj, 'foo').get.name	// get foo	这里会有一个前置的get
	bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。
	如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
	对象属性的描述对象的enumerable属性值规定了，某些操作会忽略当前属性：
		for...in循环：只遍历对象自身的和继承的可枚举的属性(键名)。
		Object.keys()：返回对象自身的所有可枚举的属性的键名。
		JSON.stringify()：只串行化对象自身的可枚举的属性。
		Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。[ES6新增]
	ES6规定，所有 Class 的原型的方法都是不可枚举的。
		Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
		// false
	Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。
	使用for...in、Object.keys(obj)、Object.getOwnPropertyNames(obj)、Object.getOwnPropertySymbols(obj)、
Reflect.ownKeys(obj)遍历对象的键名，都遵守同样的属性遍历的次序规则：
		首先遍历所有数值键，按照数值升序排列。
		其次遍历所有字符串键，按照加入时间升序排列。
		最后遍历所有 Symbol 键，按照加入时间升序排列。
		Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
		// ['2', '10', 'b', 'a', Symbol()]
	ES6 新增一个关键字super，指向当前对象的原型对象,super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。
		const proto = {
			foo: 'hello'
		};

		const obj = {
			foo: 'world',
			find() {
				return super.foo;
			}
		};

		Object.setPrototypeOf(obj, proto);
		obj.find() // "hello"
	对象的方法声明使用下面的写法不能引用this和super：
		let obj1 = {
			name: "zw",
			foo: function(){
				return this.name	//报错
			}
			bar: function(){
				return super.name	//报错
			}
		}
	对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的、但尚未被读取的属性，分配到指定的对象上面:
		let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
		z	//	{ a: 3, b: 4 }
		let { ...z } = null; // 运行时错误
		let { ...z } = undefined; // 运行时错误
	解构赋值必须是最后一个参数，否则会报错。
	解构赋值的拷贝是浅拷贝
	扩展运算符的解构赋值，不能复制继承自原型对象的属性:
		let o1 = { a: 1 };
		let o2 = { b: 2 };
		o2.__proto__ = o1;
		let { ...o3 } = o2;
		o3 // { b: 2 }
	对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中:
		let z = { a: 3, b: 4 };
		let n = { ...z };
		n // { a: 3, b: 4 }		这种写法和 let {...n} = z;一样都不能复制继承自原型对象的属性
	数组：
		let foo = { ...['a', 'b', 'c'] };
		foo		// {0: "a", 1: "b", 2: "c"}
	原始类型值：
		{...1} 			// {}
		{...undefined} 	// {}
	字符串：
		{...'hello'}	// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
	对象的扩展运算符等同于使用Object.assign()方法。
		let aClone = { ...a };
		// 等同于
		let aClone = Object.assign({}, a);
	合并两个对象：
		let ab = { ...a, ...b };
	复制对象后覆盖原对象的属性：
		let aWithOverrides = { ...a, x: 1, y: 2 };
	复制对象时设置属性默认值：
		let aWithDefaults = { x: 1, y: 2, ...a };	//这里要求原对象没有x、y属性，（x/y为null或undefined都会被继承）
	
	ES6为Object对象新增一个is方法，用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致，不同在于+0不等于-0，NaN等于自身：
		Object.is('foo', 'foo')	//true
		Object.is({}, {})		//false
		Object.is(+0, -0) 		//false
		Object.is(NaN, NaN) 	//true
	Object新增一个assign方法，用于对象的合并，将源对象的所有可枚举属性(包括方法)，复制到目标对象，并返回目标对象
		let target = {a:1};
		Object.assign(target, {b:2}, {c:3,meth(param){console.log(param)}});
		target;		// {a:1,b:2,c:3,meth: ƒ}
	源对象的同名属性将覆盖目标对象的属性，排在后面的源对象的同名属性会覆盖前面的源对象的属性。
	如果只有一个参数，Object.assign会直接返回该参数，如果该参数不是对象，则会先转成对象，然后返回。undefined和null无法转成对象将会报错
	非对象参数出现在源对象的位置，除了字符串外都会跳过：
		Object.assign({}, null, 1, true, 'ab');	//{ "0": "a", "1": "b"}
	assign方法只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。拷贝时执行浅拷贝。
	Object.assign将数组视为对象：
		Object.assign([1, 2, 3], [4, 5])		// [4, 5, 3]
	assign方法的源对象参数的属性为取值函数时(get方法)，会前求值然后返回：
		Object.assign({}, {get foo() { return 1 }});	// {foo: 1}
	ES2017为Object对象新增getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。
		Object.getOwnPropertyDescriptors({foo: 123, get bar() { return 'abc' }})
	使用getOwnPropertyDescriptors()方法和defineProperties()方法可以实现get、set属性的复制：
		Object.defineProperties(target, Object.getOwnPropertyDescriptors({get foo() { return 1 }}));
	__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。
	ES6标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。通常应该使用
Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替__proto__属性。
	Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
		Object.fromEntries([
			['foo', 'bar'],
			['baz', 42]
		]);
		// { foo: "bar", baz: 42 }
	
	第九章 Symbol
	Symbol是ES6引入的新的基础数据类型，ES6当前支持的数据类型：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、
对象（Object）、Symbol。
	Symbol 值通过Symbol函数生成，表示独一无二的值。
	 	let a = Symbol();
		let b = Symbol();
		a === b;	//false
		let c = Symbol("c");
		let d = Symbol("c");
		c === d;	//false
		typeof a 	//symbol
		c.description;	//c
	Symbol 值不能与其他类型的值进行运算，会报错。Symbol 值可以显式转为字符串和布尔值：
		String(Symbol("a"))		//Symbol("a")
		if (Symbol()) {console.log("1")}	// 1
	使用Symbol类型变量作为对象的属性名：
		let attr1 = Symbol();
		let obj = {[attr1]:1};
		obj[attr1]	// 1	访问Symbol类型的属性，只能使用这种[attr1]格式，不能使用obj.attr1
	Symbol类型变量作为属性名的属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、
JSON.stringify()返回，Object.getOwnPropertySymbols方法可以获取对象的所有Symbol属性。Reflect.ownKeys方法可以返回所有类型的键名，
包括常规键名和 Symbol 键名。
		let obj = {
			[Symbol('my_key')]: 1,
			enum: 2,
			nonEnum: 3
		};
		Object.keys(obj);		// ["enum", "nonEnum"]
		Object.getOwnPropertySymbols(obj);	//[Symbol(my_key)]
		Reflect.ownKeys(obj)	//  ["enum", "nonEnum", Symbol(my_key)]
	Symbol.for方法接受一个字符串作为参数，先在全局环境中搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，
否则就新建这个Symbol值，然后将其登记在全局环境中，再返回这个 Symbol 值。这里的全局环境是当前window，内部的所有嵌套的 iframe和
各个service worker都可以取到全局环境中的登记Symbol值。
		Symbol.for("bar") === Symbol.for("bar")	//true
	Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。
		let s1 = Symbol.for("foo");
		Symbol.keyFor(s1) // "foo"
	ES6 提供 11 个内置的 Symbol 值，指向语言内部使用的方法。Symbol.hasInstance指向一个内部方法。当其他对象使用instanceof运算符，
判断是否为该对象的实例时，会调用这个方法。
	
	第十章 Set和Map数据结构
	ES6新增数据结构Set和Map，Set表示集合，特点是不保存重复的值，因为js变量没有静态类型，所以Set可以保存不同类型的变量（值），集合这种
结构本身不强调内部元素的顺序，但是ES6的Set实现会按照插入的顺序保存元素，所以在遍历时会按照插入顺序遍历。
	创建Set对象：
			let mySet = new Set();
	创建Set对象时使用数组（或任何部署了Iterator接口的类型对象，如字符串）初始化：
			let theSet = new Set([1,2,2,3]);
			let strSet = new Set('ababc');
	添加元素：
			mySet.add(1);
	数组去重：
			let arr = [1,2,2,3];
			arr = [...new Set(arr)];					//扩展运算符内部使用for...of循环，for...of循环可以遍历Iterator实现
			或：
			arr = Array.from(new Set(arr));				//Array.from方法可以把Set转为数组
	尽管在js中，NaN!==NaN，Set却认为所有的NaN是相同的值：
			let NaNSet = new Set([NaN,NaN]);
			NaNSet.size	// 1
	{}表示空对象，{}!={},Set把每个插入的{}当作不同的元素。
	Set实例对象的属性：
		constructor属性返回构造函数：
			mySet=new mySet.constructor([1,2,3,3,3,4]);	//这里constructor看起来像是函数，但其实是属性
		size属性返回Set实例保存的元素数量。
	Set实例对象的方法：
		add(val)方法插入一个元素，返回集合本身；
		delete(val)方法删除val元素，返回true表示成功，false表示失败（删除一个不存在于集合中的元素就会返回false）；
		has(val)方法返回true或false，表示集合中是否存在val元素；
		clear()方法清空集合，没有返回值。
	Iterator接口定义了keys方法、values方法、entries方法，这些方法返回遍历器对象，Set部署了Iterator接口，所以Set
实例对象就具有了这些方法。
	Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。entries方法
返回的遍历器，同时包括键名和键值，所以每次返回一个数组，它的两个成员完全相等。
	Set实例默认就是可遍历的(实际是调用了values方法)：
		for (let x of mySet) {
			console.log(x);
		}
	Set实例具有一个forEach方法，参数为一个处理函数，处理函数的参数是遍历时的键值、键名、集合本身：
		mySet.forEach((value, key, mySet) => console.log(key + ' : ' + value));	//这里set实例的键值和键名相同
	求并集、交集、差集：
		let a = new Set([1, 2, 3]);
		let b = new Set([4, 3, 2]);

		// 并集
		let union = new Set([...a, ...b]);
		// Set {1, 2, 3, 4}

		// 交集
		let intersect = new Set([...a].filter(x => b.has(x)));
		// set {2, 3}

		// 差集
		let difference = new Set([...a].filter(x => !b.has(x)));
		// Set {1}
	ES6提供WeakSet 数据结构，与 Set 类似，也是不重复的值的集合，不同在于WeakSet实例只能保存对象（的弱引用），当保存的
对象不再具有其他非弱引用，垃圾回收器就会回收这个对象（即垃圾回收器不考虑弱引用）。
	ES6 规定 WeakSet 不可遍历，也没有size属性和clear方法，因为WeakSet实例中的对象弱引用随时可能被回收。

	尽管js的任何对象本身都是一个hash数据结构，但是这种hash结构的键只能是字符串，如果使用其他类型的值作为键，js会进行类型
转换，这通常不是我们需要的。
	ES6提供Map数据结构，Map也是一个hash数据结构，和对象的不同在于它允许使用任意类型值作为键：
		let myMap = new Map();
		myMap.set({},"{}1");
		myMap.set({},"{}2");
		myMap.set(undefined,"{}3");
		myMap.set(NaN,"{}4");
		myMap;
		//{ ...
			[0: {Object => "{}1"}
			1: {Object => "{}2"}
			2: {undefined => "{}3"}
			3: {NaN => "{}4"}]
		}
		myMap.set(NaN,NaN);
		myMap.get(NaN);	//NaN
	可见，Map和Set一样，使用NaN作为键时，将所有NaN看成同一个值
	使用数组作为参数初始化Map实例：
		let myMap = new Map([[1,"一"],[2:"二"]]);
		// myMap = new Map([{"a":"A"}]); 这种写法不会报错，但是不能正确识别，会将undefined=>undefined保存到map中
		// myMap = new Map([[1,"①","一"]]);	这种写法内部数组中的第二个元素后的元素都会被忽略。
	使用Set实例初始化Map实例：
		const set = new Set([
			['foo', 1],
			['bar', 2]
		]);
		const m1 = new Map(set);
		m1.get('foo') // 1
	map实例读取一个未知的键，则返回undefined。
		myMap.get(x);	//undefined
		myMap.set(['a'], 555);
		myMap.get(['a']) // undefined	//这里set和get方法的参数中的['a']其实是不同的两个对象
	Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这样看起来不同的值为NaN的变量都是引用了同一个地址（？）。
	Map实例对象属性和方法：
		size属性返回map实例中保存的键值对的数量；
		set方法设置键值对，返回map实例本身
		get方法根据键获取对应的值
		has方法用来判断某个键是否存在于map实例中
		delete方法根据键名删除键值对
		clear方法清空map中的所有键值对
	和Set实例一样，Map实例也可以使用keys、values、entries、forEach方法遍历保存的元素，遍历顺序是保存键值对的顺序。
		for (let [key, value] of map.entries()) {
			console.log(key, value);
		}
		for (let [key, value] of map) {	//这里直接遍历map和使用map.entries()一样
			console.log(key, value);
		}
	使用forEach遍历：
		const reporter = {
			report: function(key, value) {
				console.log("Key: %s, Value: %s", key, value);
			}
		};

		map.forEach(function(value, key, map) {
			this.report(key, value);
		}, reporter);
	转为数组：
		[...map.keys()];
		[...map];
	根据键名过滤：
		map = new Map(
			[...map].filter(([k, v]) => k < 3)
		);
	排序：
		myMap = new Map([[2,22],[1,11],[3,33]]);
		myMap = new Map([...myMap].sort(([k1,v1],[k2,v2])=>k1-k2));	//升序
		myMap = new Map([...myMap].sort(([k1,v1],[k2,v2])=>v2-v1));	//降序
	如果Map实例的键名都是字符串，可以选择转为对象 JSON。如果Map实例的键名有非字符串，可以选择转为数组 JSON。
	WeakMap结构与Map结构类似，不同在于WeakMap只接受对象（的弱引用）作为键名（null也不能作为键名），不接受其他类型的值作为键名。
	WeakMap实例没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性，也不能清空（没有clear方法）。